??cophy
?rphy_H
??cophy
?#
rcophylo_HP
?max
load('/Volumes/NICOLEWORK/Omega exploration/ExpG_omega-1.RData')
output$statistics
load('/Volumes/NICOLEWORK/Omega exploration/ExpG_omega-1noPDE.RData')
output$statistics
summary(ouput)
summary(output)
output$Ptrees[[1]]
output$Ptrees[[2]]
output$Ptrees[[3]]
output$Ptrees
output$Ptrees[[42]]
summary(output)
Sys.time()
load(".RData")
load("~/Desktop/Fix R time error..RData")
load("~/Desktop/Fix R time error.RData")
load('~/Desktop/Fix R time error.Rdata')
load("/Users/NicoleFortuna/Desktop/Fix R time error.Rdata")
save.image()
ls()
Sys.setenv(TZ="Australia/Brisbane")#
t<-Sys.time()#
as.POSIXct(t, tz=getOption("tz"))
#########################################################################################################################
################ A script to understand the evulutionary patterns of the Exploration C parameter screen #################
#########################################################################################################################
#
# Collecting relevant files#
ExpC7.files<-list.files(path = "~/Desktop/ExplorationC7", all.files = TRUE, full.names = TRUE, no.. =TRUE)#
#
ExpC7.sig.0.0<-grep("sigma-0.RData", ExpC7.files)#
#
Simulations_sig.0.0	<-c(ExpC7.files[ExpC7.sig.0.0])#
########################## sumarising data for sigma = 0 ###########################
####################################################################################
#
# organising simulations by parameters#
Check.param	<-data.frame(gamma=0,muP=0,sigma=0)#
#
all.data_sig.0.0<-list()#
for (i in 1:length(Simulations_sig.0.0)){#
	load(Simulations_sig.0.0[i])#
	Check.row<-which(Check.param$gamma==(output$parameters[4]) & Check.param$muP==output$parameters[6] & Check.param$sigma==output$parameters[5])#
	print(Check.row)#
	if (length(Check.row)>0){ # have seen these parameters before#
		all.data_sig.0.0[[Check.row-1]]$statistics<-rbind(all.data_sig.0.0[[Check.row-1]]$statistics, c(output$statistics))#
	} else { # adding these parameters to the record#
		Check.param<-rbind(Check.param,c(output$parameters[4],output$parameters[6],output$parameters[5]))#
		all.data_sig.0.0[[paste("gamma:",output$parameters[4],"sigma:",output$parameters[6],", muP:",output$parameters[5],sep="")]]<-list("parameters"=output$parameters,"statistics"=output$statistics)#
	}#
	print(paste("File",i,"out of", length(Simulations_sig.0.0),sep=" "))#
}#
#
Check.param<-Check.param[-1,]#
#
# Replacing any 0 values with NA#
for (i in 1:length(all.data_sig.0.0)){#
	zero.7<-which(all.data_sig.0.0[[i]]$statistics[,7]==0)#
	zero.8<-which(all.data_sig.0.0[[i]]$statistics[,8]==0)#
	all.data_sig.0.0[[i]]$statistics[,7][zero.7]<-NA#
	all.data_sig.0.0[[i]]$statistics[,8][zero.8]<-NA#
}#
#
mean.survival<-matrix(ncol=2,nrow=length(all.data_sig.0.0))#
colnames(mean.survival)<-c("Mean","Survival")#
for (i in 1:length(all.data_sig.0.0)){#
	mean.survival[i,1]<-mean(all.data_sig.0.0[[i]]$statistics[,7],na.rm=TRUE)#
	mean.survival[i,2]<-length(which(all.data_sig.0.0[[i]]$statistics[,7]>0))/length(all.data_sig.0.0[[i]]$statistics[,7])#
}#
#
zero <-which(mean.survival[,2]==0)#
mean.survival[zero,1]<-0#
#
# plotting mean#
plot(xlim=c(0,6.1),ylim=c(0.015,0.125),x=Check.param$muP,y=Check.param$gamma,xlab="muP",ylab="gamma",pch=15,cex=5.85, col=rgb(1-mean.survival[,1],1-mean.survival[,1],1-mean.survival[,1]))#
#
# plotting survival#
plot(xlim=c(0,6.1),ylim=c(0.015,0.125),x=Check.param$muP,y=Check.param$gamma,xlab="muP",ylab="gamma",pch=15,cex=5.85, col=rgb(1-mean.survival[,2],1-mean.survival[,2],1-mean.survival[,2]))#
########################## sumarising data for sigma = 0.1 ###########################
####################################################################################
#
# organising simulations by parameters#
Check.param	<-data.frame(gamma=0,muP=0,sigma=0)#
#
all.data_sig.0.1<-list()#
for (i in 1:length(Simulations_sig.0.1)){#
	load(Simulations_sig.0.1[i])#
	Check.row<-which(Check.param$gamma>=(output$parameters[4]) & Check.param$muP==output$parameters[6] & Check.param$sigma==output$parameters[5])#
	if (length(Check.row)>0){ # have seen these parameters before#
		all.data_sig.0.1[[Check.row-1]]$statistics<-rbind(all.data[[Check.row-1]]$statistics, c(output$statistics))#
	} else { # adding these parameters to the record#
		Check.param<-rbind(Check.param,c(output$parameters[4],output$parameters[6],output$parameters[5]))#
		all.data_sig.0.1[[paste("gamma:",output$parameters[4],"sigma:",output$parameters[6],", muP:",output$parameters[5],sep="")]]<-list("parameters"=output$parameters,"statistics"=output$statistics)#
	}#
	print(paste("File",i,"out of", length(Simulations_sig.0.1),sep=" "))#
}#
#
Check.param<-Check.param[-1,]#
#
# Replacing any 0 values with NA#
for (i in 1:length(all.data_sig.0.1)){#
	zero.7<-which(all.data_sig.0.1[[i]]$statistics[,7]==0)#
	zero.8<-which(all.data_sig.0.1[[i]]$statistics[,8]==0)#
	all.data_sig.0.1[[i]]$statistics[,7][zero.7]<-NA#
	all.data_sig.0.1[[i]]$statistics[,8][zero.8]<-NA#
}#
#
mean.survival<-matrix(ncol=2,nrow=length(all.data_sig.0.1))#
colnames(mean.survival)<-c("Mean","Survival")#
for (i in 1:length(all.data_sig.0.1)){#
	mean.survival[i,1]<-mean(all.data_sig.0.1[[i]]$statistics[,7],na.rm=TRUE)#
	mean.survival[i,2]<-length(which(all.data_sig.0.1[[i]]$statistics[,7]>0))/length(all.data_sig.0.1[[i]]$statistics[,7])#
}#
#
zero <-which(mean.survival[,2]==0)#
mean.survival[zero,1]<-0#
#
# plotting mean#
plot(xlim=c(0,6.3),ylim=c(0.015,0.125),x=Check.param$muP,y=Check.param$gamma,xlab="muP",ylab="gamma",pch=15,cex=12, col=rgb(1-mean.survival[,1],1-mean.survival[,1],1-mean.survival[,1]))#
#
# plotting survival#
plot(xlim=c(0,6.3),ylim=c(0.015,0.125),x=Check.param$muP,y=Check.param$gamma,xlab="muP",ylab="gamma",pch=15,cex=12, col=rgb(1-mean.survival[,2],1-mean.survival[,2],1-mean.survival[,2]))
ExpC7.files<-list.files(path = "~/Desktop/ExplorationC7", all.files = TRUE, full.names = TRUE, no.. =TRUE)#
#
ExpC7.sig.0.0<-grep("sigma-0.RData", ExpC7.files)#
#
Simulations_sig.0.0	<-c(ExpC7.files[ExpC7.sig.0.0])
########################## sumarising data for sigma = 0 ###########################
####################################################################################
#
# organising simulations by parameters#
Check.param	<-data.frame(gamma=0,muP=0,sigma=0)#
#
all.data_sig.0.0<-list()#
for (i in 1:length(Simulations_sig.0.0)){#
	load(Simulations_sig.0.0[i])#
	Check.row<-which(Check.param$gamma==(output$parameters[4]) & Check.param$muP==output$parameters[6] & Check.param$sigma==output$parameters[5])#
	print(Check.row)#
	if (length(Check.row)>0){ # have seen these parameters before#
		all.data_sig.0.0[[Check.row-1]]$statistics<-rbind(all.data_sig.0.0[[Check.row-1]]$statistics, c(output$statistics))#
	} else { # adding these parameters to the record#
		Check.param<-rbind(Check.param,c(output$parameters[4],output$parameters[6],output$parameters[5]))#
		all.data_sig.0.0[[paste("gamma:",output$parameters[4],"sigma:",output$parameters[6],", muP:",output$parameters[5],sep="")]]<-list("parameters"=output$parameters,"statistics"=output$statistics)#
	}#
	print(paste("File",i,"out of", length(Simulations_sig.0.0),sep=" "))#
}#
#
Check.param<-Check.param[-1,]
for (i in 1:length(all.data_sig.0.0)){#
	zero.7<-which(all.data_sig.0.0[[i]]$statistics[,7]==0)#
	zero.8<-which(all.data_sig.0.0[[i]]$statistics[,8]==0)#
	all.data_sig.0.0[[i]]$statistics[,7][zero.7]<-NA#
	all.data_sig.0.0[[i]]$statistics[,8][zero.8]<-NA#
}
mean.survival<-matrix(ncol=2,nrow=length(all.data_sig.0.0))#
colnames(mean.survival)<-c("Mean","Survival")#
for (i in 1:length(all.data_sig.0.0)){#
	mean.survival[i,1]<-mean(all.data_sig.0.0[[i]]$statistics[,7],na.rm=TRUE)#
	mean.survival[i,2]<-length(which(all.data_sig.0.0[[i]]$statistics[,7]>0))/length(all.data_sig.0.0[[i]]$statistics[,7])#
}
zero <-which(mean.survival[,2]==0)#
mean.survival[zero,1]<-0
# plotting mean#
plot(xlim=c(0,6.1),ylim=c(0.015,0.125),x=Check.param$muP,y=Check.param$gamma,xlab="muP",ylab="gamma",pch=15,cex=5.85, col=rgb(1-mean.survival[,1],1-mean.survival[,1],1-mean.survival[,1]))
# plotting survival#
plot(xlim=c(0,6.1),ylim=c(0.015,0.125),x=Check.param$muP,y=Check.param$gamma,xlab="muP",ylab="gamma",pch=15,cex=5.85, col=rgb(1-mean.survival[,2],1-mean.survival[,2],1-mean.survival[,2]))
# plotting mean#
plot(xlim=c(0,6.1),ylim=c(0.015,0.125),x=Check.param$muP,y=Check.param$gamma,xlab="muP",ylab="gamma",pch=15,cex=5.85, col=rgb(1-mean.survival[,1],1-mean.survival[,1],1-mean.survival[,1]))
# plotting survival#
plot(xlim=c(0,6.1),ylim=c(0.015,0.125),x=Check.param$muP,y=Check.param$gamma,xlab="muP",ylab="gamma",pch=15,cex=5.85, col=rgb(1-mean.survival[,2],1-mean.survival[,2],1-mean.survival[,2]))
# plotting mean#
plot(xlim=c(0,6.1),ylim=c(0.015,0.125),x=Check.param$muP,y=Check.param$gamma,xlab="muP",ylab="gamma",pch=15,cex=5.85, col=rgb(1-mean.survival[,1],1-mean.survival[,1],1-mean.survival[,1]))
# plotting survival#
plot(xlim=c(0,6.1),ylim=c(0.015,0.125),x=Check.param$muP,y=Check.param$gamma,xlab="muP",ylab="gamma",pch=15,cex=5.85, col=rgb(1-mean.survival[,2],1-mean.survival[,2],1-mean.survival[,2]))
# plotting mean#
plot(xlim=c(0,6.1),ylim=c(0.015,0.125),x=Check.param$muP,y=Check.param$gamma,xlab="muP",ylab="gamma",pch=15,cex=5.85, col=rgb(1-mean.survival[,1],1-mean.survival[,1],1-mean.survival[,1]))
# plotting survival#
plot(xlim=c(0,6.1),ylim=c(0.015,0.125),x=Check.param$muP,y=Check.param$gamma,xlab="muP",ylab="gamma",pch=15,cex=5.85, col=rgb(1-mean.survival[,2],1-mean.survival[,2],1-mean.survival[,2]))
# plotting mean#
plot(xlim=c(0,6.1),ylim=c(0.015,0.125),x=Check.param$muP,y=Check.param$gamma,xlab="muP",ylab="gamma",pch=15,cex=5.85, col=rgb(1-mean.survival[,1],1-mean.survival[,1],1-mean.survival[,1]))
#######
library(vegan)#
#
################## ANALYSING EXPLORATION A5 ###################
load('~/Desktop/clustering_files/ExplorationA5 HTree1.RData')#
#
Exp5ACorrelations<-list() # To contain linear fit information#
#
conditions<-c(paste("h=25",c("Shannon","Shannon.NoZero","Simpson", "Simpson.NoZero"), sep="."),paste("h=50",c("Shannon","Shannon.NoZero","Simpson", "Simpson.NoZero"), sep="."), paste("h=75",c("Shannon","Shannon.NoZero","Simpson", "Simpson.NoZero"), sep="."),paste("h=100",c("Shannon","Shannon.NoZero","Simpson", "Simpson.NoZero"), sep="."))#
#
cond<-1#
## CORRELATION WHEN CLUSTER HIGHT IS 100 ###
for (k in 1:length(seq(25,100,25))) {#
	load(paste('~/Desktop/clustering_files/Subtree stats Exploration5A h=',seq(25,100,25)[k],'.RData',sep=""))#
#
	shannonDiv<-rep(NA,100) # Object to hold diversity index for each host tree#
	simpsonDiv<-rep(NA,100) # Object to hold diversity index for each host tree#
	for (i in 1:100) {#
		shannonDiv[i]<-diversity(subtreeStats$size[which(subtreeStats$Htree==i)], index="shannon")#
		simpsonDiv[i]<-diversity(subtreeStats$size[which(subtreeStats$Htree==i)], index="simpson")#
	}#
#
	xShannon<-rep(NA,10000)#
	j<-1#
	for (i in seq(0,9900, 100)) {#
		xShannon[(i+1):(i+100)]<-rep(shannonDiv[j], 100)#
		j<-j+1#
	}#
	y<-output$statistics[,7]#
#
	# Shannon Diversity Plot#
	#plot(x= xShannon, y= y, xlim=c(min(shannonDiv),max(shannonDiv)), ylim=c(0,1), xlab="Host Tree Shannon Diversity Index", 	ylab="Frequency of Infected Host Species")#
	lmShan<-lm(y~xShannon)#
	Exp5ACorrelations[[cond]]<-list(conditions[cond],(lmShan))#
	cond<-cond+1#
	del<-which(y==0) # Which trees resulted in no P infections#
	lmShanNoZero<-lm(y[-del]~xShannon[-del]) # Correlation when only considering trees with parasites#
	Exp5ACorrelations[[cond]]<-list(conditions[cond],(lmShanNoZero))#
	cond<-cond+1#
#
	xSimpson<-rep(NA,10000)#
	j<-1#
	for (i in seq(0,9900, 100)) {#
		xSimpson[(i+1):(i+100)]<-rep(simpsonDiv[j], 100)#
		j<-j+1#
	}#
#
	# Simpson Diversity Plot#
	#plot(x= xSimpson, y= y, xlim=c(min(simpsonDiv),max(simpsonDiv)), ylim=c(0,1), xlab="Host Tree Simpson Diversity Index", ylab="Frequency of Infected Host Species")#
#
	lmSimp<-lm(y~xSimpson)#
	Exp5ACorrelations[[cond]]<-list(conditions[cond],(lmSimp))#
	cond<-cond+1#
	lmSimpNoZero<-lm(y[-del]~ xSimpson[-del]) # Correlation when only considering trees with parasites#
	Exp5ACorrelations[[cond]]<-list(conditions[cond],(lmSimpNoZero))#
	cond<-cond+1#
}
load("/Volumes/NICOLEWORK/ExplorationG/ExplorationG2/ExpG2_epsilon-0.01, startTrait-0.RData")#
#
library(cophy)#
#
cophy<-list(output$Htrees[[1]], output$Ptrees[[2]])#
cophy<-convert_HPCophyloToBranches(cophy)#
#
Hdist<-get_GDist(cophy[[1]]) # collect the Gdist matrix for the hosts#
Pdist<-get_GDist(cophy[[2]]) # collect the Gdist matrix for the parasites#
Halive<-which(cophy[[1]]$tDeath==max(cophy[[1]]$tDeath)) # which hosts are alive?#
Palive<-which(cophy[[2]]$tDeath==max(cophy[[2]]$tDeath)) # which parasites are alive?#
Pcarrier<-cophy[[2]]$Hassoc[Palive] # Host branch carrying an extant parasite#
Hdist<-Hdist[Halive %in% Pcarrier,Halive %in% Pcarrier] # reducing the host Gdist matrix to extant host species#
Porder<-match(Pcarrier,Halive[Halive %in% Pcarrier])		# Order on which Hassoc branches appear in the parasite #
Hdist<-Hdist[Porder, Porder]#
Hdist[which(upper.tri(Hdist)==FALSE)]<-NA#
Pdist[which(upper.tri(Pdist)==TRUE)]<-NA#
#
colsH<-as.vector(1-Hdist*0.01)#
colsH<-colsH[!is.na(colsH)]#
colsP<-as.vector(1-Pdist*0.02)#
colsP<-colsP[!is.na(colsP)]#
#
x<-vector(length=(36*36)/2)#
j<-1#
count<-0#
for (i in rev(1:36)) {#
	x[(count+1):(count+i)]<-rep(j,i)#
	count<-count+i#
	j<-j+1#
}#
#
y<-vector(length=(36*36)/2)#
j<-0#
for (i in 1:36) {#
	y[(j+1):(j+(36-(i-1)))]<-i:36#
	j<-j+(36-(i-1))#
}#
#
par(mfrow=c(2,1))#
plot(NA, xlim=c(0,nrow(Hdist)), ylim=c(0,nrow(Hdist)),)#
points(x=x, y=y, col=rgb(red=colsH,green=colsH,blue=1,alpha=1),pch=15, cex=2)#
points(x=y, y=x, col=rgb(red=1,green=colsP,blue=colsP,alpha=1),pch=15, cex=2)#
#
x2<-rep(1:36,36)#
#
y2<-vector(length=36*36)#
j<-0#
for (i in 1:36) {#
	y2[(j+1):(j+36)]<-rep(i,36)#
	j<-j+36#
}#
#
plot(NA, xlim=c(0,nrow(Hdist)), ylim=c(0,nrow(Hdist)),)#
points(x=x2, y=y2, col=rgb(red=colsH,green=colsH,blue=1,alpha=1),pch=15, cex=2)
#######
#################### LOOKING FOR DIVERSITY INDEX OF PARASITES FREQUENCY OF INFECTION PER EXPLORATION###################
#################################################################################################################
library(vegan)#
############################## INV SIMPSON DIVERSITY ###############################
#
## VARIATION IN DIVERSITY INDEX WHEN EPSILON = 0 ###
quartz("FigureS3",6.2,4.7)#
par(mfrow=c(1,1),mar=c(3.2,3,1.5,1)+0.1,mgp=c(1.8,0.6,0))#
#
for (l in c(25)) {#
	shannonDiv<-matrix(NA, ncol=10000,nrow=4) # Object to hold diversity index of parasites for each host tree#
	row<-1#
	for (k in c(4,5,2,3)) {#
		load(paste("/Volumes/NICOLEWORK/ExplorationG/ExplorationG",k,"/Subtree stats/Subtree FreqInfected ExplorationG",k," h= ",l," ExpG",k,"_epsilon-0, startTrait-0.RData", sep=''))#
		index<-1#
		for (i in 1:100) {#
			for (j in 1:50) {#
				shannonDiv[row,index]<-diversity(subtreeFreqInfected[[i]][j,4:ncol(subtreeFreqInfected[[i]])], index="invsimpson")#
				index<-index+1#
			}	#
		}#
		load(paste("/Volumes/NICOLEWORK/ExplorationG/ExplorationG",k,"/Subtree stats/Subtree FreqInfected ExplorationG",k," h= ",l," ExpG",k,"_epsilon-0, startTrait-1.RData", sep=''))#
		index<-5001#
		for (i in 1:100) {#
			for (j in 1:50) {#
				shannonDiv[row,index]<-diversity(subtreeFreqInfected[[i]][j,4:ncol(subtreeFreqInfected[[i]])], index="invsimpson")#
				index<-index+1#
			}	#
		}#
	row<-row+1#
	}#
#
		boxplot(shannonDiv[1,!is.na(shannonDiv[1,])][which(shannonDiv[1,!is.na(shannonDiv[1,])]!=0)], shannonDiv[2,!is.na(shannonDiv[2,])][which(shannonDiv[2,!is.na(shannonDiv[2,])]!=0)], shannonDiv[3,!is.na(shannonDiv[3,])][which(shannonDiv[3,!is.na(shannonDiv[3,])]!=0)], shannonDiv[4,!is.na(shannonDiv[4,])][which(shannonDiv[4,!is.na(shannonDiv[4,])]!=0)], names=c("Null", "PDE", "CE", "PDE & CE"), outpch=NA, ylab="Inverse Simpson Diversity Index of Parasites")#
		xy<-data.frame(x=rep(NA,length(c(shannonDiv[1,!is.na(shannonDiv[1,])], shannonDiv[2,!is.na(shannonDiv[2,])], shannonDiv[3,!is.na(shannonDiv[3,])], shannonDiv[4,!is.na(shannonDiv[4,])]))), y=NA)#
		xy[,2]<-c(shannonDiv[1,!is.na(shannonDiv[1,])], shannonDiv[2,!is.na(shannonDiv[2,])], shannonDiv[3,!is.na(shannonDiv[3,])], shannonDiv[4,!is.na(shannonDiv[4,])])#
		xy[,1]<-c(rep(1,length(shannonDiv[1,!is.na(shannonDiv[1,])])),rep(2,length(shannonDiv[2,!is.na(shannonDiv[2,])])), rep(3,length(shannonDiv[3,!is.na(shannonDiv[3,])])), rep(4,length(shannonDiv[4,!is.na(shannonDiv[4,])])))#
		xy<-xy[which(xy$y!=0),]#
		stripchart(y ~ x, data=xy, vertical=TRUE, method="jitter", pch=16, col=rgb(0.5,0,1,0.1), cex=0.25, add=TRUE)#
}
## VARIATION IN DIVERSITY INDEX WHEN EPSILON = 0 CORRECTED FOR HOST SUBCLADES###
quartz("FigureS3",6.2,4.7)#
par(mfrow=c(1,1),mar=c(3.2,3,1.5,1)+0.1,mgp=c(1.8,0.6,0))#
#
for (l in c(25)) {#
	shannonDiv<-matrix(NA, ncol=10000,nrow=4) # Object to hold diversity index of parasites for each host tree#
	row<-1#
	for (k in c(4,5,2,3)) {#
		load(paste("/Volumes/NICOLEWORK/ExplorationG/ExplorationG",k,"/Subtree stats/Subtree FreqInfected ExplorationG",k," h= ",l," ExpG",k,"_epsilon-0, startTrait-0.RData", sep=''))#
		index<-1#
		for (i in 1:100) {#
			for (j in 1:50) {#
				shannonDiv[row,index]<-diversity(subtreeFreqInfected[[i]][j,4:ncol(subtreeFreqInfected[[i]])], index="invsimpson")/length(4:ncol(subtreeFreqInfected[[i]]))#
				index<-index+1#
			}	#
		}#
		load(paste("/Volumes/NICOLEWORK/ExplorationG/ExplorationG",k,"/Subtree stats/Subtree FreqInfected ExplorationG",k," h= ",l," ExpG",k,"_epsilon-0, startTrait-1.RData", sep=''))#
		index<-5001#
		for (i in 1:100) {#
			for (j in 1:50) {#
				shannonDiv[row,index]<-diversity(subtreeFreqInfected[[i]][j,4:ncol(subtreeFreqInfected[[i]])], index="invsimpson")/length(4:ncol(subtreeFreqInfected[[i]]))#
				index<-index+1#
			}	#
		}#
	row<-row+1#
	}#
#
		boxplot(shannonDiv[1,!is.na(shannonDiv[1,])][which(shannonDiv[1,!is.na(shannonDiv[1,])]!=0)], shannonDiv[2,!is.na(shannonDiv[2,])][which(shannonDiv[2,!is.na(shannonDiv[2,])]!=0)], shannonDiv[3,!is.na(shannonDiv[3,])][which(shannonDiv[3,!is.na(shannonDiv[3,])]!=0)], shannonDiv[4,!is.na(shannonDiv[4,])][which(shannonDiv[4,!is.na(shannonDiv[4,])]!=0)], names=c("Null", "PDE", "CE", "PDE & CE"), outpch=NA, ylab="Effective no. of parasite clusters per host subclade")#
		xy<-data.frame(x=rep(NA,length(c(shannonDiv[1,!is.na(shannonDiv[1,])], shannonDiv[2,!is.na(shannonDiv[2,])], shannonDiv[3,!is.na(shannonDiv[3,])], shannonDiv[4,!is.na(shannonDiv[4,])]))), y=NA)#
		xy[,2]<-c(shannonDiv[1,!is.na(shannonDiv[1,])], shannonDiv[2,!is.na(shannonDiv[2,])], shannonDiv[3,!is.na(shannonDiv[3,])], shannonDiv[4,!is.na(shannonDiv[4,])])#
		xy[,1]<-c(rep(1,length(shannonDiv[1,!is.na(shannonDiv[1,])])),rep(2,length(shannonDiv[2,!is.na(shannonDiv[2,])])), rep(3,length(shannonDiv[3,!is.na(shannonDiv[3,])])), rep(4,length(shannonDiv[4,!is.na(shannonDiv[4,])])))#
		xy<-xy[which(xy$y!=0),]#
		stripchart(y ~ x, data=xy, vertical=TRUE, method="jitter", pch=16, col=rgb(0.5,0,1,0.1), cex=0.25, add=TRUE)#
}
################################################################################################################
#################################### WHEN MINIMUN OF 5 SURVIVING PARASITES #####################################
quartz("FigureS3",6.2,4.7)#
par(mfrow=c(2,2),mar=c(3.2,3,1.5,1)+0.1,mgp=c(1.8,0.6,0))#
#
for (i in c(4,5,2,3)) { #looping through explorations#
	GdistCor<-matrix(NA, ncol=10000,nrow=11) # Object to hold correlations for each epsilon#
	row<-1#
	for (j in seq(0,0.1,0.01)) { # looping through epsilon values#
		load(paste("/Users/NicoleFortuna/Desktop/Summary Stats/Exp",i,"/Summary Stats ExpG",i,"_epsilon-",j,", startTrait-0.RData" ,sep=''))#
		rDist	<-plottingStats$rDist#
		load(paste("/Users/NicoleFortuna/Desktop/Summary Stats/Exp",i,"/Summary Stats ExpG",i,"_epsilon-",j,", startTrait-1.RData" ,sep=''))#
		rDist	<-c(rDist,plottingStats$rDist)#
		GdistCor[row,]<-rDist#
		row<-row+1#
	}#
	boxplot(GdistCor[1,], GdistCor[2,], GdistCor[3,], GdistCor[4,], GdistCor[5,], GdistCor[6,], GdistCor[7,], GdistCor[8, ], GdistCor[9,], GdistCor[10,], GdistCor[11,], ylim=c(-1,1), names=c(seq(0,0.1,0.01)), ylab="Correlation btw H and P distances", outpch=NA, xlab="Host mutation rate")#
	xy<-data.frame(x=rep(NA,110000), y=NA)#
	xy[,1]<-c(rep(0,10000), rep(0.01,10000), rep(0.02,10000), rep(0.03,10000), rep(0.04,10000), rep(0.05,10000), rep(0.06,10000), rep(0.07,10000), rep(0.08,10000), rep(0.09,10000), rep(0.1,10000))#
	xy[,2]<-as.vector(t(GdistCor))#
	xy<-xy[!is.na(xy[,2]),]#
	stripchart(y ~ x, data=xy, vertical=TRUE, method="jitter", pch=16, col=rgb(0.5,0,1,0.1), cex=0.25, add=T)#
}
# Plot D: Parasite vs. host genetic distance correlations:#
pdf(file=paste(plotspath.save,"Summary stats plot ",file.simdata,".pdf",sep=""),width=3.5,height=4.8)#
par(mfrow=c(2,2),mar=c(3.2,3,0.5,1)+0.1,mgp=c(1.8,0.6,0))#
#
epsilonVals<-paste("-", c(0,0.05),",", sep='')#
#
for (i in 1:length(epsilonVals)) {#
	load(paste("/Volumes/NICOLEWORK/ExplorationG/ExplorationG2/Subtree stats/Summary stats ExpG2_epsilon", epsilonVals[i]," startTrait-0.RData" ,sep=''))#
	rDist	<-plottingStats$rDist#
	frac	<-plottingStats$fractionInfected#
	load(paste("/Volumes/NICOLEWORK/ExplorationG/ExplorationG2/Subtree stats/Summary stats ExpG2_epsilon", epsilonVals[i]," startTrait-1.RData" ,sep=''))#
	rDist	<-c(rDist,plottingStats$rDist)#
	frac		<-c(frac,plottingStats$fractionInfected)#
	survival<-length(rDist[!is.na(rDist)])/length(rDist)#
	fraction<-mean(frac[which(frac>0)])#
	rDist	<-rDist[!is.na(rDist)]#
	hist(rDist,freq=FALSE,breaks=200,xlim=c(-1,1),ylim=c(0,8),main="",xlab="Correlation between parasite and host distance", ylab="Frequency",col="gray",border="gray")#
	lines(x=rep(median(rDist,na.rm=TRUE),2),y=c(0,length(rDist)),col="Blue")#
	lines(x=rep(mean(rDist,na.rm=TRUE),2),y=c(0,length(rDist)),col="Red",lty=3)#
	#text(labels=" median",x=median(plottingStats$rDist,na.rm=TRUE),y=2750,adj=c(0,0.5),col="Red")#
	#text(labels=" mean",x=mean(plottingStats$rDist,na.rm=TRUE),y=2500,adj=c(0,0.5),col="Blue")#
	box()#
	legend('topleft', legend=c(paste("Proportion Lineage Survival:", round(survival,4),sep=" "),paste("Mean Fraction Infected:", round(fraction,4),sep=" ")),bty = "n")#
	load(paste("/Volumes/NICOLEWORK/ExplorationG/ExplorationG3/Subtree stats/Summary stats ExpG3_epsilon", epsilonVals[i]," startTrait-0.RData" ,sep=''))#
	rDist	<-plottingStats$rDist#
	frac		<-plottingStats$fractionInfected#
	load(paste("/Volumes/NICOLEWORK/ExplorationG/ExplorationG3/Subtree stats/Summary stats ExpG3_epsilon", epsilonVals[i]," startTrait-1.RData" ,sep=''))#
	rDist	<-c(rDist,plottingStats$rDist)#
	frac		<-c(frac,plottingStats$fractionInfected)#
	survival<-length(rDist[!is.na(rDist)])/length(rDist)#
	fraction<-mean(frac[which(frac>0)])#
	rDist	<-rDist[!is.na(rDist)]#
	hist(rDist,freq=FALSE,breaks=200,xlim=c(-1,1),ylim=c(0,8),main="",xlab="Correlation between parasite and host distance", ylab="Frequency",col="gray",border="gray")#
	lines(x=rep(median(rDist,na.rm=TRUE),2),y=c(0,length(rDist)),col="Blue")#
	lines(x=rep(mean(rDist,na.rm=TRUE),2),y=c(0,length(rDist)),col="Red",lty=3)#
	#text(labels=" median",x=median(plottingStats$rDist,na.rm=TRUE),y=2750,adj=c(0,0.5),col="Red")#
	#text(labels=" mean",x=mean(plottingStats$rDist,na.rm=TRUE),y=2500,adj=c(0,0.5),col="Blue")#
	box()#
	legend('topleft', legend=c(paste("Proportion Lineage Survival:", round(survival,4),sep=" "),paste("Mean Fraction Infected:", round(fraction,4),sep=" ")),bty = "n")#
}
pdf(file=paste(plotspath.save,"Summary stats plot ",file.simdata,".pdf",sep=""),width=3.5,height=4.8)#
par(mfrow=c(2,2),mar=c(3.2,3,0.5,1)+0.1,mgp=c(1.8,0.6,0))#
#
load(paste("/Volumes/NICOLEWORK/ExplorationG/ExplorationG4/Subtree stats/Summary stats ExpG4_epsilon-0, startTrait-0.RData" ,sep=''))#
	rDist	<-plottingStats$rDist#
	frac	<-plottingStats$fractionInfected#
	load(paste("/Volumes/NICOLEWORK/ExplorationG/ExplorationG4/Subtree stats/Summary stats ExpG4_epsilon-0, startTrait-1.RData" ,sep=''))#
	rDist	<-c(rDist,plottingStats$rDist)#
	frac		<-c(frac,plottingStats$fractionInfected)#
	survival<-length(rDist[!is.na(rDist)])/length(rDist)#
	fraction<-mean(frac[which(frac>0)])#
	rDist<-rDist[!is.na(rDist)]#
	hist(rDist,freq=FALSE,breaks=200,xlim=c(-1,1),ylim=c(0,8),main="",xlab="Correlation between parasite and host distance", ylab="Frequency",col="gray",border="gray")#
	lines(x=rep(median(rDist,na.rm=TRUE),2),y=c(0,length(rDist)),col="Blue")#
	lines(x=rep(mean(rDist,na.rm=TRUE),2),y=c(0,length(rDist)),col="Red",lty=3)#
	#text(labels=" median",x=median(plottingStats$rDist,na.rm=TRUE),y=2750,adj=c(0,0.5),col="Red")#
	#text(labels=" mean",x=mean(plottingStats$rDist,na.rm=TRUE),y=2500,adj=c(0,0.5),col="Blue")#
	box()#
	legend('topleft', legend=c(paste("Proportion Lineage Survival:", round(survival,4),sep=" "),paste("Mean Fraction Infected:", round(fraction,4),sep=" ")),bty = "n")#
	load(paste("/Volumes/NICOLEWORK/ExplorationG/ExplorationG5/Subtree stats/Summary stats ExpG5_epsilon-0, startTrait-0.RData" ,sep=''))#
	rDist <-plottingStats$rDist#
	frac	<-plottingStats$fractionInfected#
	load(paste("/Volumes/NICOLEWORK/ExplorationG/ExplorationG5/Subtree stats/Summary stats ExpG5_epsilon-0, startTrait-1.RData" ,sep=''))#
	rDist<-c(rDist,plottingStats$rDist)#
	frac		<-c(frac,plottingStats$fractionInfected)#
	survival<-length(rDist[!is.na(rDist)])/length(rDist)#
	fraction<-mean(frac[which(frac>0)])#
	rDist<-rDist[!is.na(rDist)]#
	hist(rDist,freq=FALSE,breaks=200,xlim=c(-1,1),ylim=c(0,8),main="",xlab="Correlation between parasite and host distance", ylab="Frequency",col="gray",border="gray")#
	lines(x=rep(median(rDist,na.rm=TRUE),2),y=c(0,length(rDist)),col="Blue")#
	lines(x=rep(mean(rDist,na.rm=TRUE),2),y=c(0,length(rDist)),col="Red",lty=3)#
	#text(labels=" median",x=median(plottingStats$rDist,na.rm=TRUE),y=2750,adj=c(0,0.5),col="Red")#
	#text(labels=" mean",x=mean(plottingStats$rDist,na.rm=TRUE),y=2500,adj=c(0,0.5),col="Blue")#
	box()#
	legend('topleft', legend=c(paste("Proportion Lineage Survival:", round(survival,4),sep=" "),paste("Mean Fraction Infected:", round(fraction,4),sep=" ")),bty = "n")#
load(paste("/Volumes/NICOLEWORK/ExplorationG/ExplorationG2/Subtree stats/Summary stats ExpG2_epsilon-0, startTrait-0.RData" ,sep=''))#
	rDist <-plottingStats$rDist#
	frac	<-plottingStats$fractionInfected#
	load(paste("/Volumes/NICOLEWORK/ExplorationG/ExplorationG2/Subtree stats/Summary stats ExpG2_epsilon-0, startTrait-1.RData" ,sep=''))#
	rDist<-c(rDist,plottingStats$rDist)#
	frac		<-c(frac,plottingStats$fractionInfected)#
	survival<-length(rDist[!is.na(rDist)])/length(rDist)#
	fraction<-mean(frac[which(frac>0)])#
	rDist<-rDist[!is.na(rDist)]#
	hist(rDist,freq=FALSE,breaks=200,xlim=c(-1,1),ylim=c(0,8),main="",xlab="Correlation between parasite and host distance", ylab="Frequency",col="gray",border="gray")#
	lines(x=rep(median(rDist,na.rm=TRUE),2),y=c(0,length(rDist)),col="Blue")#
	lines(x=rep(mean(rDist,na.rm=TRUE),2),y=c(0,length(rDist)),col="Red",lty=3)#
	#text(labels=" median",x=median(plottingStats$rDist,na.rm=TRUE),y=2750,adj=c(0,0.5),col="Red")#
	#text(labels=" mean",x=mean(plottingStats$rDist,na.rm=TRUE),y=2500,adj=c(0,0.5),col="Blue")#
	box()#
	legend('topleft', legend=c(paste("Proportion Lineage Survival:", round(survival,4),sep=" "),paste("Mean Fraction Infected:", round(fraction,4),sep=" ")),bty = "n")#
	load(paste("/Volumes/NICOLEWORK/ExplorationG/ExplorationG3/Subtree stats/Summary stats ExpG3_epsilon-0, startTrait-0.RData" ,sep=''))#
	rDist <-plottingStats$rDist#
	frac	<-plottingStats$fractionInfected#
	load(paste("/Volumes/NICOLEWORK/ExplorationG/ExplorationG3/Subtree stats/Summary stats ExpG3_epsilon-0, startTrait-1.RData" ,sep=''))#
	rDist<-c(rDist,plottingStats$rDist)#
	frac		<-c(frac,plottingStats$fractionInfected)#
	survival<-length(rDist[!is.na(rDist)])/length(rDist)#
	fraction<-mean(frac[which(frac>0)])#
	rDist<-rDist[!is.na(rDist)]#
	hist(rDist,freq=FALSE,breaks=200,xlim=c(-1,1),ylim=c(0,8),main="",xlab="Correlation between parasite and host distance", ylab="Frequency",col="gray",border="gray")#
	lines(x=rep(median(rDist,na.rm=TRUE),2),y=c(0,length(rDist)),col="Blue")#
	lines(x=rep(mean(rDist,na.rm=TRUE),2),y=c(0,length(rDist)),col="Red",lty=3)#
	#text(labels=" median",x=median(plottingStats$rDist,na.rm=TRUE),y=2750,adj=c(0,0.5),col="Red")#
	#text(labels=" mean",x=mean(plottingStats$rDist,na.rm=TRUE),y=2500,adj=c(0,0.5),col="Blue")#
	box()#
	legend('topleft', legend=c(paste("Proportion Lineage Survival:", round(survival,4),sep=" "),paste("Mean Fraction Infected:", round(fraction,4),sep=" ")),bty = "n")
# Plot D: Parasite vs. host genetic distance correlations:#
pdf(file=paste(plotspath.save,"Summary stats plot ",file.simdata,".pdf",sep=""),width=3.5,height=4.8)#
par(mfrow=c(2,2),mar=c(3.2,3,0.5,1)+0.1,mgp=c(1.8,0.6,0))#
#
epsilonVals<-paste("-", c(0,0.05),",", sep='')#
#
for (i in 1:length(epsilonVals)) {#
	load(paste("/Users/NicoleFortuna/Desktop/Summary Stats/Exp2/Summary Stats ExpG2_epsilon", epsilonVals[i]," startTrait-0.RData" ,sep=''))#
	rDist	<-plottingStats$rDist#
	frac	<-plottingStats$fractionInfected#
	load(paste("/Users/NicoleFortuna/Desktop/Summary Stats/Exp2/Summary Stats ExpG2_epsilon", epsilonVals[i]," startTrait-1.RData" ,sep=''))#
	rDist	<-c(rDist,plottingStats$rDist)#
	frac		<-c(frac,plottingStats$fractionInfected)#
	survival<-length(rDist[!is.na(rDist)])/length(rDist)#
	fraction<-mean(frac[which(frac>0)])#
	rDist	<-rDist[!is.na(rDist)]#
	hist(rDist,freq=FALSE,breaks=200,xlim=c(-1,1),ylim=c(0,8),main="",xlab="Correlation between parasite and host distance", ylab="Frequency",col="gray",border="gray")#
	lines(x=rep(median(rDist,na.rm=TRUE),2),y=c(0,length(rDist)),col="Blue")#
	lines(x=rep(mean(rDist,na.rm=TRUE),2),y=c(0,length(rDist)),col="Red",lty=3)#
	#text(labels=" median",x=median(plottingStats$rDist,na.rm=TRUE),y=2750,adj=c(0,0.5),col="Red")#
	#text(labels=" mean",x=mean(plottingStats$rDist,na.rm=TRUE),y=2500,adj=c(0,0.5),col="Blue")#
	box()#
	legend('topleft', legend=c(paste("Proportion Lineage Survival:", round(survival,4),sep=" "),paste("Mean Fraction Infected:", round(fraction,4),sep=" ")),bty = "n")#
	load(paste("/Users/NicoleFortuna/Desktop/Summary Stats/Exp3/Summary Stats ExpG3_epsilon", epsilonVals[i]," startTrait-0.RData" ,sep=''))#
	rDist	<-plottingStats$rDist#
	frac		<-plottingStats$fractionInfected#
	load(paste("/Users/NicoleFortuna/Desktop/Summary Stats/Exp3/Summary Stats ExpG3_epsilon", epsilonVals[i]," startTrait-1.RData" ,sep=''))#
	rDist	<-c(rDist,plottingStats$rDist)#
	frac		<-c(frac,plottingStats$fractionInfected)#
	survival<-length(rDist[!is.na(rDist)])/length(rDist)#
	fraction<-mean(frac[which(frac>0)])#
	rDist	<-rDist[!is.na(rDist)]#
	hist(rDist,freq=FALSE,breaks=200,xlim=c(-1,1),ylim=c(0,8),main="",xlab="Correlation between parasite and host distance", ylab="Frequency",col="gray",border="gray")#
	lines(x=rep(median(rDist,na.rm=TRUE),2),y=c(0,length(rDist)),col="Blue")#
	lines(x=rep(mean(rDist,na.rm=TRUE),2),y=c(0,length(rDist)),col="Red",lty=3)#
	#text(labels=" median",x=median(plottingStats$rDist,na.rm=TRUE),y=2750,adj=c(0,0.5),col="Red")#
	#text(labels=" mean",x=mean(plottingStats$rDist,na.rm=TRUE),y=2500,adj=c(0,0.5),col="Blue")#
	box()#
	legend('topleft', legend=c(paste("Proportion Lineage Survival:", round(survival,4),sep=" "),paste("Mean Fraction Infected:", round(fraction,4),sep=" ")),bty = "n")#
}
load("/Volumes/NICOLEWORK/ExplorationG/ExplorationG4/ExpG4_epsilon-0.01, startTrait-0.RData")#
#
Htree.Subtree<-list()#
for (i in 1:1) { #Htrees#
	Subtree<-list()#
	for (j in 1:50) { # Associated Ptrees#
		Subtree[[j]]<-get_PHDistSubtreeCorrelation(list(output$Htree[[i]], output$Ptree[[j]]), h=50)#
		print("=======")#
		print(paste("Htree: ",i,"Ptree: ",j))#
		print(Subtree[[j]])#
	}#
	Htree.Subtree[[i]]<-Subtree#
}#
#
Subtree1<-vector(length=50)#
Subtree2<-vector(length=50)#
Subtree3<-vector(length=50)#
for (i in 1:50) {#
	if (length(Subtree[[i]])==1) {#
		Subtree1[i]<-NA#
		Subtree2[i]<-NA#
		Subtree3[i]<-NA#
	} else {#
		Subtree1[i]<-Subtree[[i]][[1]]#
		Subtree2[i]<-Subtree[[i]][[2]]#
		Subtree3[i]<-Subtree[[i]][[3]]#
	}#
}#
#
SubtreeCors<-cbind(Subtree1, Subtree2, Subtree3)#
#
load("/Volumes/NICOLEWORK/ExplorationG/ExplorationG4/Subtree stats/Subtree stats ExplorationG4 h=50 ExpG4_epsilon-0.01, startTrait-0.RData")#
#
#quartz(paste(path.save,"Summary stats plot ",file.simdata,".pdf",sep=""),3.5,4.8)#
pdf(file=paste(plotspath.save,"Summary stats plot ",file.simdata,".pdf",sep=""),width=3.5,height=4.8)#
par(mfrow=c(4,1),mar=c(3.2,3,0.5,1)+0.1,mgp=c(1.8,0.6,0))#
#
# Plot D: Parasite vs. host genetic distance correlations:#
#
load(paste("/Volumes/NICOLEWORK/ExplorationG/ExplorationG4/Subtree stats/Summary stats ExpG4_epsilon-0.01, startTrait-0.RData" ,sep=''))#
	rDist <-plottingStats$rDist#
	rDist<-rDist[!is.na(rDist)]#
	hist(rDist,freq=FALSE,breaks=200,xlim=c(-1,1),main="",xlab="Correlation between parasite and host distance", ylab="Frequency",col="gray",border="gray")#
	lines(x=rep(median(rDist,na.rm=TRUE),2),y=c(0,length(rDist)),col="Blue")#
	lines(x=rep(mean(rDist,na.rm=TRUE),2),y=c(0,length(rDist)),col="Red",lty=3)#
	#text(labels=" median",x=median(plottingStats$rDist,na.rm=TRUE),y=2750,adj=c(0,0.5),col="Red")#
	#text(labels=" mean",x=mean(plottingStats$rDist,na.rm=TRUE),y=2500,adj=c(0,0.5),col="Blue")#
	box()#
#
for (i in 1:3) {#
	hist(SubtreeCors[,i],freq=FALSE,breaks=100,xlim=c(-1,1),main="",xlab="Correlation between parasite and host distance", ylab="Frequency",col="gray",border="gray")#
	lines(x=rep(median(SubtreeCors[,i],na.rm=TRUE),2),y=c(0,length(SubtreeCors[,i])),col="Blue")#
	lines(x=rep(mean(SubtreeCors[,i],na.rm=TRUE),2),y=c(0,length(SubtreeCors[,i])),col="Red",lty=3)#
	legend(legend=paste("Subclade size: ", subtreeStats[i,3],", Infection frequency: ", round(subtreeStats[i,7],3),sep=''),"topleft",col="Black",bty = "n")#
	#text(labels=" mean",x=mean(plottingStats$rDist,na.rm=TRUE),y=2500,adj=c(0,0.5),col="Blue")#
	box()#
}
quartz("FigureS3",6.2,4.7)#
par(mfrow=c(2,2),mar=c(3.2,3,1.5,1)+0.1,mgp=c(1.8,0.6,0))#
#
Htree<-2#
#
for (i in c(4,5,2,3)) {#
	load(paste('/Volumes/NICOLEWORK/ExplorationG/ExplorationG',i,'/ExpG',i,'_epsilon-0, startTrait-0.RData', sep=''))#
	load(paste('/Volumes/NICOLEWORK/ExplorationG/ExplorationG',i,'/Subtree stats/Subtree FreqInfected ExplorationG',i,' h= 25 ExpG',i,'_epsilon-0, startTrait-0.RData', sep=""))#
	subFreq<-subtreeFreqInfected[[Htree]]#
	load(paste('/Volumes/NICOLEWORK/ExplorationG/ExplorationG',i,'/Subtree stats/Subtree FreqInfected ExplorationG',i,' h= 25 ExpG',i,'_epsilon-0, startTrait-1.RData', sep=""))#
	subFreq<-rbind(subFreq, subtreeFreqInfected[[Htree]])#
#
	boxplot(output$statistics[,7][which(output$statistics[,1]==Htree & output$statistics[,7]>0)],subFreq$Subtree1, subFreq$Subtree2, subFreq$Subtree3, subFreq$Subtree4, subFreq$Subtree5)#
}
################## LOOKING FOR DIVERSITY INDEX OF PARASITES FREQUENCY OF INFECTION PER EXPLORATION###################
#################################################################################################################
library(vegan)#
############################## INV SIMPSON DIVERSITY ###############################
#
## VARIATION IN DIVERSITY INDEX WHEN EPSILON = 0 ###
quartz("FigureS3",6.2,4.7)#
par(mfrow=c(1,1),mar=c(3.2,3,1.5,1)+0.1,mgp=c(1.8,0.6,0))#
#
for (l in c(25)) {#
	shannonDiv<-matrix(NA, ncol=10000,nrow=4) # Object to hold diversity index of parasites for each host tree#
	row<-1#
	for (k in c(4,5,2,3)) {#
		load(paste("/Volumes/NICOLEWORK/ExplorationG/ExplorationG",k,"/Subtree stats/Subtree FreqInfected ExplorationG",k," h= ",l," ExpG",k,"_epsilon-0, startTrait-0.RData", sep=''))#
		index<-1#
		for (i in 1:100) {#
			for (j in 1:50) {#
				shannonDiv[row,index]<-diversity(subtreeFreqInfected[[i]][j,4:ncol(subtreeFreqInfected[[i]])], index="invsimpson")#
				index<-index+1#
			}	#
		}#
		load(paste("/Volumes/NICOLEWORK/ExplorationG/ExplorationG",k,"/Subtree stats/Subtree FreqInfected ExplorationG",k," h= ",l," ExpG",k,"_epsilon-0, startTrait-1.RData", sep=''))#
		index<-5001#
		for (i in 1:100) {#
			for (j in 1:50) {#
				shannonDiv[row,index]<-diversity(subtreeFreqInfected[[i]][j,4:ncol(subtreeFreqInfected[[i]])], index="invsimpson")#
				index<-index+1#
			}	#
		}#
	row<-row+1#
	}#
#
		boxplot(shannonDiv[1,!is.na(shannonDiv[1,])][which(shannonDiv[1,!is.na(shannonDiv[1,])]!=0)], shannonDiv[2,!is.na(shannonDiv[2,])][which(shannonDiv[2,!is.na(shannonDiv[2,])]!=0)], shannonDiv[3,!is.na(shannonDiv[3,])][which(shannonDiv[3,!is.na(shannonDiv[3,])]!=0)], shannonDiv[4,!is.na(shannonDiv[4,])][which(shannonDiv[4,!is.na(shannonDiv[4,])]!=0)], names=c("Null", "PDE", "CE", "PDE & CE"), outpch=NA, ylab="Inverse Simpson Diversity Index of Parasites")#
		xy<-data.frame(x=rep(NA,length(c(shannonDiv[1,!is.na(shannonDiv[1,])], shannonDiv[2,!is.na(shannonDiv[2,])], shannonDiv[3,!is.na(shannonDiv[3,])], shannonDiv[4,!is.na(shannonDiv[4,])]))), y=NA)#
		xy[,2]<-c(shannonDiv[1,!is.na(shannonDiv[1,])], shannonDiv[2,!is.na(shannonDiv[2,])], shannonDiv[3,!is.na(shannonDiv[3,])], shannonDiv[4,!is.na(shannonDiv[4,])])#
		xy[,1]<-c(rep(1,length(shannonDiv[1,!is.na(shannonDiv[1,])])),rep(2,length(shannonDiv[2,!is.na(shannonDiv[2,])])), rep(3,length(shannonDiv[3,!is.na(shannonDiv[3,])])), rep(4,length(shannonDiv[4,!is.na(shannonDiv[4,])])))#
		xy<-xy[which(xy$y!=0),]#
		stripchart(y ~ x, data=xy, vertical=TRUE, method="jitter", pch=16, col=rgb(0.5,0,1,0.1), cex=0.25, add=TRUE)#
}
## VARIATION IN DIVERSITY INDEX WHEN EPSILON = 0 CORRECTED FOR HOST SUBCLADES###
quartz("FigureS3",6.2,4.7)#
par(mfrow=c(1,1),mar=c(3.2,3,1.5,1)+0.1,mgp=c(1.8,0.6,0))#
#
for (l in c(25)) {#
	shannonDiv<-matrix(NA, ncol=10000,nrow=4) # Object to hold diversity index of parasites for each host tree#
	row<-1#
	for (k in c(4,5,2,3)) {#
		load(paste("/Volumes/NICOLEWORK/ExplorationG/ExplorationG",k,"/Subtree stats/Subtree FreqInfected ExplorationG",k," h= ",l," ExpG",k,"_epsilon-0, startTrait-0.RData", sep=''))#
		index<-1#
		for (i in 1:100) {#
			for (j in 1:50) {#
				shannonDiv[row,index]<-diversity(subtreeFreqInfected[[i]][j,4:ncol(subtreeFreqInfected[[i]])], index="invsimpson")/length(4:ncol(subtreeFreqInfected[[i]]))#
				index<-index+1#
			}	#
		}#
		load(paste("/Volumes/NICOLEWORK/ExplorationG/ExplorationG",k,"/Subtree stats/Subtree FreqInfected ExplorationG",k," h= ",l," ExpG",k,"_epsilon-0, startTrait-1.RData", sep=''))#
		index<-5001#
		for (i in 1:100) {#
			for (j in 1:50) {#
				shannonDiv[row,index]<-diversity(subtreeFreqInfected[[i]][j,4:ncol(subtreeFreqInfected[[i]])], index="invsimpson")/length(4:ncol(subtreeFreqInfected[[i]]))#
				index<-index+1#
			}	#
		}#
	row<-row+1#
	}#
#
		boxplot(shannonDiv[1,!is.na(shannonDiv[1,])][which(shannonDiv[1,!is.na(shannonDiv[1,])]!=0)], shannonDiv[2,!is.na(shannonDiv[2,])][which(shannonDiv[2,!is.na(shannonDiv[2,])]!=0)], shannonDiv[3,!is.na(shannonDiv[3,])][which(shannonDiv[3,!is.na(shannonDiv[3,])]!=0)], shannonDiv[4,!is.na(shannonDiv[4,])][which(shannonDiv[4,!is.na(shannonDiv[4,])]!=0)], names=c("Null", "PDE", "CE", "PDE & CE"), outpch=NA, ylab="Effective no. of parasite clusters per host subclade")#
		xy<-data.frame(x=rep(NA,length(c(shannonDiv[1,!is.na(shannonDiv[1,])], shannonDiv[2,!is.na(shannonDiv[2,])], shannonDiv[3,!is.na(shannonDiv[3,])], shannonDiv[4,!is.na(shannonDiv[4,])]))), y=NA)#
		xy[,2]<-c(shannonDiv[1,!is.na(shannonDiv[1,])], shannonDiv[2,!is.na(shannonDiv[2,])], shannonDiv[3,!is.na(shannonDiv[3,])], shannonDiv[4,!is.na(shannonDiv[4,])])#
		xy[,1]<-c(rep(1,length(shannonDiv[1,!is.na(shannonDiv[1,])])),rep(2,length(shannonDiv[2,!is.na(shannonDiv[2,])])), rep(3,length(shannonDiv[3,!is.na(shannonDiv[3,])])), rep(4,length(shannonDiv[4,!is.na(shannonDiv[4,])])))#
		xy<-xy[which(xy$y!=0),]#
		stripchart(y ~ x, data=xy, vertical=TRUE, method="jitter", pch=16, col=rgb(0.5,0,1,0.1), cex=0.25, add=TRUE)#
}
for (i in c(4,5,2,3)) { #Exploration#
	Freqs<-matrix(nrow=11, ncol=10000)#
	row<-1#
	for (j in seq(0,0.1,0.01)) { #Epsilon#
		load(paste("/Volumes/NICOLEWORK/ExplorationG/ExplorationG",i,"/ExpG",i,"_epsilon-",j,", startTrait-0.RData", sep=''))#
		freq<-output$statistics[,7]#
		load(paste("/Volumes/NICOLEWORK/ExplorationG/ExplorationG",i,"/ExpG",i,"_epsilon-",j,", startTrait-1.RData", sep=''))#
		freq<-c(freq, output$statistics[,7])#
		Freqs[row,]<-freq#
		row<-row+1#
	}#
	save(Freqs, file=paste("/Volumes/NICOLEWORK/ExplorationG/ExpG",i,"frequencyData.RData", sep=''))#
}#
#
quartz("FigureS3",6.2,4.7)#
par(mfrow=c(2,2),mar=c(3.2,3,1.5,1)+0.1,mgp=c(1.8,0.6,0))#
#
for (i in c(4,5,2,3)) { #Exploration#
	load(paste("/Volumes/NICOLEWORK/ExplorationG/ExpG",i,"frequencyData.RData", sep=''))#
	boxplot(Freqs[1,which(Freqs[1,]>0)], Freqs[2,which(Freqs[2,]>0)], Freqs[3,which(Freqs[3,]>0)], Freqs[4,which(Freqs[4,]>0)], Freqs[5,which(Freqs[5,]>0)], Freqs[6,which(Freqs[6,]>0)], Freqs[7,which(Freqs[7,]>0)], Freqs[8,which(Freqs[8,]>0)], Freqs[9,which(Freqs[9,]>0)], Freqs[10,which(Freqs[10,]>0)], Freqs[11,which(Freqs[11,]>0)], ylim=c(0,1), names=c(seq(0,0.1,0.01)), ylab="Frequency of infected hosts", outpch=NA, xlab="Host mutation rate")#
	xy<-data.frame(x=rep(NA,110000), y=NA)#
	xy[,1]<-c(rep(0,10000), rep(0.01,10000), rep(0.02,10000), rep(0.03,10000), rep(0.04,10000), rep(0.05,10000), rep(0.06,10000), rep(0.07,10000), rep(0.08,10000), rep(0.09,10000), rep(0.1,10000))#
	xy[,2]<-as.vector(t(Freqs))#
	xy<-xy[which(xy[,2]>0),]#
	stripchart(y ~ x, data=xy, vertical=TRUE, method="jitter", pch=16, col=rgb(0.5,0,1,0.1), cex=0.25, add=T)#
}
load('/Volumes/NICOLEWORK/ExplorationG/ExplorationG4/Exp4_epsilon-0.02, startTrait-0.RData')#
#
exp4alpha<-rep(NA, 5000)#
#
	j<-0#
	for (i in 1:100) { #Htrees#
		exp2fit[[i]]<-list()#
		for(count in 1:50) {#
			j<-j+1#
			if (output$Ptrees[[j]]$nAlive>10) {#
				phy<-output$Htrees[[i]]#
				taxa<-paste("t",1:output$Htrees[[i]]$nAlive, sep='')#
				TT<-output$HResistanceTraits[[j]]#
				ResistanceData<-rep(NA,length(taxa))#
				k<-1#
				for (l in 1:length(TT)) {#
					if(TT[[l]][nrow(TT[[l]]),1]>=50) {#
						ResistanceData[k]<-TT[[l]][nrow(TT[[l]]),2]#
						k<-k+1#
					}#
				}#
				Ptips<-which(output$Ptrees[[j]]$edge[,2] %in% 1:output$Ptrees[[j]]$nAlive)#
				Hbranch<-output$Ptrees[[j]]$Hassoc[Ptips]#
				Htip_P<-output$Htrees[[i]]$edge[Hbranch,2]#
				InfectionData<-rep(0,length(taxa))#
				InfectionData[Htip_P]<-1#
				dat<-data.frame(resistance.trait= ResistanceData, infection.status= InfectionData)#
				rownames(dat)<-taxa#
#
				phy.pruned<-drop.tip(phy, output$Htrees[[i]]$tip.label[(output$Htrees[[i]]$nAlive+1):length(output$Htrees[[i]]$tip.label)])#
				if (length(unique(ResistanceData))>1) {#
					fit<-phylolm(infection.status ~ resistance.trait,phy= phy.pruned, data=dat, boot=100, model="OUrandomRoot")#
					exp4alpha[j]<-fit$bootmean[4]#
				}#
			}#
		}#
	}#
load('/Volumes/NICOLEWORK/ExplorationG/ExplorationG5/ExpG5_epsilon-0.02, startTrait-0.RData')#
exp5alpha<-rep(NA, 5000)#
#
	j<-0#
	for (i in 1:100) { #Htrees#
		exp2fit[[i]]<-list()#
		for(count in 1:50) {#
			j<-j+1#
			if (output$Ptrees[[j]]$nAlive>10) {#
				phy<-output$Htrees[[i]]#
				taxa<-paste("t",1:output$Htrees[[i]]$nAlive, sep='')#
				TT<-output$HResistanceTraits[[j]]#
				ResistanceData<-rep(NA,length(taxa))#
				k<-1#
				for (l in 1:length(TT)) {#
					if(TT[[l]][nrow(TT[[l]]),1]>=50) {#
						ResistanceData[k]<-TT[[l]][nrow(TT[[l]]),2]#
						k<-k+1#
					}#
				}#
				Ptips<-which(output$Ptrees[[j]]$edge[,2] %in% 1:output$Ptrees[[j]]$nAlive)#
				Hbranch<-output$Ptrees[[j]]$Hassoc[Ptips]#
				Htip_P<-output$Htrees[[i]]$edge[Hbranch,2]#
				InfectionData<-rep(0,length(taxa))#
				InfectionData[Htip_P]<-1#
				dat<-data.frame(resistance.trait= ResistanceData, infection.status= InfectionData)#
				rownames(dat)<-taxa#
#
				phy.pruned<-drop.tip(phy, output$Htrees[[i]]$tip.label[(output$Htrees[[i]]$nAlive+1):length(output$Htrees[[i]]$tip.label)])#
				if (length(unique(ResistanceData))>1) {#
					fit<-phylolm(infection.status ~ resistance.trait,phy= phy.pruned, data=dat, boot=100, model="OUrandomRoot")#
					exp5alpha[j]<-fit$bootmean[4]#
				}#
			}#
		}#
	}#
#
load('/Volumes/NICOLEWORK/ExplorationG/ExplorationG2/ExpG2_epsilon-0.02, startTrait-0.RData')#
#
exp2fit<-list()#
exp2alpha<-rep(NA, 5000)#
#
	j<-0#
	for (i in 1:100) { #Htrees#
		exp2fit[[i]]<-list()#
		for(count in 1:50) {#
			j<-j+1#
			if (output$Ptrees[[j]]$nAlive>10) {#
				phy<-output$Htrees[[i]]#
				taxa<-paste("t",1:output$Htrees[[i]]$nAlive, sep='')#
				TT<-output$HResistanceTraits[[j]]#
				ResistanceData<-rep(NA,length(taxa))#
				k<-1#
				for (l in 1:length(TT)) {#
					if(TT[[l]][nrow(TT[[l]]),1]>=50) {#
						ResistanceData[k]<-TT[[l]][nrow(TT[[l]]),2]#
						k<-k+1#
					}#
				}#
				Ptips<-which(output$Ptrees[[j]]$edge[,2] %in% 1:output$Ptrees[[j]]$nAlive)#
				Hbranch<-output$Ptrees[[j]]$Hassoc[Ptips]#
				Htip_P<-output$Htrees[[i]]$edge[Hbranch,2]#
				InfectionData<-rep(0,length(taxa))#
				InfectionData[Htip_P]<-1#
				dat<-data.frame(resistance.trait= ResistanceData, infection.status= InfectionData)#
				rownames(dat)<-taxa#
#
				phy.pruned<-drop.tip(phy, output$Htrees[[i]]$tip.label[(output$Htrees[[i]]$nAlive+1):length(output$Htrees[[i]]$tip.label)])#
				if (length(unique(ResistanceData))>1) {#
					fit<-phylolm(infection.status ~ resistance.trait,phy= phy.pruned, data=dat, boot=100, model="OUrandomRoot")#
					exp2alpha[j]<-fit$bootmean[4]#
				}#
				#exp2fit[[i]][[j]]<-fit#
			}#
		}#
	}#
load('/Volumes/NICOLEWORK/ExplorationG/ExplorationG3/ExpG3_epsilon-0.02, startTrait-0.RData')#
exp3alpha<-rep(NA, 5000)#
#
	j<-0#
	for (i in 1:100) { #Htrees#
		exp2fit[[i]]<-list()#
		for(count in 1:50) {#
			j<-j+1#
			if (output$Ptrees[[j]]$nAlive>10) {#
				phy<-output$Htrees[[i]]#
				taxa<-paste("t",1:output$Htrees[[i]]$nAlive, sep='')#
				TT<-output$HResistanceTraits[[j]]#
				ResistanceData<-rep(NA,length(taxa))#
				k<-1#
				for (l in 1:length(TT)) {#
					if(TT[[l]][nrow(TT[[l]]),1]>=50) {#
						ResistanceData[k]<-TT[[l]][nrow(TT[[l]]),2]#
						k<-k+1#
					}#
				}#
				Ptips<-which(output$Ptrees[[j]]$edge[,2] %in% 1:output$Ptrees[[j]]$nAlive)#
				Hbranch<-output$Ptrees[[j]]$Hassoc[Ptips]#
				Htip_P<-output$Htrees[[i]]$edge[Hbranch,2]#
				InfectionData<-rep(0,length(taxa))#
				InfectionData[Htip_P]<-1#
				dat<-data.frame(resistance.trait= ResistanceData, infection.status= InfectionData)#
				rownames(dat)<-taxa#
#
				phy.pruned<-drop.tip(phy, output$Htrees[[i]]$tip.label[(output$Htrees[[i]]$nAlive+1):length(output$Htrees[[i]]$tip.label)])#
				if (length(unique(ResistanceData))>1) {#
					fit<-phylolm(infection.status ~ resistance.trait,phy= phy.pruned, data=dat, boot=100, model="OUrandomRoot")#
					exp3alpha[j]<-fit$bootmean[4]#
				}#
				#exp2fit[[i]][[j]]<-fit#
			}#
		}#
	}#
load('/Volumes/NICOLEWORK/ExplorationG/ExplorationG2/ExpG2_epsilon-0.02, startTrait-0.RData')	#
PtreeNo<-4#
output$Ptrees[[PtreeNo]]$nAlive#
#
phy<-output$Htrees[[1]]#
#
taxa<-paste("t",1:output$Htrees[[1]]$nAlive, sep='')#
#
TT<-output$HResistanceTraits[[PtreeNo]]#
#
ResistanceData<-rep(NA,length(taxa))#
#
k<-1#
for (l in 1:length(TT)) {#
	if(TT[[l]][nrow(TT[[l]]),1]>=50) {#
		ResistanceData[k]<-TT[[l]][nrow(TT[[l]]),2]#
		k<-k+1#
	}#
}#
###################################################
#
Exp2Pvals1<-matrix(ncol=5000, nrow=11)#
#
epsilonVals<-seq(0,0.1,0.01)#
#
for (n in 1:11) {#
	load(paste("/Volumes/NICOLEWORK/ExplorationG/ExplorationG2/ExpG2_epsilon-", epsilonVals[n],", startTrait-1.RData", sep=''))	#
	j<-0#
	for (i in 1:100) { #Htrees#
		for(count in 1:50) {#
			j<-j+1#
			if (output$Ptrees[[j]]$nAlive>10) {#
				phy<-output$Htrees[[i]]#
				taxa<-paste("t",1:output$Htrees[[i]]$nAlive, sep='')#
				Ptips<-which(output$Ptrees[[j]]$edge[,2] %in% 1:output$Ptrees[[j]]$nAlive)#
				Hbranch<-output$Ptrees[[j]]$Hassoc[Ptips]#
				Htip_P<-output$Htrees[[i]]$edge[Hbranch,2]#
				InfectionData<-rep(0,length(taxa))#
				InfectionData[Htip_P]<-1#
#
				phy.pruned<-drop.tip(phy, output$Htrees[[i]]$tip.label[(output$Htrees[[i]]$nAlive+1):length(output$Htrees[[i]]$tip.label)])#
				if (length(unique(InfectionData))>1) {#
					Exp2Pvals1[n,j]<-phylo.signal.disc(InfectionData, phy.pruned, rep=10000)$.Randomization.Results[6]#
				}#
			}#
		}#
		print(paste("Htree: ", i, " finished", sep=''))#
	}#
	print(paste("Epsilon: ", epsilonVals[n], " finished", sep='' ))#
}#
#
save(Exp2Pvals1, file="~/Desktop/Summary Stats/Plots/Exp2Pvals.sT1.Rdata")#
#
Exp3Pvals<-matrix(ncol=5000, nrow=11)#
#
for (n in 1:11) {#
	load(paste("/Volumes/NICOLEWORK/ExplorationG/ExplorationG3/ExpG3_epsilon-", epsilonVals[n],", startTrait-0.RData", sep=''))	#
	j<-0#
	for (i in 1:100) { #Htrees#
		for(count in 1:50) {#
			j<-j+1#
			if (output$Ptrees[[j]]$nAlive>10) {#
				phy<-output$Htrees[[i]]#
				taxa<-paste("t",1:output$Htrees[[i]]$nAlive, sep='')#
				Ptips<-which(output$Ptrees[[j]]$edge[,2] %in% 1:output$Ptrees[[j]]$nAlive)#
				Hbranch<-output$Ptrees[[j]]$Hassoc[Ptips]#
				Htip_P<-output$Htrees[[i]]$edge[Hbranch,2]#
				InfectionData<-rep(0,length(taxa))#
				InfectionData[Htip_P]<-1#
#
				phy.pruned<-drop.tip(phy, output$Htrees[[i]]$tip.label[(output$Htrees[[i]]$nAlive+1):length(output$Htrees[[i]]$tip.label)])#
				if (length(unique(InfectionData))>1) {#
					Exp3Pvals[n,j]<-phylo.signal.disc(InfectionData, phy.pruned, rep=1000)$.Randomization.Results[6]#
				}#
			}#
		}#
		print(paste("Htree: ", i, " finished", sep=''))#
	}#
	print(paste("Epsilon: ", epsilonVals[n], " finished", sep='' ))#
}#
phy<-output$Htrees[[i]]#
taxa<-paste("t",1:output$Htrees[[i]]$nAlive, sep='')#
#
PtreeNo<-2#
#
Ptips<-which(output$Ptrees[[PtreeNo]]$edge[,2] %in% 1:output$Ptrees[[PtreeNo]]$nAlive)#
#
Hbranch<-output$Ptrees[[PtreeNo]]$Hassoc[Ptips]#
#
Htip_P<-output$Htrees[[1]]$edge[Hbranch,2]#
#
InfectionData<-rep(0,length(taxa))#
#
InfectionData[Htip_P]<-1#
#
dat<-data.frame(infection.status= InfectionData)#
rownames(dat)<-taxa#
#
phy.pruned<-drop.tip(phy, output$Htrees[[1]]$tip.label[47:length(output$Htrees[[1]]$tip.label)])#
#
fit<-phylolm(infection.status ~ 1,phy= phy.pruned, data=dat, boot=100, model="OUrandomRoot")#
summary(fit)#
#
par(mfrow=c(2,2))#
load('/Volumes/NICOLEWORK/Summary Stats/Plots/Exp2Pvals.Rdata')#
boxplot(Exp2Pvals[1,], Exp2Pvals[2,], Exp2Pvals[3,], Exp2Pvals[4,], Exp2Pvals[5,], Exp2Pvals[6,], Exp2Pvals[7,], Exp2Pvals[8,], Exp2Pvals[9,], Exp2Pvals[10,], Exp2Pvals[11,])#
#
load('/Volumes/NICOLEWORK/Summary Stats/Plots/Exp3Pvals.Rdata')#
boxplot(Exp3Pvals[1,], Exp3Pvals[2,], Exp3Pvals[3,], Exp3Pvals[4,], Exp3Pvals[5,], Exp3Pvals[6,], Exp3Pvals[7,], Exp3Pvals[8,], Exp3Pvals[9,], Exp3Pvals[10,], Exp3Pvals[11,])#
#
phy<-output$Htrees[[i]]#
phy.pruned<-drop.tip(phy, output$Htrees[[i]]$tip.label[(output$Htrees[[i]]$nAlive+1):length(output$Htrees[[i]]$tip.label)])#
library(ape)#
quartz("FigureS3",6.2,4.7)#
par(mfrow=c(1,2),mar=c(1,1,1,1)+0.1,mgp=c(1.8,0.6,0))#
plot.cophylo(list(phy, output$Ptrees[[1]], output$HResistanceTraits[[1]]), plotHResistance = F, plotPEvolution = c(F, F))#
plot(phy.pruned, show.tip.label=F)
?rpois
?rgamma
rgamma(1)
rgamma(1, shape=1)
rgamma(10, shape=1)
rgamma(10, shape=1, scale=10)
rgamma(100, shape=1)
a<-rgamma(100, shape=1)
?hist
hist(a)
a<-rgamma(1000, shape=1)
hist(a)
a<-rgamma(1000, shape=2)
hist(a)
a<-rgamma(1000, shape=3)
hist(a)
a<-rgamma(1000, shape=4)
hist(a)
a<-rgamma(10000, shape=4)
hist(a)
a<-rgamma(10000, shape=1)
hist(a)
a<-rgamma(10000, shape=2)
hist(a)
a<-rgamma(10000, shape=2, scale=10)
hist(a)
a<-rgamma(10000, shape=2, scale=1)
hist(a)
a<-rgamma(10000, shape=2, scale=1, rate=1)
a<-rgamma(10000, shape=2, scale=0.5)
hist(a)
a<-rgamma(10000, shape=3, scale=0.5)
hist(a)
a<-rgamma(10000, shape=4, scale=0.5)
hist(a)
a<-rgamma(10000, shape=4, scale=1)
hist(a)
a<-matrix(ncol=3,nrow=3)
a
a<-matrix(ncol=3,nrow=3, 1:9)
a
a[c(2,3,1), c(1,3,2)]
mut<-matrix(ncol=2, c(1,2,1,1,1,0), byrow=T)
mut
a[mut[,1], mut[,2]]
library(cophy)
Htree<-rphylo_H(tmax=5, export.format="Raw")#
 HPQtree<-rcophylo_PQonH(H.tree=Htree, tmax=5)#
 convert_HPQCophyloToBranches(cophy=HPQtree)
# converting host tree:#
  HBranches<-data.frame(alive=rep(NA,nrow(cophy[[1]]$edge)),nodeBirth=cophy[[1]]$edge[,1],tBirth=NA,nodeDeath=cophy[[1]]$edge[,2],tDeath=NA,branchNo=2:(nrow(cophy[[1]]$edge)+1))#
  ancBranches<-match(HBranches$nodeBirth,HBranches$nodeDeath)#
#
  HBranches$tBirth<-sapply(1:length(HBranches$nodeBirth),get_tBirth,phy=cophy[[1]],ancBranches=ancBranches)#
  HBranches$tDeath<-HBranches$tBirth+cophy[[1]]$edge.length#
  rootNode<-cophy[[1]]$edge[match(NA,ancBranches),1]#
  HBranches<-rbind(data.frame(alive=NA,nodeBirth=0,tBirth=0,nodeDeath=rootNode,tDeath=cophy[[1]]$root.edge,branchNo=1),HBranches) # adding the root#
#
  if (!is.null(cophy[[1]]$nAlive)) { # if the phylo object contains information about how many species are alive#
    HBranches$alive<-FALSE#
    if (cophy[[1]]$nAlive>0) {#
      HBranches$alive[HBranches$tDeath==max(HBranches$tDeath)]<-TRUE#
    }#
  }#
#
  # converting parasite trees:#
  P.PBranches<-data.frame(alive=rep(NA,nrow(cophy[[2]]$edge)),nodeBirth=cophy[[2]]$edge[,1],tBirth=NA,nodeDeath=cophy[[2]]$edge[,2],tDeath=NA,Hassoc=NA,branchNo=2:(nrow(cophy[[2]]$edge)+1))#
#
  P.ancBranches<-match(P.PBranches$nodeBirth,P.PBranches$nodeDeath)#
#
  P.PBranches$tBirth<-sapply(1:length(P.PBranches$nodeBirth),get_tBirth,phy=cophy[[2]],ancBranches=P.ancBranches) + cophy[[2]]$root.time#
  P.PBranches$tDeath<-P.PBranches$tBirth+cophy[[2]]$edge.length#
  P.PBranches$Hassoc<-cophy[[2]]$Hassoc+1#
  P.rootNode<-cophy[[2]]$edge[match(NA,P.ancBranches),1]#
#
  P.PBranches<-rbind(data.frame(alive=NA,nodeBirth=0,tBirth=cophy[[2]]$root.time,nodeDeath=P.rootNode,tDeath=cophy[[2]]$root.time+cophy[[2]]$root.edge,Hassoc=cophy[[2]]$root.Hassoc,branchNo=1),P.PBranches) # adding the root#
#
  if (!is.null(cophy[[2]]$nAlive)) { # if the phylo object contains information about how many species are alive#
    P.PBranches$alive<-FALSE#
    if (cophy[[2]]$nAlive>0) {#
      P.PBranches$alive[P.PBranches$tDeath==max(P.PBranches$tDeath)]<-TRUE#
    }#
  }#
#
  Q.PBranches<-data.frame(alive=rep(NA,nrow(cophy[[3]]$edge)),nodeBirth=cophy[[3]]$edge[,1],tBirth=NA,nodeDeath=cophy[[3]]$edge[,2],tDeath=NA,Hassoc=NA,branchNo=2:(nrow(cophy[[3]]$edge)+1))#
#
  Q.ancBranches<-match(Q.PBranches$nodeBirth,Q.PBranches$nodeDeath)#
#
  Q.PBranches$tBirth<-sapply(1:length(Q.PBranches$nodeBirth),get_tBirth,phy=cophy[[3]],ancBranches=Q.ancBranches) + cophy[[3]]$root.time#
  Q.PBranches$tDeath<-Q.PBranches$tBirth+cophy[[3]]$edge.length#
  Q.PBranches$Hassoc<-cophy[[3]]$Hassoc+1#
  Q.rootNode<-cophy[[3]]$edge[match(NA,Q.ancBranches),1]#
#
  Q.PBranches<-rbind(data.frame(alive=NA,nodeBirth=0,tBirth=cophy[[3]]$root.time,nodeDeath=Q.rootNode,tDeath=cophy[[3]]$root.time+cophy[[3]]$root.edge,Hassoc=cophy[[3]]$root.Hassoc,branchNo=1),Q.PBranches) # adding the root#
#
  if (!is.null(cophy[[3]]$nAlive)) { # if the phylo object contains information about how many species are alive#
    Q.PBranches$alive<-FALSE#
    if (cophy[[3]]$nAlive>0) {#
      Q.PBranches$alive[Q.PBranches$tDeath==max(Q.PBranches$tDeath)]<-TRUE#
    }#
  }
HPQtree
cophy<-HPQtree
# converting host tree:#
  HBranches<-data.frame(alive=rep(NA,nrow(cophy[[1]]$edge)),nodeBirth=cophy[[1]]$edge[,1],tBirth=NA,nodeDeath=cophy[[1]]$edge[,2],tDeath=NA,branchNo=2:(nrow(cophy[[1]]$edge)+1))#
  ancBranches<-match(HBranches$nodeBirth,HBranches$nodeDeath)
HBranches$tBirth<-sapply(1:length(HBranches$nodeBirth),get_tBirth,phy=cophy[[1]],ancBranches=ancBranches)#
  HBranches$tDeath<-HBranches$tBirth+cophy[[1]]$edge.length#
  rootNode<-cophy[[1]]$edge[match(NA,ancBranches),1]#
  HBranches<-rbind(data.frame(alive=NA,nodeBirth=0,tBirth=0,nodeDeath=rootNode,tDeath=cophy[[1]]$root.edge,branchNo=1),HBranches) # adding the root
# utils.R#
#
# This file various helper functions for internal use.#
# This file is part of the R-package 'cophylo'.#
#
#' A function to calculate the initial host resistance trait values prior to host clade invasion by a parasite#
#'#
#' This function simulates a parasite phylogenetic tree over a pre-built host-tree. While simulating parasite tree, also simulates the evolution of a host resistance trait as a result of stochastic mutation as well as in responce to the presence of a parasite. The success of the parasite being influenced by the resistance or susceptibility of the host.#
#' @param H.tree a pre-built host phylogenetic tree#
#' @param P.startT the timepoint at which a parasite invades the host-tree#
#' @param epsilon.1to0 the basline mutation rate for a host to lose the resistance trait#
#' @param epsilon.0to1 the basline mutation rate for a host to gain the resistance trait#
#' @param startTrait specifies the initial resistance trait of the first host species (0 or 1). Defaults to NA (random)#
#' @param timestep timestep for simulations#
#' @export#
#' @examples#
#' Htree<-rphylo_H(tmax=5, export.format="Raw")#
#' get_preInvasionTraits(Htree=Htree, P.startT=2.5, epsilon.1to0=0.01, epsilon.0to1=0.01)#
#
get_preInvasionTraits<-function(H.tree, P.startT, epsilon.1to0, epsilon.0to1, startTrait=NA, timestep=0.001)#
{#
  epsilon.1to0	<- epsilon.1to0*timestep#
  epsilon.0to1	<- epsilon.0to1*timestep#
  t<-0 # initiate time counter#
#
  if (class(H.tree)=="data.frame") {#
  	HBranches<-H.tree[which(H.tree[,5]>=0 && H.tree[,3]==0),] # begin from the initial branch#
  	if (is.na(startTrait)) {#
  		HBranches$Resistance<-sample(c(0,1), 1, 0.5) # randomly choose start value#
  	} else if (startTrait %in% c(0,1)) {#
  		HBranches$Resistance<-startTrait#
  	}#
#
  } else if (class(H.tree)=="big.matrix") { # allowing the use of bigmatrix to reduce RAM burden#
  	HBranches<-H.tree[which(H.tree[,5]>=0 && H.tree[,3]==0),] # begin from the initial branch#
  	HBranches<-t(as.data.frame(HBranches))#
  	if (is.na(startTrait)) {#
  		res<-data.frame(Resistance=sample(c(0,1), 1, 0.5)) # randomly choose start value#
  	} else if (startTrait %in% c(0,1)) {#
  		res<-data.frame(Resistance=startTrait)#
  	}#
  	HBranches<-cbind(HBranches, res)#
  } else {#
  	stop("H.tree object of incompatible data type")#
  }#
#
  TraitTracking<-vector("list",length(H.tree[,1]))#
  for (i in 1:length(H.tree[,1])) {#
    TraitTracking[[i]]<-matrix(NA, ncol=2, nrow=1)#
    colnames(TraitTracking[[i]])<-c("Timepoint","Trait.value")#
  }#
#
  TraitTracking[[1]][1,]<-c(0, HBranches$Resistance) # Setting initial trait value and simulation start time#
#
  while (t<=P.startT) {#
    t<-t+timestep#
    H.Death <-which(HBranches$tDeath >= (t-timestep) & HBranches$tDeath < t) # Any host branch that dies w/in timestep interval leading up to time t#
    if (length(H.Death)>0) {# if any host dies w/in interval#
      for (i in HBranches$nodeDeath[H.Death][order(HBranches$nodeDeath[H.Death])]) # for each node where a host died#
      {#
        # Speciation events:#
        if (i %in% H.tree[,2])   # Check if host death is due to speciation#
        {#
          H.Speciations		<-which(HBranches$nodeDeath == i) # H row speciating at time t at particular node#
#
          TraitTracking[[HBranches$branchNo[H.Speciations]]]<-																							rbind(TraitTracking[[HBranches$branchNo[H.Speciations]]], 															c(HBranches$tDeath[H.Speciations], HBranches$Resistance[H.Speciations])) 											# Recording death time and trait#
#
          daughterBranches	<-which(H.tree[,2] == i)#
#
          HBranches           <-rbind(HBranches, c(H.tree[daughterBranches[1], 1:6], 																	Resistance=HBranches$Resistance[H.Speciations]))#
          HBranches          	<-rbind(HBranches, c(H.tree[daughterBranches[2], 1:6], 																	Resistance=HBranches$Resistance[H.Speciations]))#
#
          timepoint           <-HBranches$tDeath[H.Speciations] # use exact time of death as opposed to current time t#
#
          TraitTracking[[daughterBranches[1]]][1,]<-c(H.tree[,3][daughterBranches[1]], 																HBranches$Resistance[H.Speciations])#
          TraitTracking[[daughterBranches[2]]][1,]<-c(H.tree[,3][daughterBranches[2]], 															HBranches$Resistance[H.Speciations])#
#
          # delete all extinct hosts from living tree#
          HBranches	<-HBranches[-H.Speciations,]#
        }#
        else # is an extinction event#
        {#
          H.Extinctions	<-which(HBranches$nodeDeath == i) # H branch extinct at time t at particular node#
#
          if (length(H.Extinctions)>0) {#
            for (j in H.Extinctions) {#
              TraitTracking[[HBranches$branchNo[j]]]<-rbind(TraitTracking[[HBranches$branchNo[j]]], 												c(HBranches$tDeath[j], HBranches$Resistance[j]))#
            }#
            # removing all host mother branches that have died#
            HBranches	<-HBranches[-H.Extinctions,] # delete all extinct hosts from living tree#
          }#
#
        } # completed speciation/extinction loops#
#
      } # completed loop through H.Death.Nodes#
#
    }#
    # See if there is any trait mutation on the living branches#
#
    # host mutation:#
    Mutate.0to1			<-stats::rbinom(1,length(which(HBranches$Resistance==0)),epsilon.0to1) # how many parasite species go extinct?#
    Mutate.1to0			<-stats::rbinom(1,length(which(HBranches$Resistance==1)),epsilon.1to0) # how many parasite species go extinct?#
#
    if (Mutate.0to1>0) {#
      HToMutate<-sample.int(length(which(HBranches$Resistance==0)),Mutate.0to1) # which parasites?#
      HToMutate<-HToMutate[HBranches$tBirth[HToMutate]<(t-timestep)] # remove those that have just arisen in the same timestep; this is necessary to avoid problems such as negative branch lenghts#
#
      for (i in HBranches$branchNo[which(HBranches$Resistance==0)[HToMutate]]) {#
        HBranches$Resistance[which(HBranches$branchNo==i)]	<-1#
        TraitTracking[[i]]<-rbind(TraitTracking[[i]],c(t-stats::runif(1,max=timestep),1))#
      }#
    }#
#
    if (Mutate.1to0>0) {#
      HToMutate<-sample.int(length(which(HBranches$Resistance==1)),Mutate.1to0) # which parasites?#
      HToMutate<-HToMutate[HBranches$tBirth[HToMutate]<(t-timestep)] # remove those that have just arisen in the same timestep; this is necessary to avoid problems such as negative branch lenghts#
      for (i in HBranches$branchNo[which(HBranches$Resistance==1)[HToMutate]]) {#
        HBranches$Resistance[which(HBranches$branchNo==i)]	<-0#
        TraitTracking[[i]]<-rbind(TraitTracking[[i]],c(t-stats::runif(1,max=timestep),0))#
      }#
    }#
  }#
  return(list(HBranches, TraitTracking))#
}#
#' (recursive) function to obtain the time of birth of a branch n, given a tree in phy in phylo format and a list of ancestor branches for that tree#
#'#
#' @param n some branch in a tree#
#' @param root.edge object sourced from tree in phylo format#
#' @param edge.length object sourced from tree in phylo format#
#' @param ancBranches the ancestral branches for the tree#
#
get_tBirth<-function(n,root.edge,edge.length,ancBranches)#
{#
  if (is.na(ancBranches[n])) return(root.edge)#
  else return(get_tBirth(ancBranches[n],root.edge,edge.length,ancBranches)+edge.length[ancBranches[n]])#
}#
#
#' Function to add new column to Branches dataframe indicating for each branch whether or not it leaves any extant descendents#
#'#
#' @param Branches tree in internal branch format#
#
add_branchSurvival<-function(Branches)#
{#
  Branches$surviving<-FALSE#
  for (i in which(Branches$alive))#
  {#
    j<-i#
    while ((!is.na(j)) & (Branches$surviving[j]==FALSE))#
    {#
      Branches$surviving[j]<-TRUE#
      j<-match(Branches$nodeBirth[j],Branches$nodeDeath)#
    }#
  }#
  return(Branches)#
}#
#' Function to obtain the time of a node relative to the root#
#'#
#' @param phy tree in phylo format#
#' @param node a particular node in the tree#
#' @keywords node, root#
#
get_nodeTime<-function(phy,node)#
{#
  nnode<-node#
  t<-0#
  nedge<-match(nnode,phy$edge[,2])  # find corresponding edge#
  while (!is.na(nedge))#
  {#
    t<-t+phy$edge.length[nedge] # add edge.length to total time#
    nnode<-phy$edge[nedge,1] # set new node to ancestral node#
    nedge<-match(nnode,phy$edge[,2])  # find corresponding new edge#
  }#
  return(t+phy$root.edge)#
}
HBranches$tBirth<-sapply(1:length(HBranches$nodeBirth),get_tBirth,phy=cophy[[1]],ancBranches=ancBranches)#
  HBranches$tDeath<-HBranches$tBirth+cophy[[1]]$edge.length#
  rootNode<-cophy[[1]]$edge[match(NA,ancBranches),1]#
  HBranches<-rbind(data.frame(alive=NA,nodeBirth=0,tBirth=0,nodeDeath=rootNode,tDeath=cophy[[1]]$root.edge,branchNo=1),HBranches) # adding the root
HBranches<-data.frame(alive=rep(NA,nrow(cophy[[1]]$edge)),nodeBirth=cophy[[1]]$edge[,1],tBirth=NA,nodeDeath=cophy[[1]]$edge[,2],tDeath=NA,branchNo=2:(nrow(cophy[[1]]$edge)+1))#
  ancBranches<-match(HBranches$nodeBirth,HBranches$nodeDeath)#
#
  HBranches$tBirth<-sapply(1:length(HBranches$nodeBirth),get_tBirth,phy=cophy[[1]],ancBranches=ancBranches)#
  HBranches$tDeath<-HBranches$tBirth+cophy[[1]]$edge.length#
  rootNode<-cophy[[1]]$edge[match(NA,ancBranches),1]#
  HBranches<-rbind(data.frame(alive=NA,nodeBirth=0,tBirth=0,nodeDeath=rootNode,tDeath=cophy[[1]]$root.edge,branchNo=1),HBranches) # adding the root
HBranches<-data.frame(alive=rep(NA,nrow(cophy[[1]]$edge)),nodeBirth=cophy[[1]]$edge[,1],tBirth=NA,nodeDeath=cophy[[1]]$edge[,2],tDeath=NA,branchNo=2:(nrow(cophy[[1]]$edge)+1))
HBranches
ancBranches<-match(HBranches$nodeBirth,HBranches$nodeDeath)
ancBranches
cophy[[1]]
ancBranches
HBranches$tBirth<-sapply(1:length(HBranches$nodeBirth),get_tBirth,phy=cophy[[1]],ancBranches=ancBranches)
HPBranches<-rcophylo_HP(tmax=5)#
 convert_HPCophyloToBranches(cophy=HPBranches)
cophy<-HPBranches
HBranches<-data.frame(alive=rep(NA,nrow(cophy[[1]]$edge)),nodeBirth=cophy[[1]]$edge[,1],tBirth=NA,nodeDeath=cophy[[1]]$edge[,2],tDeath=NA,branchNo=2:(nrow(cophy[[1]]$edge)+1))#
  ancBranches<-match(HBranches$nodeBirth,HBranches$nodeDeath)
ancBranches
HBranches$tBirth<-sapply(1:length(HBranches$nodeBirth),get_tBirth,cophy[[1]]$root.edge, cophy[[1]]$edge.length,ancBranches=ancBranches)
HPQtree
convert_HPQCophyloToBranches(cophy=HPQtree)
# convert.R#
#
# This file contains several functions that convert (co-)phylogenies from a raw, dataframe format into the (co-)phylo class and back.#
# All of these functions are meant for internal use only.#
# This file is part of the R-package 'cophylo'.#
#' Converting raw trees to phylo format#
#'#
#' The following function converts raw host-parasite tree matricies into phylo format#
#' @param HBranches Host-tree in raw matrix format#
#' @param PBranches Parasite-tree in raw matrix format#
#' @param prune.extinct whether to remove all extinct branches (defaulting to FALSE)#
#' @export#
#' @examples#
#' HPBranches<-rcophylo_HP(tmax=5, export.format = "Raw")#
#' convert_HPBranchesToCophylo(HBranches=HPBranches[[1]], PBranches=HPBranches[[2]])#
#
convert_HPBranchesToCophylo<-function(HBranches,PBranches,prune.extinct=FALSE)#
{#
  # number of host and parasite branches:#
  nHBranches<-length(HBranches[,1])#
  nPBranches<-length(PBranches[,1])#
#
  # number of living host and parasite species:#
  nHAlive<-sum(HBranches$alive[HBranches$alive==TRUE])#
  nPAlive<-sum(PBranches$alive[PBranches$alive==TRUE])#
#
  # check if we have a host tree (with more than the initial branch):#
  if (nHBranches==1)#
  {#
    Hphy <- list( edge = NA,edge.length = NA,tip.label = NA,root.edge=HBranches$tDeath[1], nAlive=0)#
    class(Hphy) 		   <- "phylo"#
    Pphy <- list( edge = NA,edge.length = NA,tip.label = NA,root.edge=PBranches$tDeath[1], nAlive=0, Hassoc = NA)#
    class(Pphy) 		   <- "phylo"#
    return(c(Hphy,Pphy))#
  }#
  # deleting the first branch (the root) of host and parasite trees:#
  # (This is necessary because Phylo trees in APE don't have an initial branch.)#
#
  Proot.edge  <-PBranches$tDeath[1]-PBranches$tBirth[1]#
  Proot.time  <-PBranches$tBirth[1]#
  Proot.Hassoc<-PBranches$Hassoc[1]#
  Hroot.edge  <-HBranches$tDeath[1]-HBranches$tBirth[1]#
  HBranches <-HBranches[-1,]#
  nHBranches <-nHBranches-1#
  PBranches$Hassoc<-PBranches$Hassoc-1#
  PBranches   <-PBranches[-1,]  # deleting the first branch (the root)#
  nPBranches <-nPBranches-1#
#
  # relabeling all the nodes so that they are ordered with surviving species first, then external nodes, then internal ones, for host tree:#
#
  rHBranches <- HBranches#
  i.tip <- 1#
  i.ext <- nHAlive + 1#
  i.int <- (nHBranches/2 + 2)#
#
  for ( i in 1:(nHBranches+1))#
  {#
    if ( any( HBranches$nodeBirth == i ) )     # is node i an internal node?#
    {#
      rHBranches$nodeBirth[HBranches$nodeBirth == i] <- i.int#
      rHBranches$nodeDeath[HBranches$nodeDeath == i] <- i.int#
      i.int <- i.int + 1#
    }#
    else 									# node i is an external node#
    {#
      if ((nHAlive>0)&&(HBranches$alive[HBranches$nodeDeath==i]==1))#
      {#
        rHBranches$nodeDeath[HBranches$nodeDeath==i]<-i.tip#
        i.tip <- i.tip + 1#
      }#
      else#
      {#
        rHBranches$nodeDeath[HBranches$nodeDeath==i]<-i.ext#
        i.ext <- i.ext + 1#
      }#
    }#
  }#
#
  # relabeling all the nodes so that they are ordered with surviving species first, then external nodes, then internal ones, for parasite tree:#
#
  rPBranches <- PBranches#
  i.tip <- 1#
  i.ext <- nPAlive + 1#
  i.int <- (nPBranches/2 + 2)#
#
  for ( i in 1:(nPBranches+1))#
  {#
    if ( any( PBranches$nodeBirth == i ) )     # is node i an internal node?#
    {#
      rPBranches$nodeBirth[PBranches$nodeBirth == i] <- i.int#
      rPBranches$nodeDeath[PBranches$nodeDeath == i] <- i.int#
      i.int <- i.int + 1#
    }#
    else 									# node i is an external node#
    {#
      if ((nPAlive>0)&&(PBranches$alive[PBranches$nodeDeath==i]==1))#
      {#
        rPBranches$nodeDeath[PBranches$nodeDeath==i]<-i.tip#
        i.tip <- i.tip + 1#
      }#
      else#
      {#
        rPBranches$nodeDeath[PBranches$nodeDeath==i]<-i.ext#
        i.ext <- i.ext + 1#
      }#
    }#
  }#
#
  # exclude extinct taxa:#
#
  if (prune.extinct==TRUE)#
  {#
    # find nodes that don't leave any descendents:#
#
    nodeHDead<-rep(TRUE,nHBranches+1)#
    nodeHDead[rHBranches$nodeBirth[1]]<-FALSE # root is definitely alive!#
    for(i in 1:nHAlive)#
    {#
      n<-i#
      while (nodeHDead[n]==TRUE)#
      {#
        nodeHDead[n]<-FALSE#
        n<-rHBranches$nodeBirth[rHBranches$nodeDeath==n]#
      }#
    }#
#
    nodePDead<-rep(TRUE,nPBranches+1)#
    nodePDead[rPBranches$nodeBirth[1]]<-FALSE # root is definitely alive!#
    for(i in 1:nPAlive)#
    {#
      n<-i#
      while (nodePDead[n]==TRUE)#
      {#
        nodePDead[n]<-FALSE#
        n<-rPBranches$nodeBirth[rPBranches$nodeDeath==n]#
      }#
    }#
    # keep only branches that terminate in live nodes:#
#
    prunedHBranches<-rHBranches[!nodeHDead[rHBranches$nodeDeath],]#
    prunedPBranches<-rPBranches[!nodePDead[rPBranches$nodeDeath],]#
#
    # find and collapse nodes that are no nodes anymore:#
#
    nHBranches<-length(prunedHBranches[,1]) # collapse H ~nodes#
    for (i in 1:nHBranches)#
    {#
      if ((prunedHBranches$nodeDeath[i]>nHAlive)&&(length(prunedHBranches[prunedHBranches$nodeBirth==prunedHBranches$nodeDeath[i],1])==1))#
        # this branch does not terminate in a tip and also not in two new branches#
      {#
        fuse<-(prunedHBranches$nodeBirth==prunedHBranches$nodeDeath[i])   # vector marking the branch that fuses to branch i#
        prunedHBranches$nodeBirth[fuse]<-prunedHBranches$nodeBirth[i]#
        prunedHBranches$tBirth[fuse]<-prunedHBranches$tBirth[i]#
        prunedHBranches$nodeBirth[i]<-0  # mark this branch as dead for later deletion#
      }#
    }#
#
    nPBranches<-length(prunedPBranches[,1]) # collapse P ~nodes#
    for (i in 1:nPBranches)#
    {#
      if ((prunedPBranches$nodeDeath[i]>nPAlive)&&(length(prunedPBranches[prunedPBranches$nodeBirth==prunedPBranches$nodeDeath[i],1])==1))#
        # this branch does not terminate in a tip and also not in two new branches#
      {#
        Pfuse<-(prunedPBranches$nodeBirth==prunedPBranches$nodeDeath[i])   # vector marking the branch that fuses to branch i#
        prunedPBranches$nodeBirth[Pfuse]<-prunedPBranches$nodeBirth[i]#
        prunedPBranches$tBirth[Pfuse]<-prunedPBranches$tBirth[i]#
        prunedPBranches$nodeBirth[i]<-0  # mark this branch as dead for later deletion#
      }#
    }#
    # if a new root branch has been formed, mark this for deletion as well H:#
#
    for (i in 1:nHBranches)#
    {#
      if ((prunedHBranches$nodeBirth[i]>0)&&(length(prunedHBranches[prunedHBranches$nodeBirth==prunedHBranches$nodeBirth[i],1])<2))#
        prunedHBranches$nodeBirth[i]<-0#
    }#
#
    prunedHBranches<-prunedHBranches[prunedHBranches$nodeBirth>0,]#
    nHBranches<-length(prunedHBranches[,1])#
#
    # if a new root branch has been formed, mark this for deletion as well P:#
#
    for (i in 1:nPBranches)#
    {#
      if ((prunedPBranches$nodeBirth[i]>0)&&(length(prunedPBranches[prunedPBranches$nodeBirth==prunedPBranches$nodeBirth[i],1])<2))#
        prunedPBranches$nodeBirth[i]<-0#
    }#
#
    prunedPBranches<-prunedPBranches[prunedPBranches$nodeBirth>0,]#
    nPBranches<-length(prunedPBranches[,1])#
#
    # relabel nodes so that only nodes 1...2n-1 exist H:#
#
    prunedHBranches<-prunedHBranches[order(prunedHBranches$tBirth),]#
    newNodeBirth<-sort(rep((nHAlive+1):(2*nHAlive-1),2))#
    newNodeDeath<-rep(0,nHBranches)#
    for (i in 1:nHBranches)#
    {#
      if (prunedHBranches$nodeDeath[i]>nHAlive)#
        newNodeDeath[i]<-newNodeBirth[prunedHBranches$nodeBirth==prunedHBranches$nodeDeath[i]][1]#
      else#
        newNodeDeath[i]<-prunedHBranches$nodeDeath[i]#
    }#
    prunedHBranches$nodeBirth<-newNodeBirth#
    prunedHBranches$nodeDeath<-newNodeDeath#
#
    # relabel nodes so that only nodes 1...2n-1 exist P:#
#
    prunedPBranches<-prunedPBranches[order(prunedPBranches$tBirth),]#
    newNodePBirth<-sort(rep((nPAlive+1):(2*nPAlive-1),2))#
    newNodePDeath<-rep(0,nPBranches)#
    for (i in 1:nPBranches)#
    {#
      if (prunedPBranches$nodeDeath[i]>nPAlive)#
        newNodePDeath[i]<-newNodePBirth[prunedPBranches$nodeBirth==prunedPBranches$nodeDeath[i]][1]#
      else#
        newNodePDeath[i]<-prunedPBranches$nodeDeath[i]#
    }#
    prunedPBranches$nodeBirth<-newNodePBirth#
    prunedPBranches$nodeDeath<-newNodePDeath#
  }#
#
  # translate into phylo format:#
#
  if (prune.extinct==TRUE)#
  {#
    Hphy <- list(edge = cbind(prunedHBranches$nodeBirth,prunedHBranches$nodeDeath), edge.length = prunedHBranches$tDeath-prunedHBranches$tBirth,tip.label=paste("t", 1:nHAlive, sep=""),root.edge=Hroot.edge, nAlive=nHAlive)#
    class(Hphy) 		   <- "phylo"#
    Hphy$Nnode<-nHAlive-1#
#
    Pphy <- list(edge = cbind(prunedPBranches$nodeBirth,prunedPBranches$nodeDeath), edge.length = prunedPBranches$tDeath-prunedPBranches$tBirth,tip.label=paste("t", 1:nPAlive, sep=""),root.edge=Proot.edge, root.time=Proot.time, nAlive=nPAlive,Hassoc=prunedPBranches$Hassoc, root.Hassoc=Proot.Hassoc)#
    class(Pphy) 		   <- "phylo"#
    Pphy$Nnode<-nPAlive-1#
  } else   # extinct taxa included:#
  {#
    Hphy <- list( edge = cbind(rHBranches$nodeBirth, rHBranches$nodeDeath),edge.length=rHBranches$tDeath-rHBranches$tBirth,tip.label=paste("t", 1:(1+nHBranches/2), sep=""),root.edge=Hroot.edge, nAlive=nHAlive)#
    class(Hphy) 		   <- "phylo"#
    Hphy$Nnode 			   <- nHBranches/2#
#
    Pphy <- list( edge = cbind(rPBranches$nodeBirth, rPBranches$nodeDeath),edge.length=rPBranches$tDeath-rPBranches$tBirth,tip.label=paste("t", 1:(1+nPBranches/2), sep =""),root.edge=Proot.edge,  root.time=Proot.time, nAlive=nPAlive,Hassoc=rPBranches$Hassoc , root.Hassoc=Proot.Hassoc)#
    class(Pphy) 		   <- "phylo"#
    Pphy$Nnode 			   <- nPBranches/2#
  }#
#
  return(list(Hphy,Pphy))#
}#
#' Converting raw tree to phylo format#
#'#
#' The following function converts a raw host tree matrix into phylo format#
#' @param HBranches Host-tree in raw matrix format#
#' @param prune.extinct whether to remove all extinct branches (defaulting to FALSE)#
#
convert_HBtoPhy <-function(HBranches,prune.extinct=FALSE)#
{#
  # number of host and parasite branches:#
  nHBranches<-nrow(HBranches)#
#
  # number of living host and parasite species:#
  nHAlive<-sum(HBranches[,1][HBranches[,1]==TRUE])#
#
  # check if we have a host tree (with more than the initial branch):#
  if (nHBranches==1)#
  {#
    Hphy <- list( edge = NA,edge.length = NA,tip.label = NA,root.edge=HBranches$tDeath[1], nAlive=0)#
    class(Hphy) 		   <- "phylo"#
  }#
  # deleting the first branch (the root) of host and parasite trees:#
  # (This is necessary because Phylo trees in APE don't have an initial branch.)#
#
  Hroot.edge  <-HBranches[,5][1]-HBranches[,3][1]#
  HBranches <-HBranches[-1,]#
  nHBranches <-nHBranches-1#
#
  # relabeling all the nodes so that they are ordered with surviving species first, then external nodes, then internal ones, for host tree:#
#
  rHBranches <- HBranches#
  i.tip <- 1#
  i.ext <- nHAlive + 1#
  i.int <- (nHBranches/2 + 2)#
#
  for ( i in 1:(nHBranches+1))#
  {#
    if ( any( HBranches[,2] == i ) )     # is node i an internal node?#
    {#
      rHBranches[,2][HBranches[,2] == i] <- i.int#
      rHBranches[,4][HBranches[,4] == i] <- i.int#
      i.int <- i.int + 1#
    }#
    else 									# node i is an external node#
    {#
      if ((nHAlive>0)&&(HBranches[,1][HBranches[,4]==i]==1))#
      {#
        rHBranches[,4][HBranches[,4]==i]<-i.tip#
        i.tip <- i.tip + 1#
      }#
      else#
      {#
        rHBranches[,4][HBranches[,4]==i]<-i.ext#
        i.ext <- i.ext + 1#
      }#
    }#
  }#
#
  # exclude extinct taxa:#
#
  if (prune.extinct==TRUE)#
  {#
    # find nodes that don't leave any descendents:#
#
    nodeHDead<-rep(TRUE,nHBranches+1)#
    nodeHDead[rHBranches[,2][1]]<-FALSE # root is definitely alive!#
    for(i in 1:nHAlive)#
    {#
      n<-i#
      while (nodeHDead[n]==TRUE)#
      {#
        nodeHDead[n]<-FALSE#
        n<-rHBranches[,2][rHBranches[,4]==n]#
      }#
    }#
#
    # keep only branches that terminate in live nodes:#
#
    prunedHBranches<-rHBranches[!nodeHDead[rHBranches[,4]],]#
#
    # find and collapse nodes that are no nodes anymore:#
#
    nHBranches<-length(prunedHBranches[,1]) # collapse H ~nodes#
    for (i in 1:nHBranches)#
    {#
      if ((prunedHBranches$nodeDeath[i]>nHAlive)&&(length(prunedHBranches[prunedHBranches$nodeBirth==prunedHBranches$nodeDeath[i],1])==1))#
        # this branch does not terminate in a tip and also not in two new branches#
      {#
        fuse<-(prunedHBranches$nodeBirth==prunedHBranches$nodeDeath[i])   # vector marking the branch that fuses to branch i#
        prunedHBranches$nodeBirth[fuse]<-prunedHBranches$nodeBirth[i]#
        prunedHBranches$tBirth[fuse]<-prunedHBranches$tBirth[i]#
        prunedHBranches$nodeBirth[i]<-0  # mark this branch as dead for later deletion#
      }#
    }#
#
    # if a new root branch has been formed, mark this for deletion as well H:#
#
    for (i in 1:nHBranches)#
    {#
      if ((prunedHBranches$nodeBirth[i]>0)&&(length(prunedHBranches[prunedHBranches$nodeBirth==prunedHBranches$nodeBirth[i],1])<2))#
        prunedHBranches$nodeBirth[i]<-0#
    }#
#
    prunedHBranches<-prunedHBranches[prunedHBranches$nodeBirth>0,]#
    nHBranches<-length(prunedHBranches[,1])#
#
    # relabel nodes so that only nodes 1...2n-1 exist:#
#
    prunedHBranches<-prunedHBranches[order(prunedHBranches$tBirth),]#
    newNodeBirth<-sort(rep((nHAlive+1):(2*nHAlive-1),2))#
    newNodeDeath<-rep(0,nHBranches)#
    for (i in 1:nHBranches)#
    {#
      if (prunedHBranches$nodeDeath[i]>nHAlive)#
        newNodeDeath[i]<-newNodeBirth[prunedHBranches$nodeBirth==prunedHBranches$nodeDeath[i]][1]#
      else#
        newNodeDeath[i]<-prunedHBranches$nodeDeath[i]#
    }#
    prunedHBranches$nodeBirth<-newNodeBirth#
    prunedHBranches$nodeDeath<-newNodeDeath#
#
  }#
#
  # translate into phylo format:#
#
  if (prune.extinct==TRUE)#
  {#
    Hphy <- list(edge = cbind(prunedHBranches$nodeBirth,prunedHBranches$nodeDeath), edge.length = prunedHBranches$tDeath-prunedHBranches$tBirth,tip.label=paste("t", 1:nHAlive, sep=""),root.edge=Hroot.edge, nAlive=nHAlive)#
    class(Hphy) 		   <- "phylo"#
    Hphy$Nnode<-nHAlive-1#
  } else   # extinct taxa included:#
  {#
    Hphy <- list( edge = cbind(rHBranches[,2], rHBranches[,4]),edge.length=rHBranches[,5]-rHBranches[,3],tip.label=paste("t", 1:(1+nHBranches/2), sep=""),root.edge=Hroot.edge, nAlive=nHAlive)#
    class(Hphy) 		   <- "phylo"#
    Hphy$Nnode 			   <- nHBranches/2#
  }#
#
  return(Hphy)#
}#
#
#' Converting raw Parasite tree to phylo format#
#'#
#' The following function converts a raw parasite tree matrix into phylo format#
#' @param PBranches Parasite-tree in raw matrix format#
#' @param prune.extinct whether to remove all extinct branches (defaulting to FALSE)#
#' @keywords format, convert, phylo#
#' @export#
#' @examples#
#' HPBranches<-rcophylo_HP(tmax=5, export.format = "Raw")#
#' convert_PBranchesToPhylo(PBranches=HPBranches[[2]])#
#
convert_PBranchesToPhylo<-function(PBranches,prune.extinct=FALSE)#
{#
  # number of branches:#
  nPBranches<-length(PBranches[,1])#
#
  # number of living parasite species:#
  nPAlive<-sum(PBranches$alive[PBranches$alive==TRUE])#
#
  # deleting the first branch (the root) of host and parasite trees:#
  # (This is necessary because Phylo trees in APE don't have an initial branch.)#
#
  Proot.edge  <-PBranches$tDeath[1]-PBranches$tBirth[1]#
  Proot.time  <-PBranches$tBirth[1]#
  Proot.Hassoc<-PBranches$Hassoc[1]#
  PBranches$Hassoc<-PBranches$Hassoc-1#
  PBranches   <-PBranches[-1,]  # deleting the first branch (the root)#
  nPBranches <-nPBranches-1#
#
  # relabeling all the nodes so that they are ordered with surviving species first, then external nodes, then internal ones:#
#
  rPBranches <- PBranches#
  i.tip <- 1#
  i.ext <- nPAlive + 1#
  i.int <- (nPBranches/2 + 2)#
#
  for ( i in 1:(nPBranches+1))#
  {#
    if ( any( PBranches$nodeBirth == i ) )     # is node i an internal node?#
    {#
      rPBranches$nodeBirth[PBranches$nodeBirth == i] <- i.int#
      rPBranches$nodeDeath[PBranches$nodeDeath == i] <- i.int#
      i.int <- i.int + 1#
    }#
    else 									# node i is an external node#
    {#
      if ((nPAlive>0)&&(PBranches$alive[PBranches$nodeDeath==i]==1))#
      {#
        rPBranches$nodeDeath[PBranches$nodeDeath==i]<-i.tip#
        i.tip <- i.tip + 1#
      }#
      else#
      {#
        rPBranches$nodeDeath[PBranches$nodeDeath==i]<-i.ext#
        i.ext <- i.ext + 1#
      }#
    }#
  }#
#
  # exclude extinct taxa:#
#
  if (prune.extinct==TRUE)#
  {#
    # find nodes that don't leave any descendents:#
#
    nodePDead<-rep(TRUE,nPBranches+1)#
    nodePDead[rPBranches$nodeBirth[1]]<-FALSE # root is definitely alive!#
    for(i in 1:nPAlive)#
    {#
      n<-i#
      while (nodePDead[n]==TRUE)#
      {#
        nodePDead[n]<-FALSE#
        n<-rPBranches$nodeBirth[rPBranches$nodeDeath==n]#
      }#
    }#
    # keep only branches that terminate in live nodes:#
#
    prunedPBranches<-rPBranches[!nodePDead[rPBranches$nodeDeath],]#
#
    # find and collapse nodes that are no nodes anymore:#
#
    nPBranches<-length(prunedPBranches[,1]) # collapse P ~nodes#
    for (i in 1:nPBranches)#
    {#
      if ((prunedPBranches$nodeDeath[i]>nPAlive)&&(length(prunedPBranches[prunedPBranches$nodeBirth==prunedPBranches$nodeDeath[i],1])==1))#
        # this branch does not terminate in a tip and also not in two new branches#
      {#
        Pfuse<-(prunedPBranches$nodeBirth==prunedPBranches$nodeDeath[i])   # vector marking the branch that fuses to branch i#
        prunedPBranches$nodeBirth[Pfuse]<-prunedPBranches$nodeBirth[i]#
        prunedPBranches$tBirth[Pfuse]<-prunedPBranches$tBirth[i]#
        prunedPBranches$nodeBirth[i]<-0  # mark this branch as dead for later deletion#
      }#
    }#
#
    # if a new root branch has been formed, mark this for deletion as well P:#
#
    for (i in 1:nPBranches)#
    {#
      if ((prunedPBranches$nodeBirth[i]>0)&&(length(prunedPBranches[prunedPBranches$nodeBirth==prunedPBranches$nodeBirth[i],1])<2))#
        prunedPBranches$nodeBirth[i]<-0#
    }#
#
    prunedPBranches<-prunedPBranches[prunedPBranches$nodeBirth>0,]#
    nPBranches<-length(prunedPBranches[,1])#
#
    # relabel nodes so that only nodes 1...2n-1 exist P:#
#
    prunedPBranches<-prunedPBranches[order(prunedPBranches$tBirth),]#
    newNodePBirth<-sort(rep((nPAlive+1):(2*nPAlive-1),2))#
    newNodePDeath<-rep(0,nPBranches)#
    for (i in 1:nPBranches)#
    {#
      if (prunedPBranches$nodeDeath[i]>nPAlive)#
        newNodePDeath[i]<-newNodePBirth[prunedPBranches$nodeBirth==prunedPBranches$nodeDeath[i]][1]#
      else#
        newNodePDeath[i]<-prunedPBranches$nodeDeath[i]#
    }#
    prunedPBranches$nodeBirth<-newNodePBirth#
    prunedPBranches$nodeDeath<-newNodePDeath#
  }#
#
  # translate into phylo format:#
#
  if (prune.extinct==TRUE)#
  {#
    Pphy <- list(edge = cbind(prunedPBranches$nodeBirth,prunedPBranches$nodeDeath), edge.length = prunedPBranches$tDeath-prunedPBranches$tBirth,tip.label=paste("t", 1:nPAlive, sep=""),root.edge=Proot.edge, root.time=Proot.time, nAlive=nPAlive,Hassoc=prunedPBranches$Hassoc, root.Hassoc=Proot.Hassoc)#
    class(Pphy) 		   <- "phylo"#
    Pphy$Nnode<-nPAlive-1#
  } else   # extinct taxa included:#
  {#
    Pphy <- list( edge = cbind(rPBranches$nodeBirth, rPBranches$nodeDeath),edge.length=rPBranches$tDeath-rPBranches$tBirth,tip.label=paste("t", 1:(1+nPBranches/2), sep =""),root.edge=Proot.edge,  root.time=Proot.time, nAlive=nPAlive,Hassoc=rPBranches$Hassoc , root.Hassoc=Proot.Hassoc)#
    class(Pphy) 		   <- "phylo"#
    Pphy$Nnode 			   <- nPBranches/2#
  }#
#
  return(Pphy)#
}#
#' Converting raw trees to phylo format#
#'#
#' The following function converts raw dual parasite tree dataframes into phylo format#
#' @param P.PBranches Parasite-tree in raw matrix format#
#' @param Q.PBranches Parasite-tree in raw matrix format#
#' @param prune.extinct whether to remove all extinct branches (defaulting to FALSE)#
#' @export#
#' @examples#
#' Htree<-rphylo_H(tmax=5, export.format="Raw")#
#' HPQtree<-rcophylo_PQonH(H.tree=Htree, tmax=5, export.format="Raw")#
#' convert_PQBranchesToPhylo(P.PBranches=HPQtree[[1]],Q.PBranches=HPQtree[[2]])#
#
convert_PQBranchesToPhylo<-function(P.PBranches,Q.PBranches,prune.extinct=FALSE)#
{#
  # P conversion preparation#
  # number of branches:#
  P.nPBranches<-length(P.PBranches[,1])#
#
  # number of living parasite species:#
  P.nPAlive<-sum(P.PBranches$alive[P.PBranches$alive==TRUE])#
#
  # deleting the first branch (the root) of host and parasite trees:#
  # (This is necessary because Phylo trees in APE don't have an initial branch.)#
#
  P.Proot.edge		<- P.PBranches$tDeath[1]-P.PBranches$tBirth[1]#
  P.Proot.time		<- P.PBranches$tBirth[1]#
  P.Proot.Hassoc		<- P.PBranches$Hassoc[1]#
  P.PBranches$Hassoc	<- P.PBranches$Hassoc-1#
  P.PBranches			<- P.PBranches[-1,]  # deleting the first branch (the root)#
  P.nPBranches		<- P.nPBranches-1#
#
  # relabeling all the nodes so that they are ordered with surviving species first, then external nodes, then internal ones:#
#
  P.rPBranches		<- P.PBranches#
  P.i.tip				<- 1#
  P.i.ext				<- P.nPAlive + 1#
  P.i.int				<- (P.nPBranches/2 + 2)#
#
  for ( i in 1:(P.nPBranches+1))#
  {#
    if ( any(P.PBranches$nodeBirth == i ) )     # is node i an internal node?#
    {#
      P.rPBranches$nodeBirth[P.PBranches$nodeBirth == i] <- P.i.int#
      P.rPBranches$nodeDeath[P.PBranches$nodeDeath == i] <- P.i.int#
      P.i.int <- P.i.int + 1#
    }#
    else # node i is an external node#
    {#
      if ((P.nPAlive>0)&&(P.PBranches$alive[P.PBranches$nodeDeath==i]==1))#
      {#
        P.rPBranches$nodeDeath[P.PBranches$nodeDeath==i]<-P.i.tip#
        P.i.tip <- P.i.tip + 1#
      } else {#
        P.rPBranches$nodeDeath[P.PBranches$nodeDeath==i]<-P.i.ext#
        P.i.ext <- P.i.ext + 1#
      }#
    }#
  }#
#
  # exclude extinct taxa:#
#
  if (prune.extinct==TRUE)#
  {#
    # find nodes that don't leave any descendents:#
#
    P.nodePDead<-rep(TRUE,P.nPBranches+1)#
    P.nodePDead[P.rPBranches$nodeBirth[1]]<-FALSE # root is definitely alive!#
    for(i in 1:P.nPAlive)#
    {#
      n<-i#
      while (P.nodePDead[n]==TRUE)#
      {#
        P.nodePDead[n]<-FALSE#
        n<-P.rPBranches$nodeBirth[P.rPBranches$nodeDeath==n]#
      }#
    }#
    # keep only branches that terminate in live nodes:#
#
    P.prunedPBranches<-P.rPBranches[!P.nodePDead[P.rPBranches$nodeDeath],]#
#
    # find and collapse nodes that are no nodes anymore:#
#
    P.nPBranches<-length(P.prunedPBranches[,1]) # collapse P ~nodes#
    for (i in 1:P.nPBranches)#
    {#
      if ((P.prunedPBranches$nodeDeath[i]>P.nPAlive) && (length(P.prunedPBranches[P.prunedPBranches$nodeBirth==P.prunedPBranches$nodeDeath[i], 1])==1))#
        # this branch does not terminate in a tip and also not in two new branches#
      {#
        P.Pfuse <-(P.prunedPBranches$nodeBirth==P.prunedPBranches$nodeDeath[i]) # vector marking the branch that fuses to branch i#
        P.prunedPBranches$nodeBirth[P.Pfuse]	<-P.prunedPBranches$nodeBirth[i]#
        P.prunedPBranches$tBirth[P.Pfuse]		<-P.prunedPBranches$tBirth[i]#
        P.prunedPBranches$nodeBirth[i]			<-0  # mark this branch as dead for later deletion#
      }#
    }#
#
    # if a new root branch has been formed, mark this for deletion as well P:#
#
    for (i in 1:P.nPBranches)#
    {#
      if ((P.prunedPBranches$nodeBirth[i]>0)&&(length(P.prunedPBranches[P.prunedPBranches$nodeBirth==P.prunedPBranches$nodeBirth[i],1])<2))#
        P.prunedPBranches$nodeBirth[i]<-0#
    }#
#
    P.prunedPBranches<-P.prunedPBranches[P.prunedPBranches$nodeBirth>0,]#
    P.nPBranches<-length(P.prunedPBranches[,1])#
#
    # relabel nodes so that only nodes 1...2n-1 exist P:#
#
    P.prunedPBranches<-P.prunedPBranches[order(P.prunedPBranches$tBirth),]#
    P.newNodePBirth<-sort(rep((P.nPAlive+1):(2*P.nPAlive-1),2))#
    P.newNodePDeath<-rep(0,P.nPBranches)#
    for (i in 1:P.nPBranches)#
    {#
      if (P.prunedPBranches$nodeDeath[i]>P.nPAlive)#
        P.newNodePDeath[i]	<-P.newNodePBirth[P.prunedPBranches$nodeBirth==P.prunedPBranches$nodeDeath[i]][1]#
      else#
        P.newNodePDeath[i]	<-P.prunedPBranches$nodeDeath[i]#
    }#
    P.prunedPBranches$nodeBirth<-P.newNodePBirth#
    P.prunedPBranches$nodeDeath<-P.newNodePDeath#
  }#
#
  # Q conversion preparation#
  # number of branches:#
  Q.nPBranches<-length(Q.PBranches[,1])#
#
  # number of living parasite species:#
  Q.nPAlive<-sum(Q.PBranches$alive[Q.PBranches$alive==TRUE])#
#
  # deleting the first branch (the root) of host and parasite trees:#
  # (This is necessary because Phylo trees in APE don't have an initial branch.)#
#
  Q.Proot.edge		<- Q.PBranches$tDeath[1]-Q.PBranches$tBirth[1]#
  Q.Proot.time		<- Q.PBranches$tBirth[1]#
  Q.Proot.Hassoc		<- Q.PBranches$Hassoc[1]#
  Q.PBranches$Hassoc	<- Q.PBranches$Hassoc-1#
  Q.PBranches			<- Q.PBranches[-1,]  # deleting the first branch (the root)#
  Q.nPBranches		<- Q.nPBranches-1#
#
  # relabeling all the nodes so that they are ordered with surviving species first, then external nodes, then internal ones:#
#
  Q.rPBranches		<- Q.PBranches#
  Q.i.tip				<- 1#
  Q.i.ext				<- Q.nPAlive + 1#
  Q.i.int				<- (Q.nPBranches/2 + 2)#
#
  for ( i in 1:(Q.nPBranches+1))#
  {#
    if ( any(Q.PBranches$nodeBirth == i ) )     # is node i an internal node?#
    {#
      Q.rPBranches$nodeBirth[Q.PBranches$nodeBirth == i] <- Q.i.int#
      Q.rPBranches$nodeDeath[Q.PBranches$nodeDeath == i] <- Q.i.int#
      Q.i.int <- Q.i.int + 1#
    }#
    else # node i is an external node#
    {#
      if ((Q.nPAlive>0)&&(Q.PBranches$alive[Q.PBranches$nodeDeath==i]==1))#
      {#
        Q.rPBranches$nodeDeath[Q.PBranches$nodeDeath==i]<-Q.i.tip#
        Q.i.tip <- Q.i.tip + 1#
      } else {#
        Q.rPBranches$nodeDeath[Q.PBranches$nodeDeath==i]<-Q.i.ext#
        Q.i.ext <- Q.i.ext + 1#
      }#
    }#
  }#
#
  # exclude extinct taxa:#
#
  if (prune.extinct==TRUE)#
  {#
    # find nodes that don't leave any descendents:#
#
    Q.nodePDead<-rep(TRUE,Q.nPBranches+1)#
    Q.nodePDead[Q.rPBranches$nodeBirth[1]]<-FALSE # root is definitely alive!#
    for(i in 1:Q.nPAlive)#
    {#
      n<-i#
      while (Q.nodePDead[n]==TRUE)#
      {#
        Q.nodePDead[n]<-FALSE#
        n<-Q.rPBranches$nodeBirth[Q.rPBranches$nodeDeath==n]#
      }#
    }#
    # keep only branches that terminate in live nodes:#
#
    Q.prunedPBranches<-Q.rPBranches[!Q.nodePDead[Q.rPBranches$nodeDeath],]#
#
    # find and collapse nodes that are no nodes anymore:#
#
    Q.nPBranches<-length(Q.prunedPBranches[,1]) # collapse P ~nodes#
    for (i in 1:Q.nPBranches)#
    {#
      if ((Q.prunedPBranches$nodeDeath[i]>Q.nPAlive) && (length(Q.prunedPBranches[Q.prunedPBranches$nodeBirth==Q.prunedPBranches$nodeDeath[i], 1])==1))#
        # this branch does not terminate in a tip and also not in two new branches#
      {#
        Q.Pfuse <-(Q.prunedPBranches$nodeBirth==Q.prunedPBranches$nodeDeath[i]) # vector marking the branch that fuses to branch i#
        Q.prunedPBranches$nodeBirth[Q.Pfuse]	<-Q.prunedPBranches$nodeBirth[i]#
        Q.prunedPBranches$tBirth[Q.Pfuse]		<-Q.prunedPBranches$tBirth[i]#
        Q.prunedPBranches$nodeBirth[i]			<-0  # mark this branch as dead for later deletion#
      }#
    }#
#
    # if a new root branch has been formed, mark this for deletion as well P:#
#
    for (i in 1:Q.nPBranches)#
    {#
      if ((Q.prunedPBranches$nodeBirth[i]>0)&&(length(Q.prunedPBranches[Q.prunedPBranches$nodeBirth==Q.prunedPBranches$nodeBirth[i],1])<2))#
        Q.prunedPBranches$nodeBirth[i]<-0#
    }#
#
    Q.prunedPBranches<-Q.prunedPBranches[Q.prunedPBranches$nodeBirth>0,]#
    Q.nPBranches<-length(Q.prunedPBranches[,1])#
#
    # relabel nodes so that only nodes 1...2n-1 exist P:#
#
    Q.prunedPBranches<-Q.prunedPBranches[order(Q.prunedPBranches$tBirth),]#
    Q.newNodePBirth<-sort(rep((Q.nPAlive+1):(2*Q.nPAlive-1),2))#
    Q.newNodePDeath<-rep(0,Q.nPBranches)#
    for (i in 1:Q.nPBranches)#
    {#
      if (Q.prunedPBranches$nodeDeath[i]>Q.nPAlive)#
        Q.newNodePDeath[i]	<-Q.newNodePBirth[Q.prunedPBranches$nodeBirth==Q.prunedPBranches$nodeDeath[i]][1]#
      else#
        Q.newNodePDeath[i]	<-Q.prunedPBranches$nodeDeath[i]#
    }#
    Q.prunedPBranches$nodeBirth	<-Q.newNodePBirth#
    Q.prunedPBranches$nodeDeath	<-Q.newNodePDeath#
  }#
#
  # translate into phylo format:#
#
  if (prune.extinct==TRUE)#
  {#
    P.Pphy <- list(edge = cbind(P.prunedPBranches$nodeBirth,P.prunedPBranches$nodeDeath), edge.length = P.prunedPBranches$tDeath-P.prunedPBranches$tBirth,tip.label=paste("t", 1:P.nPAlive, sep=""),root.edge=P.Proot.edge, root.time=P.Proot.time, nAlive=P.nPAlive,Hassoc=P.prunedPBranches$Hassoc, root.Hassoc=P.Proot.Hassoc)#
    class(P.Pphy)			<- "phylo"#
    P.Pphy$Nnode			<- P.nPAlive-1#
#
    Q.Pphy <- list(edge = cbind(Q.prunedPBranches$nodeBirth,Q.prunedPBranches$nodeDeath), edge.length = Q.prunedPBranches$tDeath-Q.prunedPBranches$tBirth,tip.label=paste("t", 1:Q.nPAlive, sep=""),root.edge=Q.Proot.edge, root.time=Q.Proot.time, nAlive=Q.nPAlive,Hassoc=Q.prunedPBranches$Hassoc, root.Hassoc=Q.Proot.Hassoc)#
    class(Q.Pphy)			<- "phylo"#
    Q.Pphy$Nnode			<- Q.nPAlive-1#
  } else   # extinct taxa included:#
  {#
    P.Pphy <- list( edge = cbind(P.rPBranches$nodeBirth, P.rPBranches$nodeDeath),edge.length=P.rPBranches$tDeath-P.rPBranches$tBirth,tip.label=paste("t", 1:(1+P.nPBranches/2), sep =""),root.edge=P.Proot.edge,  root.time=P.Proot.time, nAlive=P.nPAlive,Hassoc=P.rPBranches$Hassoc , root.Hassoc=P.Proot.Hassoc)#
    class(P.Pphy)			<- "phylo"#
    P.Pphy$Nnode			<- P.nPBranches/2#
#
    Q.Pphy <- list( edge = cbind(Q.rPBranches$nodeBirth, Q.rPBranches$nodeDeath),edge.length=Q.rPBranches$tDeath-Q.rPBranches$tBirth,tip.label=paste("t", 1:(1+Q.nPBranches/2), sep =""),root.edge=Q.Proot.edge,  root.time=Q.Proot.time, nAlive=Q.nPAlive,Hassoc=Q.rPBranches$Hassoc , root.Hassoc=Q.Proot.Hassoc)#
    class(Q.Pphy)			<- "phylo"#
    Q.Pphy$Nnode			<- Q.nPBranches/2#
  }#
#
  return(list(P.Pphy,Q.Pphy))#
}#
#
#' Converting raw host trees to phylo format#
#'#
#' The following function converts raw host tree matricies into phylo format#
#' @param Hbranches Host-tree in raw matrix format#
#' @param prune.extinct whether to remove all extinct branches (defaulting to FALSE)#
#' @param fromHtree starting host-tree#
#' @param toHtree finishing host-tree#
#' @export#
#' @examples#
#' Hbranches<-rphylo_H(tmax=5, export.format = "Raw")#
#' convert_HBranchesToPhylo(Hbranches=Hbranches)#
#
convert_HBranchesToPhylo <-function(Hbranches, prune.extinct=FALSE, fromHtree=NA, toHtree=NA)#
{#
	if (class(Hbranches)=="data.frame") nHtrees<-1#
	else if (class(Hbranches)=="big.matrix") nHtrees<-1#
	else nHtrees<-length(Hbranches)#
#
	if (is.na(fromHtree)) {#
		fromHtree<-1#
	}#
	if (is.na(toHtree)) {#
    	toHtree<-nHtrees#
	}#
#
	TreesToConvert<-list()#
	HtreesPhylo<-list()#
	if (length(fromHtree:toHtree)!=nHtrees) {#
		for (i in fromHtree:toHtree) {#
			TreesToConvert[[i-(fromHtree-1)]]<- Hbranches[[i]]#
		}#
		if (length(fromHtree:toHtree)==1) {#
			phylo <-convert_HBtoPhy(TreesToConvert[[1]])#
			HtreesPhylo[[fromHtree]]<-phylo#
		} else {#
			phylo<-lapply(TreesToConvert, convert_HBtoPhy)  # converting to APE Phylo format#
			for (i in fromHtree:toHtree) {#
				HtreesPhylo[[i]] <-phylo[[i-(fromHtree-1)]]#
			}#
		}#
	} else {#
		if (nHtrees==1) HtreesPhylo<-convert_HBtoPhy(Hbranches)#
		else HtreesPhylo <-lapply(Hbranches, convert_HBtoPhy)  # converting to APE Phylo format#
	}#
	HtreesPhylo#
}#
#' Convert cophylogenetic trees from Ape's phylo format to the internal Branches format#
#'#
#' The following function converts a phylo host-parasite tree into internal Branches format#
#' @param cophy a cophylogeny (in phylo format) containing one host and one parasite tree#
#' @export#
#' @examples#
#' HPBranches<-rcophylo_HP(tmax=5)#
#' convert_HPCophyloToBranches(cophy=HPBranches)#
#
convert_HPCophyloToBranches<-function(cophy)#
{#
  # converting host tree:#
  HBranches<-data.frame(alive=rep(NA,nrow(cophy[[1]]$edge)),nodeBirth=cophy[[1]]$edge[,1],tBirth=NA,nodeDeath=cophy[[1]]$edge[,2],tDeath=NA,branchNo=2:(nrow(cophy[[1]]$edge)+1))#
  ancBranches<-match(HBranches$nodeBirth,HBranches$nodeDeath)#
#
  HBranches$tBirth<-sapply(1:length(HBranches$nodeBirth),get_tBirth,cophy[[1]]$root.edge, cophy[[1]]$edge.length,ancBranches=ancBranches)#
  HBranches$tDeath<-HBranches$tBirth+cophy[[1]]$edge.length#
  rootNode<-cophy[[1]]$edge[match(NA,ancBranches),1]#
  HBranches<-rbind(data.frame(alive=NA,nodeBirth=0,tBirth=0,nodeDeath=rootNode,tDeath=cophy[[1]]$root.edge,branchNo=1),HBranches) # adding the root#
#
  if (!is.null(cophy[[1]]$nAlive))  # if the phylo object contains information about how many species are alive#
  {#
    HBranches$alive<-FALSE#
    if (cophy[[1]]$nAlive>0) HBranches$alive[HBranches$tDeath==max(HBranches$tDeath)]<-TRUE#
  }#
#
  # converting parasite tree:#
  PBranches<-data.frame(alive=rep(NA,nrow(cophy[[2]]$edge)),nodeBirth=cophy[[2]]$edge[,1],tBirth=NA,nodeDeath=cophy[[2]]$edge[,2],tDeath=NA,Hassoc=NA,branchNo=2:(nrow(cophy[[2]]$edge)+1))#
#
  ancBranches<-match(PBranches$nodeBirth,PBranches$nodeDeath)#
#
  PBranches$tBirth<-sapply(1:length(PBranches$nodeBirth),get_tBirth,cophy[[2]]$root.edge, cophy[[2]]$edge.length,ancBranches=ancBranches) + cophy[[2]]$root.time#
  #	for (i in 1:length(PBranches$nodeBirth)) {#
  #		print(i)#
  #		PBranches$tBirth[i]<-get_tBirth(n=i, cophy[[2]]$root.edge, cophy[[2]]$edge.length,ancBranches=ancBranches) + cophy[[2]]$root.time#
  #	}#
#
  PBranches$tDeath<-PBranches$tBirth+cophy[[2]]$edge.length#
  PBranches$Hassoc<-cophy[[2]]$Hassoc+1#
  rootNode<-cophy[[2]]$edge[match(NA,ancBranches),1]#
#
  PBranches<-rbind(data.frame(alive=NA,nodeBirth=0,tBirth=cophy[[2]]$root.time,nodeDeath=rootNode,tDeath=cophy[[2]]$root.time+cophy[[2]]$root.edge,Hassoc=cophy[[2]]$root.Hassoc,branchNo=1),PBranches) # adding the root#
#
  if (!is.null(cophy[[2]]$nAlive))  # if the phylo object contains information about how many species are alive#
  {#
    PBranches$alive<-FALSE#
    if (cophy[[2]]$nAlive>0) PBranches$alive[PBranches$tDeath==max(PBranches$tDeath)]<-TRUE#
  }#
#
  return(list(HBranches,PBranches))#
}#
#
#' Convert cophylogenetic trees from Ape's phylo format to the internal Branches format#
#'#
#' The following function converts a phylo host-(dual) parasite tree into internal Branches format#
#' @param cophy a cophylogeny (in phylo format) containing one host and two parasite trees#
#' @export#
#' @examples#
#' Htree<-rphylo_H(tmax=5, export.format="Raw")#
#' HPQtree<-rcophylo_PQonH(H.tree=Htree, tmax=5)#
#' convert_HPQCophyloToBranches(cophy=HPQtree)#
#
convert_HPQCophyloToBranches<-function(cophy)#
{#
  # converting host tree:#
  HBranches<-data.frame(alive=rep(NA,nrow(cophy[[1]]$edge)),nodeBirth=cophy[[1]]$edge[,1],tBirth=NA,nodeDeath=cophy[[1]]$edge[,2],tDeath=NA,branchNo=2:(nrow(cophy[[1]]$edge)+1))#
  ancBranches<-match(HBranches$nodeBirth,HBranches$nodeDeath)#
#
  HBranches$tBirth<-sapply(1:length(HBranches$nodeBirth), get_tBirth, cophy[[1]]$root.edge, cophy[[1]]$edge.length, ancBranches=ancBranches)#
  HBranches$tDeath<-HBranches$tBirth+cophy[[1]]$edge.length#
  rootNode<-cophy[[1]]$edge[match(NA,ancBranches),1]#
  HBranches<-rbind(data.frame(alive=NA,nodeBirth=0,tBirth=0,nodeDeath=rootNode,tDeath=cophy[[1]]$root.edge,branchNo=1),HBranches) # adding the root#
#
  if (!is.null(cophy[[1]]$nAlive)) { # if the phylo object contains information about how many species are alive#
    HBranches$alive<-FALSE#
    if (cophy[[1]]$nAlive>0) {#
      HBranches$alive[HBranches$tDeath==max(HBranches$tDeath)]<-TRUE#
    }#
  }#
#
  # converting parasite trees:#
  P.PBranches<-data.frame(alive=rep(NA,nrow(cophy[[2]]$edge)),nodeBirth=cophy[[2]]$edge[,1],tBirth=NA,nodeDeath=cophy[[2]]$edge[,2],tDeath=NA,Hassoc=NA,branchNo=2:(nrow(cophy[[2]]$edge)+1))#
#
  P.ancBranches<-match(P.PBranches$nodeBirth,P.PBranches$nodeDeath)#
#
  P.PBranches$tBirth<-sapply(1:length(P.PBranches$nodeBirth),get_tBirth,phy=cophy[[2]],ancBranches=P.ancBranches) + cophy[[2]]$root.time#
  P.PBranches$tDeath<-P.PBranches$tBirth+cophy[[2]]$edge.length#
  P.PBranches$Hassoc<-cophy[[2]]$Hassoc+1#
  P.rootNode<-cophy[[2]]$edge[match(NA,P.ancBranches),1]#
#
  P.PBranches<-rbind(data.frame(alive=NA,nodeBirth=0,tBirth=cophy[[2]]$root.time,nodeDeath=P.rootNode,tDeath=cophy[[2]]$root.time+cophy[[2]]$root.edge,Hassoc=cophy[[2]]$root.Hassoc,branchNo=1),P.PBranches) # adding the root#
#
  if (!is.null(cophy[[2]]$nAlive)) { # if the phylo object contains information about how many species are alive#
    P.PBranches$alive<-FALSE#
    if (cophy[[2]]$nAlive>0) {#
      P.PBranches$alive[P.PBranches$tDeath==max(P.PBranches$tDeath)]<-TRUE#
    }#
  }#
#
  Q.PBranches<-data.frame(alive=rep(NA,nrow(cophy[[3]]$edge)),nodeBirth=cophy[[3]]$edge[,1],tBirth=NA,nodeDeath=cophy[[3]]$edge[,2],tDeath=NA,Hassoc=NA,branchNo=2:(nrow(cophy[[3]]$edge)+1))#
#
  Q.ancBranches<-match(Q.PBranches$nodeBirth,Q.PBranches$nodeDeath)#
#
  Q.PBranches$tBirth<-sapply(1:length(Q.PBranches$nodeBirth),get_tBirth,phy=cophy[[3]],ancBranches=Q.ancBranches) + cophy[[3]]$root.time#
  Q.PBranches$tDeath<-Q.PBranches$tBirth+cophy[[3]]$edge.length#
  Q.PBranches$Hassoc<-cophy[[3]]$Hassoc+1#
  Q.rootNode<-cophy[[3]]$edge[match(NA,Q.ancBranches),1]#
#
  Q.PBranches<-rbind(data.frame(alive=NA,nodeBirth=0,tBirth=cophy[[3]]$root.time,nodeDeath=Q.rootNode,tDeath=cophy[[3]]$root.time+cophy[[3]]$root.edge,Hassoc=cophy[[3]]$root.Hassoc,branchNo=1),Q.PBranches) # adding the root#
#
  if (!is.null(cophy[[3]]$nAlive)) { # if the phylo object contains information about how many species are alive#
    Q.PBranches$alive<-FALSE#
    if (cophy[[3]]$nAlive>0) {#
      Q.PBranches$alive[Q.PBranches$tDeath==max(Q.PBranches$tDeath)]<-TRUE#
    }#
  }#
#
  return(list(HBranches,P.PBranches,Q.PBranches))#
}
convert_HPQCophyloToBranches(cophy=HPQtree)
cophy<-HPQtree
HBranches<-data.frame(alive=rep(NA,nrow(cophy[[1]]$edge)),nodeBirth=cophy[[1]]$edge[,1],tBirth=NA,nodeDeath=cophy[[1]]$edge[,2],tDeath=NA,branchNo=2:(nrow(cophy[[1]]$edge)+1))#
  ancBranches<-match(HBranches$nodeBirth,HBranches$nodeDeath)
HBranches$tBirth<-sapply(1:length(HBranches$nodeBirth), get_tBirth, cophy[[1]]$root.edge, cophy[[1]]$edge.length, ancBranches=ancBranches)
HBranches$tDeath<-HBranches$tBirth+cophy[[1]]$edge.length
rootNode<-cophy[[1]]$edge[match(NA,ancBranches),1]
HBranches<-rbind(data.frame(alive=NA,nodeBirth=0,tBirth=0,nodeDeath=rootNode,tDeath=cophy[[1]]$root.edge,branchNo=1),HBranches) # adding the root
if (!is.null(cophy[[1]]$nAlive)) { # if the phylo object contains information about how many species are alive#
    HBranches$alive<-FALSE#
    if (cophy[[1]]$nAlive>0) {#
      HBranches$alive[HBranches$tDeath==max(HBranches$tDeath)]<-TRUE#
    }#
  }
P.PBranches<-data.frame(alive=rep(NA,nrow(cophy[[2]]$edge)),nodeBirth=cophy[[2]]$edge[,1],tBirth=NA,nodeDeath=cophy[[2]]$edge[,2],tDeath=NA,Hassoc=NA,branchNo=2:(nrow(cophy[[2]]$edge)+1))
P.ancBranches<-match(P.PBranches$nodeBirth,P.PBranches$nodeDeath)
P.PBranches$tBirth<-sapply(1:length(P.PBranches$nodeBirth),get_tBirth,phy=cophy[[2]],ancBranches=P.ancBranches) + cophy[[2]]$root.time
P.PBranches$tBirth<-sapply(1:length(P.PBranches$nodeBirth),get_tBirth,cophy[[2]]$root.edge, cophy[[2]]$edge.length,ancBranches=P.ancBranches) + cophy[[2]]$root.time
convert_HPQCophyloToBranches<-function(cophy)#
{#
  # converting host tree:#
  HBranches<-data.frame(alive=rep(NA,nrow(cophy[[1]]$edge)),nodeBirth=cophy[[1]]$edge[,1],tBirth=NA,nodeDeath=cophy[[1]]$edge[,2],tDeath=NA,branchNo=2:(nrow(cophy[[1]]$edge)+1))#
  ancBranches<-match(HBranches$nodeBirth,HBranches$nodeDeath)#
#
  HBranches$tBirth<-sapply(1:length(HBranches$nodeBirth), get_tBirth, cophy[[1]]$root.edge, cophy[[1]]$edge.length, ancBranches=ancBranches)#
  HBranches$tDeath<-HBranches$tBirth+cophy[[1]]$edge.length#
  rootNode<-cophy[[1]]$edge[match(NA,ancBranches),1]#
  HBranches<-rbind(data.frame(alive=NA,nodeBirth=0,tBirth=0,nodeDeath=rootNode,tDeath=cophy[[1]]$root.edge,branchNo=1),HBranches) # adding the root#
#
  if (!is.null(cophy[[1]]$nAlive)) { # if the phylo object contains information about how many species are alive#
    HBranches$alive<-FALSE#
    if (cophy[[1]]$nAlive>0) {#
      HBranches$alive[HBranches$tDeath==max(HBranches$tDeath)]<-TRUE#
    }#
  }#
#
  # converting parasite trees:#
  P.PBranches<-data.frame(alive=rep(NA,nrow(cophy[[2]]$edge)),nodeBirth=cophy[[2]]$edge[,1],tBirth=NA,nodeDeath=cophy[[2]]$edge[,2],tDeath=NA,Hassoc=NA,branchNo=2:(nrow(cophy[[2]]$edge)+1))#
#
  P.ancBranches<-match(P.PBranches$nodeBirth,P.PBranches$nodeDeath)#
#
  P.PBranches$tBirth<-sapply(1:length(P.PBranches$nodeBirth),get_tBirth,cophy[[2]]$root.edge, cophy[[2]]$edge.length,ancBranches=P.ancBranches) + cophy[[2]]$root.time#
  P.PBranches$tDeath<-P.PBranches$tBirth+cophy[[2]]$edge.length#
  P.PBranches$Hassoc<-cophy[[2]]$Hassoc+1#
  P.rootNode<-cophy[[2]]$edge[match(NA,P.ancBranches),1]#
#
  P.PBranches<-rbind(data.frame(alive=NA,nodeBirth=0,tBirth=cophy[[2]]$root.time,nodeDeath=P.rootNode,tDeath=cophy[[2]]$root.time+cophy[[2]]$root.edge,Hassoc=cophy[[2]]$root.Hassoc,branchNo=1),P.PBranches) # adding the root#
#
  if (!is.null(cophy[[2]]$nAlive)) { # if the phylo object contains information about how many species are alive#
    P.PBranches$alive<-FALSE#
    if (cophy[[2]]$nAlive>0) {#
      P.PBranches$alive[P.PBranches$tDeath==max(P.PBranches$tDeath)]<-TRUE#
    }#
  }#
#
  Q.PBranches<-data.frame(alive=rep(NA,nrow(cophy[[3]]$edge)),nodeBirth=cophy[[3]]$edge[,1],tBirth=NA,nodeDeath=cophy[[3]]$edge[,2],tDeath=NA,Hassoc=NA,branchNo=2:(nrow(cophy[[3]]$edge)+1))#
#
  Q.ancBranches<-match(Q.PBranches$nodeBirth,Q.PBranches$nodeDeath)#
#
  Q.PBranches$tBirth<-sapply(1:length(Q.PBranches$nodeBirth),get_tBirth,cophy[[3]]$root.edge, cophy[[3]]$edge.length,ancBranches=Q.ancBranches) + cophy[[3]]$root.time#
  Q.PBranches$tDeath<-Q.PBranches$tBirth+cophy[[3]]$edge.length#
  Q.PBranches$Hassoc<-cophy[[3]]$Hassoc+1#
  Q.rootNode<-cophy[[3]]$edge[match(NA,Q.ancBranches),1]#
#
  Q.PBranches<-rbind(data.frame(alive=NA,nodeBirth=0,tBirth=cophy[[3]]$root.time,nodeDeath=Q.rootNode,tDeath=cophy[[3]]$root.time+cophy[[3]]$root.edge,Hassoc=cophy[[3]]$root.Hassoc,branchNo=1),Q.PBranches) # adding the root#
#
  if (!is.null(cophy[[3]]$nAlive)) { # if the phylo object contains information about how many species are alive#
    Q.PBranches$alive<-FALSE#
    if (cophy[[3]]$nAlive>0) {#
      Q.PBranches$alive[Q.PBranches$tDeath==max(Q.PBranches$tDeath)]<-TRUE#
    }#
  }#
#
  return(list(HBranches,P.PBranches,Q.PBranches))#
}
Htree<-rphylo_H(tmax=5, export.format="Raw")#
 HPQtree<-rcophylo_PQonH(H.tree=Htree, tmax=5)#
 convert_HPQCophyloToBranches(cophy=HPQtree)
# Lauren #
# started from version 2018_05_5 Lauren#
# attented prac 11/5/18#
# added comments to code#
#
#tmax = number of generations #
#N0 = initial population and maximum population size #
#Nmin = minimum population size, agter bottleneck #
#s = selection coefficient against mutations (mutations are deleterious) --> can be positive as well#
#mu1 = #
#
mutation.simulator<-function(tmax=100, N0=1000, Nmin=10, s=-0.00001, mu1=1, mu2=0.01, K=2000, bint=10, mu.sd = 0.5)#
{#
	# The following creates an empty array with three dimensions: 1) generation, 2) individual, and 3) its properties (mutation rate, # mutations, fitness):#
	pops<-array(NA,dim=c(tmax+1,N0,3),dimnames=list(0:tmax,1:N0,c("mu","n.muts","fitness")))#
	# Initialising the population with no mutations and 1:1 ratio of genotypes with the two mutation rates#
	# at the start, half the population have mu1 and half mu2#
	pops[1,,]<-matrix(c(rep(c(mu1,0,1),N0/2),rep(c(mu2,0,1),N0/2)),byrow=TRUE,ncol=3,nrow=N0,dimnames=list(1:N0,c("mu","n.muts","fitness")))#
	# a vector of fitness values for different numbers of mutations#
	fitness.values<-(1+s)^(0:1000)#
	# a vector of population size in each generation#
	N<- populationsize(K=K, tmax=tmax, bint=bint, Nmin=Nmin, N0=N0)#
	#iterating through generations#
	for(i in 1:tmax) {#
		current.pop<-pops[i,,]#
		#chance of mutation for each individuation taken from poisson distribution:#
		for(j in 1:N[i]) {#
			new.muts<-rpois(1,current.pop[j,"mu"])#
			current.pop[j,"n.muts"]<-current.pop[j,"n.muts"]+new.muts#
			current.pop[j,"fitness"]<-fitness.values[current.pop[j,"n.muts"]+1]#
		}#
		#lowers popoulation if there is bottleneck, otherwise models reproduction#
		if (N[i+1]==Nmin) {#
		  #takes the previous generation population and randomly selects sample (number = Nmin)#
		  #sets all dead/potential individuals to NA#
		  current.pop[-sample(N[i],Nmin),]<-NA#
		  #stack live individuals on top of NA #
		  pops[i+1,,]<-rbind(current.pop[which(!is.na(current.pop[,1])),],current.pop[which(is.na(current.pop[,1])),])#
		} else {#
		  # reproduction (including drift):#
		  # weighted sampling, higher fitness individuals more likely to copy themselves#
		  # sampling previous gen to get current gen #
		  pops[i+1,,][1:N[i+1],]<-current.pop[sample(N[i],N[i+1],replace=TRUE,prob=current.pop[,"fitness"][which(!is.na(current.pop[,"fitness"]))]),][1:N[i+1],]#
		}#
	 pops[i+1,,"mu"] <- exp(log(pops[i+1,,"mu"])) + rnorm(N[i+1],0,mu.sd)#
	}#
	return(pops)#
}#
#
# calculates population size of current generation and adds to vector, N #
# models bottlenecks and population growth #
populationsize <- function(K, tmax, bint, Nmin, N0){#
  N=c(N0)#
  for (i in 1:tmax){#
    if (i %% bint == 0){#
      N[i+1] <- Nmin #
    } else {#
      N[i+1] <- 2*N[i]*(1-(N[i]/K))#
    }#
  }#
  return(round(N))#
}#
#
# helper function to calculate the frequency of a genotype with a certain mutation rate:#
# y axis#
mutator.freq<-function(pop,mu)#
{#
	population<-pop[,"mu"][which(!is.na(pop[,"mu"]))]#
	return(length(which(population==mu))/length(population))#
}#
#
sim.run<-mutation.simulator()#
plot(apply(sim.run,1,mutator.freq,mu=0.01),type="l",xlab="Generation",ylab="Frequency of anti-mutator")
# Lauren #
# started from version 2018_05_5 Lauren#
# attented prac 11/5/18#
# added comments to code#
# tmax #
mutation.simulator<-function(tmax=100, N0=1000, Nmin=10, s=-0.01, mu1=1, mu2=0.01, K=2000, bint=10)#
{#
	# The following creates an empty array with three dimensions: 1) generation, 2) individual, and 3) its properties (mutation rate, # mutations, fitness):#
	pops<-array(NA,dim=c(tmax+1,N0,3),dimnames=list(0:tmax,1:N0,c("mu","n.muts","fitness")))#
	# Initialising the population with no mutations and 1:1 ratio of genotypes with the two mutation rates#
	# at the start, half the population have mu1 and half mu2#
	pops[1,,]<-matrix(c(rep(c(mu1,0,1),N0/2),rep(c(mu2,0,1),N0/2)),byrow=TRUE,ncol=3,nrow=N0,dimnames=list(1:N0,c("mu","n.muts","fitness")))#
	# a vector of fitness values for different numbers of mutations#
	fitness.values<-(1+s)^(0:1000)#
	# a vector of population size in each generation#
	N<- populationsize(K=K, tmax=tmax, bint=bint, Nmin=Nmin, N0=N0)#
	#iterating through generations#
	for(i in 1:tmax) {#
		current.pop<-pops[i,,]#
		#chance of mutation for each individuation taken from poisson distribution:#
		for(j in 1:N[i]) {#
			new.muts<-rpois(1,current.pop[j,"mu"])#
			current.pop[j,"n.muts"]<-current.pop[j,"n.muts"]+new.muts#
			current.pop[j,"fitness"]<-fitness.values[current.pop[j,"n.muts"]+1]#
		}#
		#lowers popoulation if there is bottleneck, otherwise models reproduction#
		if (N[i+1]==Nmin) {#
		  #takes the previous generation population and randomly selects sample (number = Nmin)#
		  #sets all dead/potential individuals to NA#
		  current.pop[-sample(N[i],Nmin),]<-NA#
		  #stack live individuals on top of NA #
		  pops[i+1,,]<-rbind(current.pop[which(!is.na(current.pop[,1])),],current.pop[which(is.na(current.pop[,1])),])#
		} else {#
		  # reproduction (including drift):#
		  # weighted sampling, higher fitness individuals more likely to copy themselves#
		  # sampling previous gen to get current gen #
		  pops[i+1,,][1:N[i+1],]<-current.pop[sample(N[i],N[i+1],replace=TRUE,prob=current.pop[,"fitness"][which(!is.na(current.pop[,"fitness"]))]),][1:N[i+1],]#
		}#
	}#
	return(pops)#
}#
# calculates population size of current generation and adds to vector, N #
# models bottlenecks and population growth #
populationsize <- function(K, tmax, bint, Nmin, N0){#
  N=c(N0)#
  for (i in 1:tmax){#
    if (i %% bint == 0){#
      N[i+1] <- Nmin #
    } else {#
      N[i+1] <- 2*N[i]*(1-(N[i]/K))#
    }#
  }#
  return(round(N))#
}#
# helper function to calculate the frequency of a genotype with a certain mutation rate:#
# y axis#
mutator.freq<-function(pop,mu)#
{#
	population<-pop[,"mu"][which(!is.na(pop[,"mu"]))]#
	return(length(which(population==mu))/length(population))#
}#
sim.run<-mutation.simulator(tmax=100, N0=1000, Nmin=10, s=-0.01, mu1=1, mu2=0.01, K=2000, bint=10)#
plot(apply(sim.run,1,mutator.freq,mu=0.01),type="l",xlab="Generation",ylab="Frequency of anti-mutator")
# Lauren #
# started from version 2018_05_5 Lauren#
# attented prac 11/5/18#
# added comments to code#
#
#tmax = number of generations #
#N0 = initial population and maximum population size #
#Nmin = minimum population size, agter bottleneck #
#s = selection coefficient against mutations (mutations are deleterious) --> can be positive as well#
#mu1 = #
#
mutation.simulator<-function(tmax=100, N0=1000, Nmin=10, s=-0.00001, mu1=1, mu2=0.01, K=2000, bint=10, mu.sd = 0.5)#
{#
	# The following creates an empty array with three dimensions: 1) generation, 2) individual, and 3) its properties (mutation rate, # mutations, fitness):#
	pops<-array(NA,dim=c(tmax+1,N0,3),dimnames=list(0:tmax,1:N0,c("mu","n.muts","fitness")))#
	# Initialising the population with no mutations and 1:1 ratio of genotypes with the two mutation rates#
	# at the start, half the population have mu1 and half mu2#
	pops[1,,]<-matrix(c(rep(c(mu1,0,1),N0/2),rep(c(mu2,0,1),N0/2)),byrow=TRUE,ncol=3,nrow=N0,dimnames=list(1:N0,c("mu","n.muts","fitness")))#
	# a vector of fitness values for different numbers of mutations#
	fitness.values<-(1+s)^(0:1000)#
	# a vector of population size in each generation#
	N<- populationsize(K=K, tmax=tmax, bint=bint, Nmin=Nmin, N0=N0)#
	#iterating through generations#
	for(i in 1:tmax) {#
		current.pop<-pops[i,,]#
		#chance of mutation for each individuation taken from poisson distribution:#
		for(j in 1:N[i]) {#
			new.muts<-rpois(1,current.pop[j,"mu"])#
			current.pop[j,"n.muts"]<-current.pop[j,"n.muts"]+new.muts#
			current.pop[j,"fitness"]<-fitness.values[current.pop[j,"n.muts"]+1]#
		}#
		#lowers popoulation if there is bottleneck, otherwise models reproduction#
		if (N[i+1]==Nmin) {#
		  #takes the previous generation population and randomly selects sample (number = Nmin)#
		  #sets all dead/potential individuals to NA#
		  current.pop[-sample(N[i],Nmin),]<-NA#
		  #stack live individuals on top of NA #
		  pops[i+1,,]<-rbind(current.pop[which(!is.na(current.pop[,1])),],current.pop[which(is.na(current.pop[,1])),])#
		} else {#
		  # reproduction (including drift):#
		  # weighted sampling, higher fitness individuals more likely to copy themselves#
		  # sampling previous gen to get current gen #
		  pops[i+1,,][1:N[i+1],]<-current.pop[sample(N[i],N[i+1],replace=TRUE,prob=current.pop[,"fitness"][which(!is.na(current.pop[,"fitness"]))]),][1:N[i+1],]#
		}#
	 pops[i+1,,"mu"] <- exp(log(pops[i+1,,"mu"])) + rnorm(N[i+1],0,mu.sd)#
	}#
	return(pops)#
}#
#
# calculates population size of current generation and adds to vector, N #
# models bottlenecks and population growth #
populationsize <- function(K, tmax, bint, Nmin, N0){#
  N=c(N0)#
  for (i in 1:tmax){#
    if (i %% bint == 0){#
      N[i+1] <- Nmin #
    } else {#
      N[i+1] <- 2*N[i]*(1-(N[i]/K))#
    }#
  }#
  return(round(N))#
}#
#
# helper function to calculate the frequency of a genotype with a certain mutation rate:#
# y axis#
mutator.freq<-function(pop,mu)#
{#
	population<-pop[,"mu"][which(!is.na(pop[,"mu"]))]#
	return(length(which(population==mu))/length(population))#
}#
#
sim.run<-mutation.simulator()#
plot(apply(sim.run,1,mutator.freq,mu=0.01),type="l",xlab="Generation",ylab="Frequency of anti-mutator")
# Lauren #
# started from version 2018_05_5 Lauren#
# attented prac 11/5/18#
# added comments to code#
#
#tmax = number of generations #
#N0 = initial population and maximum population size #
#Nmin = minimum population size, agter bottleneck #
#s = selection coefficient against mutations (mutations are deleterious) --> can be positive as well#
#mu1 = #
#
mutation.simulator<-function(tmax=100, N0=1000, Nmin=10, s=-0.00001, mu1=1, mu2=0.01, K=2000, bint=10, mu.sd = 0.5)#
{#
	# The following creates an empty array with three dimensions: 1) generation, 2) individual, and 3) its properties (mutation rate, # mutations, fitness):#
	pops<-array(NA,dim=c(tmax+1,N0,3),dimnames=list(0:tmax,1:N0,c("mu","n.muts","fitness")))#
	# Initialising the population with no mutations and 1:1 ratio of genotypes with the two mutation rates#
	# at the start, half the population have mu1 and half mu2#
	pops[1,,]<-matrix(c(rep(c(mu1,0,1),N0/2),rep(c(mu2,0,1),N0/2)),byrow=TRUE,ncol=3,nrow=N0,dimnames=list(1:N0,c("mu","n.muts","fitness")))#
	# a vector of fitness values for different numbers of mutations#
	fitness.values<-(1+s)^(0:1000)#
	# a vector of population size in each generation#
	N<- populationsize(K=K, tmax=tmax, bint=bint, Nmin=Nmin, N0=N0)#
	#iterating through generations#
	for(i in 1:tmax) {#
		current.pop<-pops[i,,]#
		#chance of mutation for each individuation taken from poisson distribution:#
		for(j in 1:N[i]) {#
			new.muts<-rpois(1,current.pop[j,"mu"])#
			current.pop[j,"n.muts"]<-current.pop[j,"n.muts"]+new.muts#
			current.pop[j,"fitness"]<-fitness.values[current.pop[j,"n.muts"]+1]#
		}#
		#lowers popoulation if there is bottleneck, otherwise models reproduction#
		if (N[i+1]==Nmin) {#
		  #takes the previous generation population and randomly selects sample (number = Nmin)#
		  #sets all dead/potential individuals to NA#
		  current.pop[-sample(N[i],Nmin),]<-NA#
		  #stack live individuals on top of NA #
		  pops[i+1,,]<-rbind(current.pop[which(!is.na(current.pop[,1])),],current.pop[which(is.na(current.pop[,1])),])#
		} else {#
		  # reproduction (including drift):#
		  # weighted sampling, higher fitness individuals more likely to copy themselves#
		  # sampling previous gen to get current gen #
		  pops[i+1,,][1:N[i+1],]<-current.pop[sample(N[i],N[i+1],replace=TRUE,prob=current.pop[,"fitness"][which(!is.na(current.pop[,"fitness"]))]),][1:N[i+1],]#
		}#
	 #pops[i+1,,"mu"] <- exp(log(pops[i+1,,"mu"])) + rnorm(N[i+1],0,mu.sd)#
	}#
	return(pops)#
}#
#
# calculates population size of current generation and adds to vector, N #
# models bottlenecks and population growth #
populationsize <- function(K, tmax, bint, Nmin, N0){#
  N=c(N0)#
  for (i in 1:tmax){#
    if (i %% bint == 0){#
      N[i+1] <- Nmin #
    } else {#
      N[i+1] <- 2*N[i]*(1-(N[i]/K))#
    }#
  }#
  return(round(N))#
}#
#
# helper function to calculate the frequency of a genotype with a certain mutation rate:#
# y axis#
mutator.freq<-function(pop,mu)#
{#
	population<-pop[,"mu"][which(!is.na(pop[,"mu"]))]#
	return(length(which(population==mu))/length(population))#
}#
#
sim.run<-mutation.simulator()#
plot(apply(sim.run,1,mutator.freq,mu=0.01),type="l",xlab="Generation",ylab="Frequency of anti-mutator")
?rnorm
# Lauren #
# started from version 2018_05_5 Lauren#
# attented prac 11/5/18#
# added comments to code#
#
#tmax = number of generations #
#N0 = initial population and maximum population size #
#Nmin = minimum population size, agter bottleneck #
#s = selection coefficient against mutations (mutations are deleterious) --> can be positive as well#
#mu1 = #
#
mutation.simulator<-function(tmax=100, N0=1000, Nmin=10, s=-0.00001, mu1=1, mu2=0.01, K=2000, bint=10, mu.sd = 0.5)#
{#
	# The following creates an empty array with three dimensions: 1) generation, 2) individual, and 3) its properties (mutation rate, # mutations, fitness):#
	pops<-array(NA,dim=c(tmax+1,N0,3),dimnames=list(0:tmax,1:N0,c("mu","n.muts","fitness")))#
	# Initialising the population with no mutations and 1:1 ratio of genotypes with the two mutation rates#
	# at the start, half the population have mu1 and half mu2#
	pops[1,,]<-matrix(c(rep(c(mu1,0,1),N0/2),rep(c(mu2,0,1),N0/2)),byrow=TRUE,ncol=3,nrow=N0,dimnames=list(1:N0,c("mu","n.muts","fitness")))#
	# a vector of fitness values for different numbers of mutations#
	fitness.values<-(1+s)^(0:1000)#
	# a vector of population size in each generation#
	N<- populationsize(K=K, tmax=tmax, bint=bint, Nmin=Nmin, N0=N0)#
	#iterating through generations#
	for(i in 1:tmax) {#
		current.pop<-pops[i,,]#
		#chance of mutation for each individuation taken from poisson distribution:#
		for(j in 1:N[i]) {#
			new.muts<-rpois(1,current.pop[j,"mu"])#
			current.pop[j,"n.muts"]<-current.pop[j,"n.muts"]+new.muts#
			current.pop[j,"fitness"]<-fitness.values[current.pop[j,"n.muts"]+1]#
		}#
		#lowers popoulation if there is bottleneck, otherwise models reproduction#
		if (N[i+1]==Nmin) {#
		  #takes the previous generation population and randomly selects sample (number = Nmin)#
		  #sets all dead/potential individuals to NA#
		  current.pop[-sample(N[i],Nmin),]<-NA#
		  #stack live individuals on top of NA #
		  pops[i+1,,]<-rbind(current.pop[which(!is.na(current.pop[,1])),],current.pop[which(is.na(current.pop[,1])),])#
		} else {#
		  # reproduction (including drift):#
		  # weighted sampling, higher fitness individuals more likely to copy themselves#
		  # sampling previous gen to get current gen #
		  pops[i+1,,][1:N[i+1],]<-current.pop[sample(N[i],N[i+1],replace=TRUE,prob=current.pop[,"fitness"][which(!is.na(current.pop[,"fitness"]))]),][1:N[i+1],]#
		}#
		print(exp(log(pops[i+1,,"mu"])))#
		print(rnorm(N[i+1],0,mu.sd))#
	 #pops[i+1,,"mu"] <- exp(log(pops[i+1,,"mu"])) + rnorm(N[i+1],0,mu.sd)#
	}#
	return(pops)#
}#
#
# calculates population size of current generation and adds to vector, N #
# models bottlenecks and population growth #
populationsize <- function(K, tmax, bint, Nmin, N0){#
  N=c(N0)#
  for (i in 1:tmax){#
    if (i %% bint == 0){#
      N[i+1] <- Nmin #
    } else {#
      N[i+1] <- 2*N[i]*(1-(N[i]/K))#
    }#
  }#
  return(round(N))#
}#
#
# helper function to calculate the frequency of a genotype with a certain mutation rate:#
# y axis#
mutator.freq<-function(pop,mu)#
{#
	population<-pop[,"mu"][which(!is.na(pop[,"mu"]))]#
	return(length(which(population==mu))/length(population))#
}#
#
sim.run<-mutation.simulator()#
plot(apply(sim.run,1,mutator.freq,mu=0.01),type="l",xlab="Generation",ylab="Frequency of anti-mutator")
print(rnorm(N[i+1],0,mu.sd))
# Lauren #
# started from version 2018_05_5 Lauren#
# attented prac 11/5/18#
# added comments to code#
#
#tmax = number of generations #
#N0 = initial population and maximum population size #
#Nmin = minimum population size, agter bottleneck #
#s = selection coefficient against mutations (mutations are deleterious) --> can be positive as well#
#mu1 = #
#
mutation.simulator<-function(tmax=100, N0=1000, Nmin=10, s=-0.00001, mu1=1, mu2=0.01, K=2000, bint=10, mu.sd = 0.5)#
{#
	# The following creates an empty array with three dimensions: 1) generation, 2) individual, and 3) its properties (mutation rate, # mutations, fitness):#
	pops<-array(NA,dim=c(tmax+1,N0,3),dimnames=list(0:tmax,1:N0,c("mu","n.muts","fitness")))#
	# Initialising the population with no mutations and 1:1 ratio of genotypes with the two mutation rates#
	# at the start, half the population have mu1 and half mu2#
	pops[1,,]<-matrix(c(rep(c(mu1,0,1),N0/2),rep(c(mu2,0,1),N0/2)),byrow=TRUE,ncol=3,nrow=N0,dimnames=list(1:N0,c("mu","n.muts","fitness")))#
	# a vector of fitness values for different numbers of mutations#
	fitness.values<-(1+s)^(0:1000)#
	# a vector of population size in each generation#
	N<- populationsize(K=K, tmax=tmax, bint=bint, Nmin=Nmin, N0=N0)#
	#iterating through generations#
	for(i in 1:tmax) {#
		current.pop<-pops[i,,]#
		#chance of mutation for each individuation taken from poisson distribution:#
		for(j in 1:N[i]) {#
			new.muts<-rpois(1,current.pop[j,"mu"])#
			current.pop[j,"n.muts"]<-current.pop[j,"n.muts"]+new.muts#
			current.pop[j,"fitness"]<-fitness.values[current.pop[j,"n.muts"]+1]#
		}#
		#lowers popoulation if there is bottleneck, otherwise models reproduction#
		if (N[i+1]==Nmin) {#
		  #takes the previous generation population and randomly selects sample (number = Nmin)#
		  #sets all dead/potential individuals to NA#
		  current.pop[-sample(N[i],Nmin),]<-NA#
		  #stack live individuals on top of NA #
		  pops[i+1,,]<-rbind(current.pop[which(!is.na(current.pop[,1])),],current.pop[which(is.na(current.pop[,1])),])#
		} else {#
		  # reproduction (including drift):#
		  # weighted sampling, higher fitness individuals more likely to copy themselves#
		  # sampling previous gen to get current gen #
		  pops[i+1,,][1:N[i+1],]<-current.pop[sample(N[i],N[i+1],replace=TRUE,prob=current.pop[,"fitness"][which(!is.na(current.pop[,"fitness"]))]),][1:N[i+1],]#
		}#
		print(exp(log(pops[i+1,,"mu"])))#
		print(rnorm(N[i+1],0,mu.sd))#
	 #pops[i+1,,"mu"] <- exp(log(pops[i+1,,"mu"])) + rnorm(N[i+1],0,mu.sd)#
	}#
	return(pops)#
}#
#
# calculates population size of current generation and adds to vector, N #
# models bottlenecks and population growth #
populationsize <- function(K, tmax, bint, Nmin, N0){#
  N=c(N0)#
  for (i in 1:tmax){#
    if (i %% bint == 0){#
      N[i+1] <- Nmin #
    } else {#
      N[i+1] <- 2*N[i]*(1-(N[i]/K))#
    }#
  }#
  return(round(N))#
}#
#
# helper function to calculate the frequency of a genotype with a certain mutation rate:#
# y axis#
mutator.freq<-function(pop,mu)#
{#
	population<-pop[,"mu"][which(!is.na(pop[,"mu"]))]#
	return(length(which(population==mu))/length(population))#
}#
#
sim.run<-mutation.simulator()#
plot(apply(sim.run,1,mutator.freq,mu=0.01),type="l",xlab="Generation",ylab="Frequency of anti-mutator")
# Lauren #
# started from version 2018_05_5 Lauren#
# attented prac 11/5/18#
# added comments to code#
#
#tmax = number of generations #
#N0 = initial population and maximum population size #
#Nmin = minimum population size, agter bottleneck #
#s = selection coefficient against mutations (mutations are deleterious) --> can be positive as well#
#mu1 = #
#
mutation.simulator<-function(tmax=100, N0=1000, Nmin=10, s=-0.00001, mu1=1, mu2=0.01, K=2000, bint=10, mu.sd = 0.5)#
{#
	# The following creates an empty array with three dimensions: 1) generation, 2) individual, and 3) its properties (mutation rate, # mutations, fitness):#
	pops<-array(NA,dim=c(tmax+1,N0,3),dimnames=list(0:tmax,1:N0,c("mu","n.muts","fitness")))#
	# Initialising the population with no mutations and 1:1 ratio of genotypes with the two mutation rates#
	# at the start, half the population have mu1 and half mu2#
	pops[1,,]<-matrix(c(rep(c(mu1,0,1),N0/2),rep(c(mu2,0,1),N0/2)),byrow=TRUE,ncol=3,nrow=N0,dimnames=list(1:N0,c("mu","n.muts","fitness")))#
	# a vector of fitness values for different numbers of mutations#
	fitness.values<-(1+s)^(0:1000)#
	# a vector of population size in each generation#
	N<- populationsize(K=K, tmax=tmax, bint=bint, Nmin=Nmin, N0=N0)#
	#iterating through generations#
	for(i in 1:tmax) {#
		current.pop<-pops[i,,]#
		#chance of mutation for each individuation taken from poisson distribution:#
		for(j in 1:N[i]) {#
			new.muts<-rpois(1,current.pop[j,"mu"])#
			current.pop[j,"n.muts"]<-current.pop[j,"n.muts"]+new.muts#
			current.pop[j,"fitness"]<-fitness.values[current.pop[j,"n.muts"]+1]#
		}#
		#lowers popoulation if there is bottleneck, otherwise models reproduction#
		if (N[i+1]==Nmin) {#
		  #takes the previous generation population and randomly selects sample (number = Nmin)#
		  #sets all dead/potential individuals to NA#
		  current.pop[-sample(N[i],Nmin),]<-NA#
		  #stack live individuals on top of NA #
		  pops[i+1,,]<-rbind(current.pop[which(!is.na(current.pop[,1])),],current.pop[which(is.na(current.pop[,1])),])#
		} else {#
		  # reproduction (including drift):#
		  # weighted sampling, higher fitness individuals more likely to copy themselves#
		  # sampling previous gen to get current gen #
		  pops[i+1,,][1:N[i+1],]<-current.pop[sample(N[i],N[i+1],replace=TRUE,prob=current.pop[,"fitness"][which(!is.na(current.pop[,"fitness"]))]),][1:N[i+1],]#
		}#
		print(exp(log(pops[i+1,,"mu"])) + rnorm(N[i+1],0,mu.sd)#
)#
#
	 #pops[i+1,,"mu"] <- exp(log(pops[i+1,,"mu"])) + rnorm(N[i+1],0,mu.sd)#
	}#
	return(pops)#
}#
#
# calculates population size of current generation and adds to vector, N #
# models bottlenecks and population growth #
populationsize <- function(K, tmax, bint, Nmin, N0){#
  N=c(N0)#
  for (i in 1:tmax){#
    if (i %% bint == 0){#
      N[i+1] <- Nmin #
    } else {#
      N[i+1] <- 2*N[i]*(1-(N[i]/K))#
    }#
  }#
  return(round(N))#
}#
#
# helper function to calculate the frequency of a genotype with a certain mutation rate:#
# y axis#
mutator.freq<-function(pop,mu)#
{#
	population<-pop[,"mu"][which(!is.na(pop[,"mu"]))]#
	return(length(which(population==mu))/length(population))#
}#
#
sim.run<-mutation.simulator()#
plot(apply(sim.run,1,mutator.freq,mu=0.01),type="l",xlab="Generation",ylab="Frequency of anti-mutator")
# Lauren #
# started from version 2018_05_5 Lauren#
# attented prac 11/5/18#
# added comments to code#
#
#tmax = number of generations #
#N0 = initial population and maximum population size #
#Nmin = minimum population size, agter bottleneck #
#s = selection coefficient against mutations (mutations are deleterious) --> can be positive as well#
#mu1 = #
#
mutation.simulator<-function(tmax=100, N0=1000, Nmin=10, s=-0.00001, mu1=1, mu2=0.01, K=2000, bint=10, mu.sd = 0.5)#
{#
	# The following creates an empty array with three dimensions: 1) generation, 2) individual, and 3) its properties (mutation rate, # mutations, fitness):#
	pops<-array(NA,dim=c(tmax+1,N0,3),dimnames=list(0:tmax,1:N0,c("mu","n.muts","fitness")))#
	# Initialising the population with no mutations and 1:1 ratio of genotypes with the two mutation rates#
	# at the start, half the population have mu1 and half mu2#
	pops[1,,]<-matrix(c(rep(c(mu1,0,1),N0/2),rep(c(mu2,0,1),N0/2)),byrow=TRUE,ncol=3,nrow=N0,dimnames=list(1:N0,c("mu","n.muts","fitness")))#
	# a vector of fitness values for different numbers of mutations#
	fitness.values<-(1+s)^(0:1000)#
	# a vector of population size in each generation#
	N<- populationsize(K=K, tmax=tmax, bint=bint, Nmin=Nmin, N0=N0)#
	#iterating through generations#
	for(i in 1:tmax) {#
		current.pop<-pops[i,,]#
		#chance of mutation for each individuation taken from poisson distribution:#
		for(j in 1:N[i]) {#
			new.muts<-rpois(1,current.pop[j,"mu"])#
			current.pop[j,"n.muts"]<-current.pop[j,"n.muts"]+new.muts#
			current.pop[j,"fitness"]<-fitness.values[current.pop[j,"n.muts"]+1]#
		}#
		#lowers popoulation if there is bottleneck, otherwise models reproduction#
		if (N[i+1]==Nmin) {#
		  #takes the previous generation population and randomly selects sample (number = Nmin)#
		  #sets all dead/potential individuals to NA#
		  current.pop[-sample(N[i],Nmin),]<-NA#
		  #stack live individuals on top of NA #
		  pops[i+1,,]<-rbind(current.pop[which(!is.na(current.pop[,1])),],current.pop[which(is.na(current.pop[,1])),])#
		} else {#
		  # reproduction (including drift):#
		  # weighted sampling, higher fitness individuals more likely to copy themselves#
		  # sampling previous gen to get current gen #
		  pops[i+1,,][1:N[i+1],]<-current.pop[sample(N[i],N[i+1],replace=TRUE,prob=current.pop[,"fitness"][which(!is.na(current.pop[,"fitness"]))]),][1:N[i+1],]#
		}#
		#print(exp(log(pops[i+1,,"mu"])) + rnorm(N[i+1],0,mu.sd)#
)#
	print(rnorm(N[i+1],0,mu.sd))#
#
	 #pops[i+1,,"mu"] <- exp(log(pops[i+1,,"mu"])) + rnorm(N[i+1],0,mu.sd)#
	}#
	return(pops)#
}#
#
# calculates population size of current generation and adds to vector, N #
# models bottlenecks and population growth #
populationsize <- function(K, tmax, bint, Nmin, N0){#
  N=c(N0)#
  for (i in 1:tmax){#
    if (i %% bint == 0){#
      N[i+1] <- Nmin #
    } else {#
      N[i+1] <- 2*N[i]*(1-(N[i]/K))#
    }#
  }#
  return(round(N))#
}#
#
# helper function to calculate the frequency of a genotype with a certain mutation rate:#
# y axis#
mutator.freq<-function(pop,mu)#
{#
	population<-pop[,"mu"][which(!is.na(pop[,"mu"]))]#
	return(length(which(population==mu))/length(population))#
}#
#
sim.run<-mutation.simulator()#
plot(apply(sim.run,1,mutator.freq,mu=0.01),type="l",xlab="Generation",ylab="Frequency of anti-mutator")
# Lauren #
# started from version 2018_05_5 Lauren#
# attented prac 11/5/18#
# added comments to code#
#
#tmax = number of generations #
#N0 = initial population and maximum population size #
#Nmin = minimum population size, agter bottleneck #
#s = selection coefficient against mutations (mutations are deleterious) --> can be positive as well#
#mu1 = #
#
mutation.simulator<-function(tmax=100, N0=1000, Nmin=10, s=-0.00001, mu1=1, mu2=0.01, K=2000, bint=10, mu.sd = 0.5)#
{#
	# The following creates an empty array with three dimensions: 1) generation, 2) individual, and 3) its properties (mutation rate, # mutations, fitness):#
	pops<-array(NA,dim=c(tmax+1,N0,3),dimnames=list(0:tmax,1:N0,c("mu","n.muts","fitness")))#
	# Initialising the population with no mutations and 1:1 ratio of genotypes with the two mutation rates#
	# at the start, half the population have mu1 and half mu2#
	pops[1,,]<-matrix(c(rep(c(mu1,0,1),N0/2),rep(c(mu2,0,1),N0/2)),byrow=TRUE,ncol=3,nrow=N0,dimnames=list(1:N0,c("mu","n.muts","fitness")))#
	# a vector of fitness values for different numbers of mutations#
	fitness.values<-(1+s)^(0:1000)#
	# a vector of population size in each generation#
	N<- populationsize(K=K, tmax=tmax, bint=bint, Nmin=Nmin, N0=N0)#
	#iterating through generations#
	for(i in 1:tmax) {#
		current.pop<-pops[i,,]#
		#chance of mutation for each individuation taken from poisson distribution:#
		for(j in 1:N[i]) {#
			new.muts<-rpois(1,current.pop[j,"mu"])#
			current.pop[j,"n.muts"]<-current.pop[j,"n.muts"]+new.muts#
			current.pop[j,"fitness"]<-fitness.values[current.pop[j,"n.muts"]+1]#
		}#
		#lowers popoulation if there is bottleneck, otherwise models reproduction#
		if (N[i+1]==Nmin) {#
		  #takes the previous generation population and randomly selects sample (number = Nmin)#
		  #sets all dead/potential individuals to NA#
		  current.pop[-sample(N[i],Nmin),]<-NA#
		  #stack live individuals on top of NA #
		  pops[i+1,,]<-rbind(current.pop[which(!is.na(current.pop[,1])),],current.pop[which(is.na(current.pop[,1])),])#
		} else {#
		  # reproduction (including drift):#
		  # weighted sampling, higher fitness individuals more likely to copy themselves#
		  # sampling previous gen to get current gen #
		  pops[i+1,,][1:N[i+1],]<-current.pop[sample(N[i],N[i+1],replace=TRUE,prob=current.pop[,"fitness"][which(!is.na(current.pop[,"fitness"]))]),][1:N[i+1],]#
		}#
		print(exp(log(pops[i+1,,"mu"])) + rnorm(N[i+1],0,mu.sd))#
	print(rnorm(N[i+1],0,mu.sd))#
	 #pops[i+1,,"mu"] <- exp(log(pops[i+1,,"mu"])) + rnorm(N[i+1],0,mu.sd)#
	}#
	return(pops)#
}#
#
# calculates population size of current generation and adds to vector, N #
# models bottlenecks and population growth #
populationsize <- function(K, tmax, bint, Nmin, N0){#
  N=c(N0)#
  for (i in 1:tmax){#
    if (i %% bint == 0){#
      N[i+1] <- Nmin #
    } else {#
      N[i+1] <- 2*N[i]*(1-(N[i]/K))#
    }#
  }#
  return(round(N))#
}#
#
# helper function to calculate the frequency of a genotype with a certain mutation rate:#
# y axis#
mutator.freq<-function(pop,mu)#
{#
	population<-pop[,"mu"][which(!is.na(pop[,"mu"]))]#
	return(length(which(population==mu))/length(population))#
}#
#
sim.run<-mutation.simulator()#
plot(apply(sim.run,1,mutator.freq,mu=0.01),type="l",xlab="Generation",ylab="Frequency of anti-mutator")
# Lauren #
# started from version 2018_05_5 Lauren#
# attented prac 11/5/18#
# added comments to code#
#
#tmax = number of generations #
#N0 = initial population and maximum population size #
#Nmin = minimum population size, agter bottleneck #
#s = selection coefficient against mutations (mutations are deleterious) --> can be positive as well#
#mu1 = #
#
mutation.simulator<-function(tmax=100, N0=1000, Nmin=10, s=-0.00001, mu1=1, mu2=0.01, K=2000, bint=10, mu.sd = 0.5)#
{#
	# The following creates an empty array with three dimensions: 1) generation, 2) individual, and 3) its properties (mutation rate, # mutations, fitness):#
	pops<-array(NA,dim=c(tmax+1,N0,3),dimnames=list(0:tmax,1:N0,c("mu","n.muts","fitness")))#
	# Initialising the population with no mutations and 1:1 ratio of genotypes with the two mutation rates#
	# at the start, half the population have mu1 and half mu2#
	pops[1,,]<-matrix(c(rep(c(mu1,0,1),N0/2),rep(c(mu2,0,1),N0/2)),byrow=TRUE,ncol=3,nrow=N0,dimnames=list(1:N0,c("mu","n.muts","fitness")))#
	# a vector of fitness values for different numbers of mutations#
	fitness.values<-(1+s)^(0:1000)#
	# a vector of population size in each generation#
	N<- populationsize(K=K, tmax=tmax, bint=bint, Nmin=Nmin, N0=N0)#
	#iterating through generations#
	for(i in 1:tmax) {#
		current.pop<-pops[i,,]#
		#chance of mutation for each individuation taken from poisson distribution:#
		for(j in 1:N[i]) {#
			new.muts<-rpois(1,current.pop[j,"mu"])#
			current.pop[j,"n.muts"]<-current.pop[j,"n.muts"]+new.muts#
			current.pop[j,"fitness"]<-fitness.values[current.pop[j,"n.muts"]+1]#
		}#
		#lowers popoulation if there is bottleneck, otherwise models reproduction#
		if (N[i+1]==Nmin) {#
		  #takes the previous generation population and randomly selects sample (number = Nmin)#
		  #sets all dead/potential individuals to NA#
		  current.pop[-sample(N[i],Nmin),]<-NA#
		  #stack live individuals on top of NA #
		  pops[i+1,,]<-rbind(current.pop[which(!is.na(current.pop[,1])),],current.pop[which(is.na(current.pop[,1])),])#
		} else {#
		  # reproduction (including drift):#
		  # weighted sampling, higher fitness individuals more likely to copy themselves#
		  # sampling previous gen to get current gen #
		  pops[i+1,,][1:N[i+1],]<-current.pop[sample(N[i],N[i+1],replace=TRUE,prob=current.pop[,"fitness"][which(!is.na(current.pop[,"fitness"]))]),][1:N[i+1],]#
		}#
		#print(exp(log(pops[i+1,,"mu"])) + rnorm(N[i+1],0,mu.sd))#
	print(rnorm(N[i+1],0,mu.sd))#
	 #pops[i+1,,"mu"] <- exp(log(pops[i+1,,"mu"])) + rnorm(N[i+1],0,mu.sd)#
	}#
	return(pops)#
}#
#
# calculates population size of current generation and adds to vector, N #
# models bottlenecks and population growth #
populationsize <- function(K, tmax, bint, Nmin, N0){#
  N=c(N0)#
  for (i in 1:tmax){#
    if (i %% bint == 0){#
      N[i+1] <- Nmin #
    } else {#
      N[i+1] <- 2*N[i]*(1-(N[i]/K))#
    }#
  }#
  return(round(N))#
}#
#
# helper function to calculate the frequency of a genotype with a certain mutation rate:#
# y axis#
mutator.freq<-function(pop,mu)#
{#
	population<-pop[,"mu"][which(!is.na(pop[,"mu"]))]#
	return(length(which(population==mu))/length(population))#
}#
#
sim.run<-mutation.simulator()#
plot(apply(sim.run,1,mutator.freq,mu=0.01),type="l",xlab="Generation",ylab="Frequency of anti-mutator")
# Lauren #
# started from version 2018_05_5 Lauren#
# attented prac 11/5/18#
# added comments to code#
#
#tmax = number of generations #
#N0 = initial population and maximum population size #
#Nmin = minimum population size, agter bottleneck #
#s = selection coefficient against mutations (mutations are deleterious) --> can be positive as well#
#mu1 = #
#
mutation.simulator<-function(tmax=100, N0=1000, Nmin=10, s=-0.00001, mu1=1, mu2=0.01, K=2000, bint=10, mu.sd = 0.5)#
{#
	# The following creates an empty array with three dimensions: 1) generation, 2) individual, and 3) its properties (mutation rate, # mutations, fitness):#
	pops<-array(NA,dim=c(tmax+1,N0,3),dimnames=list(0:tmax,1:N0,c("mu","n.muts","fitness")))#
	# Initialising the population with no mutations and 1:1 ratio of genotypes with the two mutation rates#
	# at the start, half the population have mu1 and half mu2#
	pops[1,,]<-matrix(c(rep(c(mu1,0,1),N0/2),rep(c(mu2,0,1),N0/2)),byrow=TRUE,ncol=3,nrow=N0,dimnames=list(1:N0,c("mu","n.muts","fitness")))#
	# a vector of fitness values for different numbers of mutations#
	fitness.values<-(1+s)^(0:1000)#
	# a vector of population size in each generation#
	N<- populationsize(K=K, tmax=tmax, bint=bint, Nmin=Nmin, N0=N0)#
	#iterating through generations#
	for(i in 1:tmax) {#
		current.pop<-pops[i,,]#
		#chance of mutation for each individuation taken from poisson distribution:#
		for(j in 1:N[i]) {#
			new.muts<-rpois(1,current.pop[j,"mu"])#
			current.pop[j,"n.muts"]<-current.pop[j,"n.muts"]+new.muts#
			current.pop[j,"fitness"]<-fitness.values[current.pop[j,"n.muts"]+1]#
		}#
		#lowers popoulation if there is bottleneck, otherwise models reproduction#
		if (N[i+1]==Nmin) {#
		  #takes the previous generation population and randomly selects sample (number = Nmin)#
		  #sets all dead/potential individuals to NA#
		  current.pop[-sample(N[i],Nmin),]<-NA#
		  #stack live individuals on top of NA #
		  pops[i+1,,]<-rbind(current.pop[which(!is.na(current.pop[,1])),],current.pop[which(is.na(current.pop[,1])),])#
		} else {#
		  # reproduction (including drift):#
		  # weighted sampling, higher fitness individuals more likely to copy themselves#
		  # sampling previous gen to get current gen #
		  pops[i+1,,][1:N[i+1],]<-current.pop[sample(N[i],N[i+1],replace=TRUE,prob=current.pop[,"fitness"][which(!is.na(current.pop[,"fitness"]))]),][1:N[i+1],]#
		}#
		#print(exp(log(pops[i+1,,"mu"])) + rnorm(N[i+1],0,mu.sd))#
	#print(rnorm(N[i+1],0,mu.sd))#
	 pops[i+1,,"mu"][1:N[i+1]] <- exp(log(pops[i+1,,"mu"])) + rnorm(N[i+1],0,mu.sd)#
	}#
	return(pops)#
}#
#
# calculates population size of current generation and adds to vector, N #
# models bottlenecks and population growth #
populationsize <- function(K, tmax, bint, Nmin, N0){#
  N=c(N0)#
  for (i in 1:tmax){#
    if (i %% bint == 0){#
      N[i+1] <- Nmin #
    } else {#
      N[i+1] <- 2*N[i]*(1-(N[i]/K))#
    }#
  }#
  return(round(N))#
}#
#
# helper function to calculate the frequency of a genotype with a certain mutation rate:#
# y axis#
mutator.freq<-function(pop,mu)#
{#
	population<-pop[,"mu"][which(!is.na(pop[,"mu"]))]#
	return(length(which(population==mu))/length(population))#
}#
#
sim.run<-mutation.simulator()#
plot(apply(sim.run,1,mutator.freq,mu=0.01),type="l",xlab="Generation",ylab="Frequency of anti-mutator")
# Lauren #
# started from version 2018_05_5 Lauren#
# attented prac 11/5/18#
# added comments to code#
#
#tmax = number of generations #
#N0 = initial population and maximum population size #
#Nmin = minimum population size, agter bottleneck #
#s = selection coefficient against mutations (mutations are deleterious) --> can be positive as well#
#mu1 = #
#
mutation.simulator<-function(tmax=100, N0=1000, Nmin=10, s=-0.00001, mu1=1, mu2=0.01, K=2000, bint=10, mu.sd = 0.5)#
{#
	# The following creates an empty array with three dimensions: 1) generation, 2) individual, and 3) its properties (mutation rate, # mutations, fitness):#
	pops<-array(NA,dim=c(tmax+1,N0,3),dimnames=list(0:tmax,1:N0,c("mu","n.muts","fitness")))#
	# Initialising the population with no mutations and 1:1 ratio of genotypes with the two mutation rates#
	# at the start, half the population have mu1 and half mu2#
	pops[1,,]<-matrix(c(rep(c(mu1,0,1),N0/2),rep(c(mu2,0,1),N0/2)),byrow=TRUE,ncol=3,nrow=N0,dimnames=list(1:N0,c("mu","n.muts","fitness")))#
	# a vector of fitness values for different numbers of mutations#
	fitness.values<-(1+s)^(0:1000)#
	# a vector of population size in each generation#
	N<- populationsize(K=K, tmax=tmax, bint=bint, Nmin=Nmin, N0=N0)#
	#iterating through generations#
	for(i in 1:tmax) {#
		current.pop<-pops[i,,]#
		#chance of mutation for each individuation taken from poisson distribution:#
		for(j in 1:N[i]) {#
			new.muts<-rpois(1,current.pop[j,"mu"])#
			current.pop[j,"n.muts"]<-current.pop[j,"n.muts"]+new.muts#
			current.pop[j,"fitness"]<-fitness.values[current.pop[j,"n.muts"]+1]#
		}#
		#lowers popoulation if there is bottleneck, otherwise models reproduction#
		if (N[i+1]==Nmin) {#
		  #takes the previous generation population and randomly selects sample (number = Nmin)#
		  #sets all dead/potential individuals to NA#
		  current.pop[-sample(N[i],Nmin),]<-NA#
		  #stack live individuals on top of NA #
		  pops[i+1,,]<-rbind(current.pop[which(!is.na(current.pop[,1])),],current.pop[which(is.na(current.pop[,1])),])#
		} else {#
		  # reproduction (including drift):#
		  # weighted sampling, higher fitness individuals more likely to copy themselves#
		  # sampling previous gen to get current gen #
		  pops[i+1,,][1:N[i+1],]<-current.pop[sample(N[i],N[i+1],replace=TRUE,prob=current.pop[,"fitness"][which(!is.na(current.pop[,"fitness"]))]),][1:N[i+1],]#
		}#
		#print(exp(log(pops[i+1,,"mu"])) + rnorm(N[i+1],0,mu.sd))#
	#print(rnorm(N[i+1],0,mu.sd))#
	 pops[i+1,,"mu"][1:N[i+1]] <- exp(log(pops[i+1,,"mu"][1:N[i+1]])) + rnorm(N[i+1],0,mu.sd)#
	}#
	return(pops)#
}#
#
# calculates population size of current generation and adds to vector, N #
# models bottlenecks and population growth #
populationsize <- function(K, tmax, bint, Nmin, N0){#
  N=c(N0)#
  for (i in 1:tmax){#
    if (i %% bint == 0){#
      N[i+1] <- Nmin #
    } else {#
      N[i+1] <- 2*N[i]*(1-(N[i]/K))#
    }#
  }#
  return(round(N))#
}#
#
# helper function to calculate the frequency of a genotype with a certain mutation rate:#
# y axis#
mutator.freq<-function(pop,mu)#
{#
	population<-pop[,"mu"][which(!is.na(pop[,"mu"]))]#
	return(length(which(population==mu))/length(population))#
}#
#
sim.run<-mutation.simulator()#
plot(apply(sim.run,1,mutator.freq,mu=0.01),type="l",xlab="Generation",ylab="Frequency of anti-mutator")
# Lauren #
# started from version 2018_05_5 Lauren#
# attented prac 11/5/18#
# added comments to code#
#
#tmax = number of generations #
#N0 = initial population and maximum population size #
#Nmin = minimum population size, agter bottleneck #
#s = selection coefficient against mutations (mutations are deleterious) --> can be positive as well#
#mu1 = #
#
mutation.simulator<-function(tmax=100, N0=1000, Nmin=10, s=-0.00001, mu1=1, mu2=0.01, K=2000, bint=10, mu.sd = 0.5)#
{#
	# The following creates an empty array with three dimensions: 1) generation, 2) individual, and 3) its properties (mutation rate, # mutations, fitness):#
	pops<-array(NA,dim=c(tmax+1,N0,3),dimnames=list(0:tmax,1:N0,c("mu","n.muts","fitness")))#
	# Initialising the population with no mutations and 1:1 ratio of genotypes with the two mutation rates#
	# at the start, half the population have mu1 and half mu2#
	pops[1,,]<-matrix(c(rep(c(mu1,0,1),N0/2),rep(c(mu2,0,1),N0/2)),byrow=TRUE,ncol=3,nrow=N0,dimnames=list(1:N0,c("mu","n.muts","fitness")))#
	# a vector of fitness values for different numbers of mutations#
	fitness.values<-(1+s)^(0:1000)#
	# a vector of population size in each generation#
	N<- populationsize(K=K, tmax=tmax, bint=bint, Nmin=Nmin, N0=N0)#
	#iterating through generations#
	for(i in 1:tmax) {#
		current.pop<-pops[i,,]#
		#chance of mutation for each individuation taken from poisson distribution:#
		for(j in 1:N[i]) {#
			new.muts<-rpois(1,current.pop[j,"mu"])#
			current.pop[j,"n.muts"]<-current.pop[j,"n.muts"]+new.muts#
			current.pop[j,"fitness"]<-fitness.values[current.pop[j,"n.muts"]+1]#
		}#
		#lowers popoulation if there is bottleneck, otherwise models reproduction#
		if (N[i+1]==Nmin) {#
		  #takes the previous generation population and randomly selects sample (number = Nmin)#
		  #sets all dead/potential individuals to NA#
		  current.pop[-sample(N[i],Nmin),]<-NA#
		  #stack live individuals on top of NA #
		  pops[i+1,,]<-rbind(current.pop[which(!is.na(current.pop[,1])),],current.pop[which(is.na(current.pop[,1])),])#
		} else {#
		  # reproduction (including drift):#
		  # weighted sampling, higher fitness individuals more likely to copy themselves#
		  # sampling previous gen to get current gen #
		  pops[i+1,,][1:N[i+1],]<-current.pop[sample(N[i],N[i+1],replace=TRUE,prob=current.pop[,"fitness"][which(!is.na(current.pop[,"fitness"]))]),][1:N[i+1],]#
		}#
		print(exp(log(pops[i+1,,"mu"][1:N[i+1]])))#
		print(rnorm(N[i+1],0,mu.sd))#
	 #pops[i+1,,"mu"][1:N[i+1]] <- exp(log(pops[i+1,,"mu"][1:N[i+1]])) + rnorm(N[i+1],0,mu.sd)#
	}#
	return(pops)#
}#
#
# calculates population size of current generation and adds to vector, N #
# models bottlenecks and population growth #
populationsize <- function(K, tmax, bint, Nmin, N0){#
  N=c(N0)#
  for (i in 1:tmax){#
    if (i %% bint == 0){#
      N[i+1] <- Nmin #
    } else {#
      N[i+1] <- 2*N[i]*(1-(N[i]/K))#
    }#
  }#
  return(round(N))#
}#
#
# helper function to calculate the frequency of a genotype with a certain mutation rate:#
# y axis#
mutator.freq<-function(pop,mu)#
{#
	population<-pop[,"mu"][which(!is.na(pop[,"mu"]))]#
	return(length(which(population==mu))/length(population))#
}#
#
sim.run<-mutation.simulator()#
plot(apply(sim.run,1,mutator.freq,mu=0.01),type="l",xlab="Generation",ylab="Frequency of anti-mutator")
tmax<-100; N0<-1000; Nmin<-10; s<--0.00001; mu1<-1; mu2<-0.01; K<-2000; bint<-10; mu.sd <- 0.5
# The following creates an empty array with three dimensions: 1) generation, 2) individual, and 3) its properties (mutation rate, # mutations, fitness):#
	pops<-array(NA,dim=c(tmax+1,N0,3),dimnames=list(0:tmax,1:N0,c("mu","n.muts","fitness")))#
	# Initialising the population with no mutations and 1:1 ratio of genotypes with the two mutation rates#
	# at the start, half the population have mu1 and half mu2#
	pops[1,,]<-matrix(c(rep(c(mu1,0,1),N0/2),rep(c(mu2,0,1),N0/2)),byrow=TRUE,ncol=3,nrow=N0,dimnames=list(1:N0,c("mu","n.muts","fitness")))#
	# a vector of fitness values for different numbers of mutations#
	fitness.values<-(1+s)^(0:1000)#
	# a vector of population size in each generation#
	N<- populationsize(K=K, tmax=tmax, bint=bint, Nmin=Nmin, N0=N0)
i<-1
current.pop<-pops[i,,]#
		#chance of mutation for each individuation taken from poisson distribution:#
		for(j in 1:N[i]) {#
			new.muts<-rpois(1,current.pop[j,"mu"])#
			current.pop[j,"n.muts"]<-current.pop[j,"n.muts"]+new.muts#
			current.pop[j,"fitness"]<-fitness.values[current.pop[j,"n.muts"]+1]#
		}#
		#lowers popoulation if there is bottleneck, otherwise models reproduction#
		if (N[i+1]==Nmin) {#
		  #takes the previous generation population and randomly selects sample (number = Nmin)#
		  #sets all dead/potential individuals to NA#
		  current.pop[-sample(N[i],Nmin),]<-NA#
		  #stack live individuals on top of NA #
		  pops[i+1,,]<-rbind(current.pop[which(!is.na(current.pop[,1])),],current.pop[which(is.na(current.pop[,1])),])#
		} else {#
		  # reproduction (including drift):#
		  # weighted sampling, higher fitness individuals more likely to copy themselves#
		  # sampling previous gen to get current gen #
		  pops[i+1,,][1:N[i+1],]<-current.pop[sample(N[i],N[i+1],replace=TRUE,prob=current.pop[,"fitness"][which(!is.na(current.pop[,"fitness"]))]),][1:N[i+1],]#
		}
print(exp(log(pops[i+1,,"mu"][1:N[i+1]])))
pops[i+1,,"mu"]
print(exp(log(pops[i+1,,"mu"][1:N[i+1]])))
exp(log(pops[i+1,,"mu"][1:N[i+1]]))==pops[i+1,,"mu"]
cbind(exp(log(pops[i+1,,"mu"][1:N[i+1]])),pops[i+1,,"mu"])
cbind(exp(log(pops[i+1,,"mu"][1:N[i+1]])),pops[i+1,,"mu"],exp(log(pops[i+1,,"mu"][1:N[i+1]]))==pops[i+1,,"mu"])
rnorm(N[i+1],0,mu.sd)
exp(log(pops[i+1,,"mu"]+rnorm(N[i+1],0,mu.sd)
exp(log(pops[i+1,,"mu"])+rnorm(N[i+1],0,mu.sd)
exp(log(pops[i+1,,"mu"]))+rnorm(N[i+1],0,mu.sd)
sim.run<-mutation.simulator()
#N0 = initial population and maximum population size #
#Nmin = minimum population size, agter bottleneck #
#s = selection coefficient against mutations (mutations are deleterious) --> can be positive as well#
#mu1 = #
#
mutation.simulator<-function(tmax=100, N0=1000, Nmin=10, s=-0.00001, mu1=1, mu2=0.01, K=2000, bint=10, mu.sd = 0.5)#
{#
	# The following creates an empty array with three dimensions: 1) generation, 2) individual, and 3) its properties (mutation rate, # mutations, fitness):#
	pops<-array(NA,dim=c(tmax+1,N0,3),dimnames=list(0:tmax,1:N0,c("mu","n.muts","fitness")))#
	# Initialising the population with no mutations and 1:1 ratio of genotypes with the two mutation rates#
	# at the start, half the population have mu1 and half mu2#
	pops[1,,]<-matrix(c(rep(c(mu1,0,1),N0/2),rep(c(mu2,0,1),N0/2)),byrow=TRUE,ncol=3,nrow=N0,dimnames=list(1:N0,c("mu","n.muts","fitness")))#
	# a vector of fitness values for different numbers of mutations#
	fitness.values<-(1+s)^(0:1000)#
	# a vector of population size in each generation#
	N<- populationsize(K=K, tmax=tmax, bint=bint, Nmin=Nmin, N0=N0)#
	#iterating through generations#
	for(i in 1:tmax) {#
		current.pop<-pops[i,,]#
		#chance of mutation for each individuation taken from poisson distribution:#
		for(j in 1:N[i]) {#
			new.muts<-rpois(1,current.pop[j,"mu"])#
			current.pop[j,"n.muts"]<-current.pop[j,"n.muts"]+new.muts#
			current.pop[j,"fitness"]<-fitness.values[current.pop[j,"n.muts"]+1]#
		}#
		#lowers popoulation if there is bottleneck, otherwise models reproduction#
		if (N[i+1]==Nmin) {#
		  #takes the previous generation population and randomly selects sample (number = Nmin)#
		  #sets all dead/potential individuals to NA#
		  current.pop[-sample(N[i],Nmin),]<-NA#
		  #stack live individuals on top of NA #
		  pops[i+1,,]<-rbind(current.pop[which(!is.na(current.pop[,1])),],current.pop[which(is.na(current.pop[,1])),])#
		} else {#
		  # reproduction (including drift):#
		  # weighted sampling, higher fitness individuals more likely to copy themselves#
		  # sampling previous gen to get current gen #
		  pops[i+1,,][1:N[i+1],]<-current.pop[sample(N[i],N[i+1],replace=TRUE,prob=current.pop[,"fitness"][which(!is.na(current.pop[,"fitness"]))]),][1:N[i+1],]#
		}#
		#print(exp(log(pops[i+1,,"mu"][1:N[i+1]])))#
		#print(rnorm(N[i+1],0,mu.sd))#
	 #pops[i+1,,"mu"][1:N[i+1]] <- exp(log(pops[i+1,,"mu"][1:N[i+1]])) + rnorm(N[i+1],0,mu.sd)#
	}#
	return(pops)#
}
sim.run<-mutation.simulator()
# Lauren #
# started from version 2018_05_5 Lauren#
# attented prac 11/5/18#
# added comments to code#
#
#tmax = number of generations #
#N0 = initial population and maximum population size #
#Nmin = minimum population size, agter bottleneck #
#s = selection coefficient against mutations (mutations are deleterious) --> can be positive as well#
#mu1 = #
#
mutation.simulator<-function(tmax=100, N0=1000, Nmin=10, s=-0.00001, mu1=1, mu2=0.01, K=2000, bint=10, mu.sd = 0.5)#
{#
	# The following creates an empty array with three dimensions: 1) generation, 2) individual, and 3) its properties (mutation rate, # mutations, fitness):#
	pops<-array(NA,dim=c(tmax+1,N0,3),dimnames=list(0:tmax,1:N0,c("mu","n.muts","fitness")))#
	# Initialising the population with no mutations and 1:1 ratio of genotypes with the two mutation rates#
	# at the start, half the population have mu1 and half mu2#
	pops[1,,]<-matrix(c(rep(c(mu1,0,1),N0/2),rep(c(mu2,0,1),N0/2)),byrow=TRUE,ncol=3,nrow=N0,dimnames=list(1:N0,c("mu","n.muts","fitness")))#
	# a vector of fitness values for different numbers of mutations#
	fitness.values<-(1+s)^(0:1000)#
	# a vector of population size in each generation#
	N<- populationsize(K=K, tmax=tmax, bint=bint, Nmin=Nmin, N0=N0)#
	#iterating through generations#
	for(i in 1:tmax) {#
		current.pop<-pops[i,,]#
		#chance of mutation for each individuation taken from poisson distribution:#
		for(j in 1:N[i]) {#
			new.muts<-rpois(1,current.pop[j,"mu"])#
			current.pop[j,"n.muts"]<-current.pop[j,"n.muts"]+new.muts#
			current.pop[j,"fitness"]<-fitness.values[current.pop[j,"n.muts"]+1]#
		}#
		#lowers popoulation if there is bottleneck, otherwise models reproduction#
		if (N[i+1]==Nmin) {#
		  #takes the previous generation population and randomly selects sample (number = Nmin)#
		  #sets all dead/potential individuals to NA#
		  current.pop[-sample(N[i],Nmin),]<-NA#
		  #stack live individuals on top of NA #
		  pops[i+1,,]<-rbind(current.pop[which(!is.na(current.pop[,1])),],current.pop[which(is.na(current.pop[,1])),])#
		} else {#
		  # reproduction (including drift):#
		  # weighted sampling, higher fitness individuals more likely to copy themselves#
		  # sampling previous gen to get current gen #
		  pops[i+1,,][1:N[i+1],]<-current.pop[sample(N[i],N[i+1],replace=TRUE,prob=current.pop[,"fitness"][which(!is.na(current.pop[,"fitness"]))]),][1:N[i+1],]#
		}#
		#print(exp(log(pops[i+1,,"mu"][1:N[i+1]])))#
		#print(rnorm(N[i+1],0,mu.sd))#
	 pops[i+1,,"mu"][1:N[i+1]] <- exp(log(pops[i+1,,"mu"][1:N[i+1]])) + rnorm(N[i+1],0,mu.sd)#
	}#
	return(pops)#
}
sim.run<-mutation.simulator()
exp(log(pops[i+1,,"mu"][1:N[i+1]])) + rnorm(N[i+1],0,mu.sd)
# The following creates an empty array with three dimensions: 1) generation, 2) individual, and 3) its properties (mutation rate, # mutations, fitness):#
	pops<-array(NA,dim=c(tmax+1,N0,3),dimnames=list(0:tmax,1:N0,c("mu","n.muts","fitness")))#
	# Initialising the population with no mutations and 1:1 ratio of genotypes with the two mutation rates#
	# at the start, half the population have mu1 and half mu2#
	pops[1,,]<-matrix(c(rep(c(mu1,0,1),N0/2),rep(c(mu2,0,1),N0/2)),byrow=TRUE,ncol=3,nrow=N0,dimnames=list(1:N0,c("mu","n.muts","fitness")))#
	# a vector of fitness values for different numbers of mutations#
	fitness.values<-(1+s)^(0:1000)#
	# a vector of population size in each generation#
	N<- populationsize(K=K, tmax=tmax, bint=bint, Nmin=Nmin, N0=N0)#
	#iterating through generations#
	for(i in 1:tmax) {#
		current.pop<-pops[i,,]#
		#chance of mutation for each individuation taken from poisson distribution:#
		for(j in 1:N[i]) {#
			new.muts<-rpois(1,current.pop[j,"mu"])#
			current.pop[j,"n.muts"]<-current.pop[j,"n.muts"]+new.muts#
			current.pop[j,"fitness"]<-fitness.values[current.pop[j,"n.muts"]+1]#
		}#
		#lowers popoulation if there is bottleneck, otherwise models reproduction#
		if (N[i+1]==Nmin) {#
		  #takes the previous generation population and randomly selects sample (number = Nmin)#
		  #sets all dead/potential individuals to NA#
		  current.pop[-sample(N[i],Nmin),]<-NA#
		  #stack live individuals on top of NA #
		  pops[i+1,,]<-rbind(current.pop[which(!is.na(current.pop[,1])),],current.pop[which(is.na(current.pop[,1])),])#
		} else {#
		  # reproduction (including drift):#
		  # weighted sampling, higher fitness individuals more likely to copy themselves#
		  # sampling previous gen to get current gen #
		  pops[i+1,,][1:N[i+1],]<-current.pop[sample(N[i],N[i+1],replace=TRUE,prob=current.pop[,"fitness"][which(!is.na(current.pop[,"fitness"]))]),][1:N[i+1],]#
		}#
		#print(exp(log(pops[i+1,,"mu"][1:N[i+1]])))#
		#print(rnorm(N[i+1],0,mu.sd))#
	 pops[i+1,,"mu"][1:N[i+1]] <- exp(log(pops[i+1,,"mu"][1:N[i+1]])) + rnorm(N[i+1],0,mu.sd)#
	}
warnings()
traceback()
# Lauren #
# started from version 2018_05_5 Lauren#
# attented prac 11/5/18#
# added comments to code#
#
#tmax = number of generations #
#N0 = initial population and maximum population size #
#Nmin = minimum population size, agter bottleneck #
#s = selection coefficient against mutations (mutations are deleterious) --> can be positive as well#
#mu1 = #
#
mutation.simulator<-function(tmax=100, N0=1000, Nmin=10, s=-0.00001, mu1=1, mu2=0.01, K=2000, bint=10, mu.sd = 0.5)#
{#
	# The following creates an empty array with three dimensions: 1) generation, 2) individual, and 3) its properties (mutation rate, # mutations, fitness):#
	pops<-array(NA,dim=c(tmax+1,N0,3),dimnames=list(0:tmax,1:N0,c("mu","n.muts","fitness")))#
	# Initialising the population with no mutations and 1:1 ratio of genotypes with the two mutation rates#
	# at the start, half the population have mu1 and half mu2#
	pops[1,,]<-matrix(c(rep(c(mu1,0,1),N0/2),rep(c(mu2,0,1),N0/2)),byrow=TRUE,ncol=3,nrow=N0,dimnames=list(1:N0,c("mu","n.muts","fitness")))#
	# a vector of fitness values for different numbers of mutations#
	fitness.values<-(1+s)^(0:1000)#
	# a vector of population size in each generation#
	N<- populationsize(K=K, tmax=tmax, bint=bint, Nmin=Nmin, N0=N0)#
	#iterating through generations#
	for(i in 1:tmax) {#
		current.pop<-pops[i,,]#
		#chance of mutation for each individuation taken from poisson distribution:#
		for(j in 1:N[i]) {#
			new.muts<-rpois(1,current.pop[j,"mu"])#
			current.pop[j,"n.muts"]<-current.pop[j,"n.muts"]+new.muts#
			current.pop[j,"fitness"]<-fitness.values[current.pop[j,"n.muts"]+1]#
		}#
		#lowers popoulation if there is bottleneck, otherwise models reproduction#
		if (N[i+1]==Nmin) {#
		  #takes the previous generation population and randomly selects sample (number = Nmin)#
		  #sets all dead/potential individuals to NA#
		  current.pop[-sample(N[i],Nmin),]<-NA#
		  #stack live individuals on top of NA #
		  pops[i+1,,]<-rbind(current.pop[which(!is.na(current.pop[,1])),],current.pop[which(is.na(current.pop[,1])),])#
		} else {#
		  # reproduction (including drift):#
		  # weighted sampling, higher fitness individuals more likely to copy themselves#
		  # sampling previous gen to get current gen #
		  print(current.pop[sample(N[i],N[i+1],replace=TRUE,prob=current.pop[,"fitness"][which(!is.na(current.pop[,"fitness"]))]),][1:N[i+1],]) #
		  pops[i+1,,][1:N[i+1],]<-current.pop[sample(N[i],N[i+1],replace=TRUE,prob=current.pop[,"fitness"][which(!is.na(current.pop[,"fitness"]))]),][1:N[i+1],]#
		}#
		#print(exp(log(pops[i+1,,"mu"][1:N[i+1]])))#
		#print(rnorm(N[i+1],0,mu.sd))#
	 pops[i+1,,"mu"][1:N[i+1]] <- exp(log(pops[i+1,,"mu"][1:N[i+1]])) + rnorm(N[i+1],0,mu.sd)#
	}#
	return(pops)#
}#
#
# calculates population size of current generation and adds to vector, N #
# models bottlenecks and population growth #
populationsize <- function(K, tmax, bint, Nmin, N0){#
  N=c(N0)#
  for (i in 1:tmax){#
    if (i %% bint == 0){#
      N[i+1] <- Nmin #
    } else {#
      N[i+1] <- 2*N[i]*(1-(N[i]/K))#
    }#
  }#
  return(round(N))#
}#
#
# helper function to calculate the frequency of a genotype with a certain mutation rate:#
# y axis#
mutator.freq<-function(pop,mu)#
{#
	population<-pop[,"mu"][which(!is.na(pop[,"mu"]))]#
	return(length(which(population==mu))/length(population))#
}#
#
sim.run<-mutation.simulator()#
plot(apply(sim.run,1,mutator.freq,mu=0.01),type="l",xlab="Generation",ylab="Frequency of anti-mutator")
mutation.simulator<-function(tmax=100, N0=1000, Nmin=10, s=-0.00001, mu1=1, mu2=0.01, K=2000, bint=10, mu.sd = 0.5)#
{#
	# The following creates an empty array with three dimensions: 1) generation, 2) individual, and 3) its properties (mutation rate, # mutations, fitness):#
	pops<-array(NA,dim=c(tmax+1,N0,3),dimnames=list(0:tmax,1:N0,c("mu","n.muts","fitness")))#
	# Initialising the population with no mutations and 1:1 ratio of genotypes with the two mutation rates#
	# at the start, half the population have mu1 and half mu2#
	pops[1,,]<-matrix(c(rep(c(mu1,0,1),N0/2),rep(c(mu2,0,1),N0/2)),byrow=TRUE,ncol=3,nrow=N0,dimnames=list(1:N0,c("mu","n.muts","fitness")))#
	# a vector of fitness values for different numbers of mutations#
	fitness.values<-(1+s)^(0:1000)#
	# a vector of population size in each generation#
	N<- populationsize(K=K, tmax=tmax, bint=bint, Nmin=Nmin, N0=N0)#
	#iterating through generations#
	for(i in 1:tmax) {#
		current.pop<-pops[i,,]#
		#chance of mutation for each individuation taken from poisson distribution:#
		for(j in 1:N[i]) {#
			new.muts<-rpois(1,current.pop[j,"mu"])#
			current.pop[j,"n.muts"]<-current.pop[j,"n.muts"]+new.muts#
			current.pop[j,"fitness"]<-fitness.values[current.pop[j,"n.muts"]+1]#
		}#
		#lowers popoulation if there is bottleneck, otherwise models reproduction#
		if (N[i+1]==Nmin) {#
		  #takes the previous generation population and randomly selects sample (number = Nmin)#
		  #sets all dead/potential individuals to NA#
		  current.pop[-sample(N[i],Nmin),]<-NA#
		  #stack live individuals on top of NA #
		  pops[i+1,,]<-rbind(current.pop[which(!is.na(current.pop[,1])),],current.pop[which(is.na(current.pop[,1])),])#
		} else {#
		  # reproduction (including drift):#
		  # weighted sampling, higher fitness individuals more likely to copy themselves#
		  # sampling previous gen to get current gen #
		  print(current.pop[sample(N[i],N[i+1],replace=TRUE,prob=current.pop[,"fitness"][which(!is.na(current.pop[,"fitness"]))]),][1:N[i+1],]) #
		  pops[i+1,,][1:N[i+1],]<-current.pop[sample(N[i],N[i+1],replace=TRUE,prob=current.pop[,"fitness"][which(!is.na(current.pop[,"fitness"]))]),][1:N[i+1],]#
		}#
		#print(exp(log(pops[i+1,,"mu"][1:N[i+1]])))#
		#print(rnorm(N[i+1],0,mu.sd))#
	 pops[i+1,,"mu"][1:N[i+1]] <- exp(log(pops[i+1,,"mu"][1:N[i+1]])) + rnorm(N[i+1],0,mu.sd)#
	}#
	return(pops)#
}
# calculates population size of current generation and adds to vector, N #
# models bottlenecks and population growth #
populationsize <- function(K, tmax, bint, Nmin, N0){#
  N=c(N0)#
  for (i in 1:tmax){#
    if (i %% bint == 0){#
      N[i+1] <- Nmin #
    } else {#
      N[i+1] <- 2*N[i]*(1-(N[i]/K))#
    }#
  }#
  return(round(N))#
}#
#
# helper function to calculate the frequency of a genotype with a certain mutation rate:#
# y axis#
mutator.freq<-function(pop,mu)#
{#
	population<-pop[,"mu"][which(!is.na(pop[,"mu"]))]#
	return(length(which(population==mu))/length(population))#
}
sim.run<-mutation.simulator()
# Lauren #
# started from version 2018_05_5 Lauren#
# attented prac 11/5/18#
# added comments to code#
#
#tmax = number of generations #
#N0 = initial population and maximum population size #
#Nmin = minimum population size, agter bottleneck #
#s = selection coefficient against mutations (mutations are deleterious) --> can be positive as well#
#mu1 = #
#
mutation.simulator<-function(tmax=100, N0=1000, Nmin=10, s=-0.00001, mu1=1, mu2=0.01, K=2000, bint=10, mu.sd = 0.5)#
{#
	# The following creates an empty array with three dimensions: 1) generation, 2) individual, and 3) its properties (mutation rate, # mutations, fitness):#
	pops<-array(NA,dim=c(tmax+1,N0,3),dimnames=list(0:tmax,1:N0,c("mu","n.muts","fitness")))#
	# Initialising the population with no mutations and 1:1 ratio of genotypes with the two mutation rates#
	# at the start, half the population have mu1 and half mu2#
	pops[1,,]<-matrix(c(rep(c(mu1,0,1),N0/2),rep(c(mu2,0,1),N0/2)),byrow=TRUE,ncol=3,nrow=N0,dimnames=list(1:N0,c("mu","n.muts","fitness")))#
	# a vector of fitness values for different numbers of mutations#
	fitness.values<-(1+s)^(0:1000)#
	# a vector of population size in each generation#
	N<- populationsize(K=K, tmax=tmax, bint=bint, Nmin=Nmin, N0=N0)#
	#iterating through generations#
	for(i in 1:tmax) {#
		current.pop<-pops[i,,]#
		#chance of mutation for each individuation taken from poisson distribution:#
		for(j in 1:N[i]) {#
			print("before mutation")#
			new.muts<-rpois(1,current.pop[j,"mu"])#
			print("after mutation")#
			current.pop[j,"n.muts"]<-current.pop[j,"n.muts"]+new.muts#
			current.pop[j,"fitness"]<-fitness.values[current.pop[j,"n.muts"]+1]#
		}#
		#lowers popoulation if there is bottleneck, otherwise models reproduction#
		if (N[i+1]==Nmin) {#
		  #takes the previous generation population and randomly selects sample (number = Nmin)#
		  #sets all dead/potential individuals to NA#
		  current.pop[-sample(N[i],Nmin),]<-NA#
		  #stack live individuals on top of NA #
		  pops[i+1,,]<-rbind(current.pop[which(!is.na(current.pop[,1])),],current.pop[which(is.na(current.pop[,1])),])#
		} else {#
		  # reproduction (including drift):#
		  # weighted sampling, higher fitness individuals more likely to copy themselves#
		  # sampling previous gen to get current gen #
#
		  pops[i+1,,][1:N[i+1],]<-current.pop[sample(N[i],N[i+1],replace=TRUE,prob=current.pop[,"fitness"][which(!is.na(current.pop[,"fitness"]))]),][1:N[i+1],]#
		}#
		#print(exp(log(pops[i+1,,"mu"][1:N[i+1]])))#
		#print(rnorm(N[i+1],0,mu.sd))#
	 pops[i+1,,"mu"][1:N[i+1]] <- exp(log(pops[i+1,,"mu"][1:N[i+1]])) + rnorm(N[i+1],0,mu.sd)#
	}#
	return(pops)#
}#
#
# calculates population size of current generation and adds to vector, N #
# models bottlenecks and population growth #
populationsize <- function(K, tmax, bint, Nmin, N0){#
  N=c(N0)#
  for (i in 1:tmax){#
    if (i %% bint == 0){#
      N[i+1] <- Nmin #
    } else {#
      N[i+1] <- 2*N[i]*(1-(N[i]/K))#
    }#
  }#
  return(round(N))#
}#
#
# helper function to calculate the frequency of a genotype with a certain mutation rate:#
# y axis#
mutator.freq<-function(pop,mu)#
{#
	population<-pop[,"mu"][which(!is.na(pop[,"mu"]))]#
	return(length(which(population==mu))/length(population))#
}#
#
sim.run<-mutation.simulator()#
plot(apply(sim.run,1,mutator.freq,mu=0.01),type="l",xlab="Generation",ylab="Frequency of anti-mutator")
# Lauren #
# started from version 2018_05_5 Lauren#
# attented prac 11/5/18#
# added comments to code#
#
#tmax = number of generations #
#N0 = initial population and maximum population size #
#Nmin = minimum population size, agter bottleneck #
#s = selection coefficient against mutations (mutations are deleterious) --> can be positive as well#
#mu1 = #
#
mutation.simulator<-function(tmax=100, N0=1000, Nmin=10, s=-0.00001, mu1=1, mu2=0.01, K=2000, bint=10, mu.sd = 0.5)#
{#
	# The following creates an empty array with three dimensions: 1) generation, 2) individual, and 3) its properties (mutation rate, # mutations, fitness):#
	pops<-array(NA,dim=c(tmax+1,N0,3),dimnames=list(0:tmax,1:N0,c("mu","n.muts","fitness")))#
	# Initialising the population with no mutations and 1:1 ratio of genotypes with the two mutation rates#
	# at the start, half the population have mu1 and half mu2#
	pops[1,,]<-matrix(c(rep(c(mu1,0,1),N0/2),rep(c(mu2,0,1),N0/2)),byrow=TRUE,ncol=3,nrow=N0,dimnames=list(1:N0,c("mu","n.muts","fitness")))#
	# a vector of fitness values for different numbers of mutations#
	fitness.values<-(1+s)^(0:1000)#
	# a vector of population size in each generation#
	N<- populationsize(K=K, tmax=tmax, bint=bint, Nmin=Nmin, N0=N0)#
	#iterating through generations#
	for(i in 1:tmax) {#
		current.pop<-pops[i,,]#
		#chance of mutation for each individuation taken from poisson distribution:#
		for(j in 1:N[i]) {#
			print("before mutation")#
			new.muts<-rpois(1,current.pop[j,"mu"])#
			print(new.muts)#
			print("after mutation")#
			current.pop[j,"n.muts"]<-current.pop[j,"n.muts"]+new.muts#
			current.pop[j,"fitness"]<-fitness.values[current.pop[j,"n.muts"]+1]#
		}#
		#lowers popoulation if there is bottleneck, otherwise models reproduction#
		if (N[i+1]==Nmin) {#
		  #takes the previous generation population and randomly selects sample (number = Nmin)#
		  #sets all dead/potential individuals to NA#
		  current.pop[-sample(N[i],Nmin),]<-NA#
		  #stack live individuals on top of NA #
		  pops[i+1,,]<-rbind(current.pop[which(!is.na(current.pop[,1])),],current.pop[which(is.na(current.pop[,1])),])#
		} else {#
		  # reproduction (including drift):#
		  # weighted sampling, higher fitness individuals more likely to copy themselves#
		  # sampling previous gen to get current gen #
#
		  pops[i+1,,][1:N[i+1],]<-current.pop[sample(N[i],N[i+1],replace=TRUE,prob=current.pop[,"fitness"][which(!is.na(current.pop[,"fitness"]))]),][1:N[i+1],]#
		}#
		#print(exp(log(pops[i+1,,"mu"][1:N[i+1]])))#
		#print(rnorm(N[i+1],0,mu.sd))#
	 pops[i+1,,"mu"][1:N[i+1]] <- exp(log(pops[i+1,,"mu"][1:N[i+1]])) + rnorm(N[i+1],0,mu.sd)#
	}#
	return(pops)#
}#
#
# calculates population size of current generation and adds to vector, N #
# models bottlenecks and population growth #
populationsize <- function(K, tmax, bint, Nmin, N0){#
  N=c(N0)#
  for (i in 1:tmax){#
    if (i %% bint == 0){#
      N[i+1] <- Nmin #
    } else {#
      N[i+1] <- 2*N[i]*(1-(N[i]/K))#
    }#
  }#
  return(round(N))#
}#
#
# helper function to calculate the frequency of a genotype with a certain mutation rate:#
# y axis#
mutator.freq<-function(pop,mu)#
{#
	population<-pop[,"mu"][which(!is.na(pop[,"mu"]))]#
	return(length(which(population==mu))/length(population))#
}#
#
sim.run<-mutation.simulator()#
plot(apply(sim.run,1,mutator.freq,mu=0.01),type="l",xlab="Generation",ylab="Frequency of anti-mutator")
library(cophy)
library(devtools)
library(roxygen2)
check("cophy", cran=F)
?Classes
?Methods
ExpC7.files<-list.files(path = "/Volumes/NicoleWork/Exploration C/ExplorationC7", all.files = TRUE, full.names = TRUE, no.. =TRUE)
ExpC7.files
ExpC7.sig.0.0<-grep("ExplorationC7/Exploration C7 screen gamma", ExpC7.files)
ExpC7.sig.0.0
ExpC7.files[ExpC7.sig.0.0]
4*4*4
#' Creates a cophy object#
#'#
#' This function creates an object of class 'cophy', which can be passed to the#
#' plot.cophy() function. This object must contain at least one host and one#
#' parasite tree, but can also contain a second parasite tree and a#
#' TraitTracking object.#
#' @param HP.tree a list of a pre-built host phylogenetic tree and a parasite phylogenetic tree of class 'cophylogeny' or 'data.frame#
#' @return this function returns an object of class 'cophylogeny' which can be#
#'   passed to the plot() function.#
#' @keywords cophy, object#
#' @export#
#' @examples#
#' Htree<-rphylo_H(tmax=5, export.format='Raw')#
#' HPtree<-rcophylo_PonH(H.tree=Htree, tmax=5)#
#' cophylogeny(HPtree[[1]], HPtree[[2]])#
#
cophylogeny <- function(HP.tree) {#
  if (class(HP.tree[[1]]) == "data.frame") {#
    H.tree <- convert_HBranchesToPhylo(Hbranches = H.tree)#
  }#
#
  if (class(HP.tree[[2]]) == "data.frame") {#
    P.tree <- convert_PBranchesToPhylo(PBranches = P.tree)#
  }#
#
  cophy <- list(H.tree, P.tree)#
#
  class(cophy) <- "cophylogeny"#
  return(cophy)#
}#
#
#' Cophylogeny plot#
#'#
#' This function plots a host-parasite cophylogenetic tree.#
#' @param x a cophylogeny (object of class 'cophy' built by the cophy(H.tree,#
#'   P.tree, Q.tree=NA, TraitTracking=NA) function) containing a host tree and a#
#'   parasite tree. This may also contain a second parasite tree or/and parasite#
#'   trait values.#
#' @param ParasiteCol specifies the colour to use when ploting parasite lineages. #
#'   Defaults to "Red".#
#' @param ... other parameters to be passed to plotting functions.#
#' @keywords cophylogeny, plot#
#' @importFrom graphics arrows#
#' @importFrom graphics lines#
#' @export#
#' @examples#
#' Htree<-rphylo_H(tmax=5, export.format='Raw')#
#' HPtree<-rcophylo_PonH(H.tree=Htree, tmax=5)#
#' plot(cophylogeny(HPtree[[1]], HPtree[[2]]))#
#
plot.cophylogeny <- function(x, ParasiteCol = "Red", ...) {#
  Hphy <- x[[1]]#
  Pphy <- x[[2]]#
#
  # determining lines to be drawn for the host phylogeny:#
#
  HBranchLines <- matrix(NA, ncol = 3, nrow = 0)#
  colnames(HBranchLines) <- c("x1", "x2", "y")#
#
  HBranchLines <- rbind(HBranchLines, c(0, Hphy$edge.length[1], 0))#
  HBranchLines <- rbind(HBranchLines, c(0, Hphy$edge.length[2], 1))#
#
  HConnectorLines <- matrix(NA, ncol = 3, nrow = 0)#
  colnames(HConnectorLines) <- c("x", "y1", "y2")#
#
  noHNodes <- length(Hphy$edge[, 1]) + 1  # total number of nodes in the host phylogeny#
  firstHNode <- (length(Hphy$edge[, 1])/2) + 2  # the first internal node in the host phylogeny#
#
  if (length(Hphy$edge[, 1]) > 2) {#
    for (i in (firstHNode + 1):noHNodes) {#
      # loop covering all internal nodes#
      daughterBranches <- which(Hphy$edge[, 1] == i)  # indices of the two new branches to be added#
      motherBranch <- match(i, Hphy$edge[, 2])  # index of the mother branch#
      tnew <- HBranchLines[motherBranch, 2]  # time point when the new branches begin#
      HBranchLines <- rbind(HBranchLines, c(tnew, tnew + Hphy$edge.length[daughterBranches[1]],#
                                            HBranchLines[motherBranch, 3]))#
      HBranchLines <- rbind(HBranchLines, c(tnew, tnew + Hphy$edge.length[daughterBranches[2]],#
                                            HBranchLines[motherBranch, 3] + 1))#
#
      # move old branches situated above the new ones up by one unit:#
      branchesAbove <- which(HBranchLines[1:(length(HBranchLines[, 1]) - 2),#
                                          3] >= HBranchLines[motherBranch, 3] + 1)#
      HBranchLines[branchesAbove, 3] <- HBranchLines[branchesAbove, 3] + 1#
#
      # go backwards in time and adjust ancestral branches so that they are in the#
      # middle of daughter branches:#
      j <- motherBranch#
      while (!is.na(j)) {#
        daughterBranches <- which(Hphy$edge[j, 2] == Hphy$edge[, 1])#
        HBranchLines[j, 3] <- mean(HBranchLines[daughterBranches, 3])  # y-position of branch should be average of two daugher branch y-values#
        j <- match(Hphy$edge[j, 1], Hphy$edge[, 2])  # going further back in time to the ancestral branch#
      }#
    }#
  }#
#
  for (i in firstHNode:noHNodes) {#
    # loop covering all internal nodes#
    daughterBranches <- which(Hphy$edge[, 1] == i)  # indices of the two daughter branches extending from node#
    tnew <- HBranchLines[daughterBranches[1], 1]  # time point of the node#
    HConnectorLines <- rbind(HConnectorLines, c(tnew, HBranchLines[daughterBranches[1],#
                                                                   3], HBranchLines[daughterBranches[2], 3]))#
  }#
#
  PBranchLines <- matrix(NA, ncol = 3, nrow = 2)#
  colnames(PBranchLines) <- c("x1", "x2", "y")#
  PBranchLines[1, 1] <- 0#
  PBranchLines[1, 2] <- Pphy$edge.length[1]#
  PBranchLines[1, 3] <- HBranchLines[Pphy$Hassoc[1], 3]#
#
  PBranchLines[2, 1] <- 0#
  PBranchLines[2, 2] <- Pphy$edge.length[2]#
  PBranchLines[2, 3] <- HBranchLines[Pphy$Hassoc[2], 3]#
#
  PConnectorLines <- matrix(NA, ncol = 4, nrow = 0)#
  colnames(PConnectorLines) <- c("x", "y1", "y2", "hostJump")#
#
  noPNodes <- length(Pphy$edge[, 1]) + 1  # total number of nodes in the parasite phylogeny#
  firstPNode <- (length(Pphy$edge[, 1])/2) + 2  # the first internal node in the parasite phylogeny#
#
  if (length(Pphy$edge[, 1]) > 2) {#
    for (i in (firstPNode + 1):noPNodes) {#
      # loop covering all internal nodes#
      daughterBranches <- which(Pphy$edge[, 1] == i)  # indices of the two new branches to be added#
      motherBranch <- match(i, Pphy$edge[, 2])  # index of the mother branch#
      tnew <- PBranchLines[motherBranch, 2]  # time point when the new branches begin#
      PBranchLines <- rbind(PBranchLines, c(tnew, tnew + Pphy$edge.length[daughterBranches[1]],#
                                              HBranchLines[Pphy$Hassoc[daughterBranches[1]], 3]))#
      PBranchLines <- rbind(PBranchLines, c(tnew, tnew + Pphy$edge.length[daughterBranches[2]],#
                                              HBranchLines[Pphy$Hassoc[daughterBranches[2]], 3]))#
    }#
  }#
#
  for (i in firstPNode:noPNodes) {#
    # loop covering all internal nodes#
    daughterBranches <- which(Pphy$edge[, 1] == i)  # indices of the two daughter branches extending from node#
#
    tnew <- PBranchLines[daughterBranches[1], 1]  # time point of the node#
    if (i == firstPNode) {#
      hostJump <- FALSE#
    }#
    if (i > firstPNode) {#
      motherBranch <- match(i, Pphy$edge[, 2])  # index of the mother branch#
      hostJump <- (Pphy$Hassoc[daughterBranches[1]] == Pphy$Hassoc[motherBranch])  # whether or not the node corresponds to a host jump#
    }#
    PConnectorLines <- rbind(PConnectorLines, c(tnew, PBranchLines[daughterBranches[1],#
                                                                     3], PBranchLines[daughterBranches[2], 3], hostJump))#
  }#
#
  if (!is.null(Hphy$root.edge)) {#
    # adding root branch if there is one#
    HBranchLines <- t(t(HBranchLines) + c(Hphy$root.edge, Hphy$root.edge, 0))#
    HBranchLines <- rbind(c(0, Hphy$root.edge, (HBranchLines[1, 3] + HBranchLines[2,#
                                                                                  3])/2), HBranchLines)#
    HConnectorLines <- t(t(HConnectorLines) + c(Hphy$root.edge, 0, 0))#
#
    if (plotP == TRUE) {#
      PBranchLines <- t(t(PBranchLines) + c(Pphy$root.edge, Pphy$root.edge,#
                                            0))#
      if (is.null(Pphy$root.Hassoc))#
        Proot.y <- HBranchLines[1, 3] else Proot.y <- HBranchLines[Pphy$root.Hassoc, 3]#
        PBranchLines <- rbind(c(0, Pphy$root.edge, Proot.y), PBranchLines)#
        PConnectorLines <- t(t(PConnectorLines) + c(Pphy$root.edge, 0, 0, 0))#
#
        xshift <- max(HBranchLines[, 2])/1000 + Pphy$root.time#
        if (class(TraitTracking) == "list")#
          yshift <- 0.5 else yshift <- 0.1#
        PBranchLines <- sweep(PBranchLines, 2, -c(xshift, xshift, yshift))#
        if (length(PConnectorLines[, 1]) > 1)#
          PConnectorLines[, 1:3] <- sweep(PConnectorLines[, 1:3], 2, -c(xshift,#
                                                                        yshift, yshift)) else PConnectorLines[1, 1:3] <- PConnectorLines[1, 1:3] + c(xshift, yshift,#
                                                                                                                                                     yshift)#
#
    }#
  }#
#
  # plotting all lines:#
  graphics::plot.new()#
  graphics::plot.window(xlim = c(0, max(HBranchLines[, 2])), ylim = c(0, max(HBranchLines[, 3])))#
  for (i in 1:length(HBranchLines[, 1])) {#
  	graphics::lines(c(HBranchLines[i, 1], HBranchLines[i, 2]), c(HBranchLines[i, 3], HBranchLines[i, 3]))#
  }#
  for (i in 1:length(HConnectorLines[, 1])) {#
  	graphics::lines(c(HConnectorLines[i, 1], HConnectorLines[i, 1]), c(HConnectorLines[i, 2], HConnectorLines[i,3]))#
  }#
#
  if (plotP == TRUE) {#
    for (i in 1:length(PBranchLines[, 1])) {#
    	  graphics::lines(c(PBranchLines[i, 1], PBranchLines[i, 2]), c(PBranchLines[i, 3], PBranchLines[i, 3]), col = ParasiteCol[[1]])#
    	}#
    for (i in 1:length(PConnectorLines[, 1])) {#
      if (PConnectorLines[i, 4] == TRUE) {#
        graphics::arrows(PConnectorLines[i, 1], PConnectorLines[i, 2], PConnectorLines[i, 1], PConnectorLines[i, 3], col = ParasiteCol[[1]], length = 0.1, angle = 10) else graphics::lines(c(PConnectorLines[i, 1], PConnectorLines[i, 1]), c(PConnectorLines[i, 2], PConnectorLines[i, 3]), col = ParasiteCol[[1]])#
      }#
    }#
  }#
}
#' Creates a cophy object#
#'#
#' This function creates an object of class 'cophy', which can be passed to the#
#' plot.cophy() function. This object must contain at least one host and one#
#' parasite tree, but can also contain a second parasite tree and a#
#' TraitTracking object.#
#' @param HP.tree a list of a pre-built host phylogenetic tree and a parasite phylogenetic tree of class 'cophylogeny' or 'data.frame#
#' @return this function returns an object of class 'cophylogeny' which can be#
#'   passed to the plot() function.#
#' @keywords cophy, object#
#' @export#
#' @examples#
#' Htree<-rphylo_H(tmax=5, export.format='Raw')#
#' HPtree<-rcophylo_PonH(H.tree=Htree, tmax=5)#
#' cophylogeny(HPtree[[1]], HPtree[[2]])#
#
cophylogeny <- function(HP.tree) {#
  if (class(HP.tree[[1]]) == "data.frame") {#
    H.tree <- convert_HBranchesToPhylo(Hbranches = H.tree)#
  }#
#
  if (class(HP.tree[[2]]) == "data.frame") {#
    P.tree <- convert_PBranchesToPhylo(PBranches = P.tree)#
  }#
#
  cophy <- list(H.tree, P.tree)#
#
  class(cophy) <- "cophylogeny"#
  return(cophy)#
}#
#
#' Cophylogeny plot#
#'#
#' This function plots a host-parasite cophylogenetic tree.#
#' @param x a cophylogeny (object of class 'cophy' built by the cophy(H.tree,#
#'   P.tree, Q.tree=NA, TraitTracking=NA) function) containing a host tree and a#
#'   parasite tree. This may also contain a second parasite tree or/and parasite#
#'   trait values.#
#' @param ParasiteCol specifies the colour to use when ploting parasite lineages. #
#'   Defaults to "Red".#
#' @param ... other parameters to be passed to plotting functions.#
#' @keywords cophylogeny, plot#
#' @importFrom graphics arrows#
#' @importFrom graphics lines#
#' @export#
#' @examples#
#' Htree<-rphylo_H(tmax=5, export.format='Raw')#
#' HPtree<-rcophylo_PonH(H.tree=Htree, tmax=5)#
#' plot(cophylogeny(HPtree[[1]], HPtree[[2]]))#
#
plot.cophylogeny <- function(x, ParasiteCol = "Red", ...) {#
  Hphy <- x[[1]]#
  Pphy <- x[[2]]#
#
  # determining lines to be drawn for the host phylogeny:#
#
  HBranchLines <- matrix(NA, ncol = 3, nrow = 0)#
  colnames(HBranchLines) <- c("x1", "x2", "y")#
#
  HBranchLines <- rbind(HBranchLines, c(0, Hphy$edge.length[1], 0))#
  HBranchLines <- rbind(HBranchLines, c(0, Hphy$edge.length[2], 1))#
#
  HConnectorLines <- matrix(NA, ncol = 3, nrow = 0)#
  colnames(HConnectorLines) <- c("x", "y1", "y2")#
#
  noHNodes <- length(Hphy$edge[, 1]) + 1  # total number of nodes in the host phylogeny#
  firstHNode <- (length(Hphy$edge[, 1])/2) + 2  # the first internal node in the host phylogeny#
#
  if (length(Hphy$edge[, 1]) > 2) {#
    for (i in (firstHNode + 1):noHNodes) {#
      # loop covering all internal nodes#
      daughterBranches <- which(Hphy$edge[, 1] == i)  # indices of the two new branches to be added#
      motherBranch <- match(i, Hphy$edge[, 2])  # index of the mother branch#
      tnew <- HBranchLines[motherBranch, 2]  # time point when the new branches begin#
      HBranchLines <- rbind(HBranchLines, c(tnew, tnew + Hphy$edge.length[daughterBranches[1]],#
                                            HBranchLines[motherBranch, 3]))#
      HBranchLines <- rbind(HBranchLines, c(tnew, tnew + Hphy$edge.length[daughterBranches[2]],#
                                            HBranchLines[motherBranch, 3] + 1))#
#
      # move old branches situated above the new ones up by one unit:#
      branchesAbove <- which(HBranchLines[1:(length(HBranchLines[, 1]) - 2),#
                                          3] >= HBranchLines[motherBranch, 3] + 1)#
      HBranchLines[branchesAbove, 3] <- HBranchLines[branchesAbove, 3] + 1#
#
      # go backwards in time and adjust ancestral branches so that they are in the#
      # middle of daughter branches:#
      j <- motherBranch#
      while (!is.na(j)) {#
        daughterBranches <- which(Hphy$edge[j, 2] == Hphy$edge[, 1])#
        HBranchLines[j, 3] <- mean(HBranchLines[daughterBranches, 3])  # y-position of branch should be average of two daugher branch y-values#
        j <- match(Hphy$edge[j, 1], Hphy$edge[, 2])  # going further back in time to the ancestral branch#
      }#
    }#
  }#
#
  for (i in firstHNode:noHNodes) {#
    # loop covering all internal nodes#
    daughterBranches <- which(Hphy$edge[, 1] == i)  # indices of the two daughter branches extending from node#
    tnew <- HBranchLines[daughterBranches[1], 1]  # time point of the node#
    HConnectorLines <- rbind(HConnectorLines, c(tnew, HBranchLines[daughterBranches[1],#
                                                                   3], HBranchLines[daughterBranches[2], 3]))#
  }#
#
  PBranchLines <- matrix(NA, ncol = 3, nrow = 2)#
  colnames(PBranchLines) <- c("x1", "x2", "y")#
  PBranchLines[1, 1] <- 0#
  PBranchLines[1, 2] <- Pphy$edge.length[1]#
  PBranchLines[1, 3] <- HBranchLines[Pphy$Hassoc[1], 3]#
#
  PBranchLines[2, 1] <- 0#
  PBranchLines[2, 2] <- Pphy$edge.length[2]#
  PBranchLines[2, 3] <- HBranchLines[Pphy$Hassoc[2], 3]#
#
  PConnectorLines <- matrix(NA, ncol = 4, nrow = 0)#
  colnames(PConnectorLines) <- c("x", "y1", "y2", "hostJump")#
#
  noPNodes <- length(Pphy$edge[, 1]) + 1  # total number of nodes in the parasite phylogeny#
  firstPNode <- (length(Pphy$edge[, 1])/2) + 2  # the first internal node in the parasite phylogeny#
#
  if (length(Pphy$edge[, 1]) > 2) {#
    for (i in (firstPNode + 1):noPNodes) {#
      # loop covering all internal nodes#
      daughterBranches <- which(Pphy$edge[, 1] == i)  # indices of the two new branches to be added#
      motherBranch <- match(i, Pphy$edge[, 2])  # index of the mother branch#
      tnew <- PBranchLines[motherBranch, 2]  # time point when the new branches begin#
      PBranchLines <- rbind(PBranchLines, c(tnew, tnew + Pphy$edge.length[daughterBranches[1]],#
                                              HBranchLines[Pphy$Hassoc[daughterBranches[1]], 3]))#
      PBranchLines <- rbind(PBranchLines, c(tnew, tnew + Pphy$edge.length[daughterBranches[2]],#
                                              HBranchLines[Pphy$Hassoc[daughterBranches[2]], 3]))#
    }#
  }#
#
  for (i in firstPNode:noPNodes) {#
    # loop covering all internal nodes#
    daughterBranches <- which(Pphy$edge[, 1] == i)  # indices of the two daughter branches extending from node#
#
    tnew <- PBranchLines[daughterBranches[1], 1]  # time point of the node#
    if (i == firstPNode) {#
      hostJump <- FALSE#
    }#
    if (i > firstPNode) {#
      motherBranch <- match(i, Pphy$edge[, 2])  # index of the mother branch#
      hostJump <- (Pphy$Hassoc[daughterBranches[1]] == Pphy$Hassoc[motherBranch])  # whether or not the node corresponds to a host jump#
    }#
    PConnectorLines <- rbind(PConnectorLines, c(tnew, PBranchLines[daughterBranches[1],#
                                                                     3], PBranchLines[daughterBranches[2], 3], hostJump))#
  }#
#
  if (!is.null(Hphy$root.edge)) {#
    # adding root branch if there is one#
    HBranchLines <- t(t(HBranchLines) + c(Hphy$root.edge, Hphy$root.edge, 0))#
    HBranchLines <- rbind(c(0, Hphy$root.edge, (HBranchLines[1, 3] + HBranchLines[2,#
                                                                                  3])/2), HBranchLines)#
    HConnectorLines <- t(t(HConnectorLines) + c(Hphy$root.edge, 0, 0))#
#
    if (plotP == TRUE) {#
      PBranchLines <- t(t(PBranchLines) + c(Pphy$root.edge, Pphy$root.edge, 0))#
      if (is.null(Pphy$root.Hassoc))#
        Proot.y <- HBranchLines[1, 3] #
      else {#
        	Proot.y <- HBranchLines[Pphy$root.Hassoc, 3]#
      }#
      PBranchLines <- rbind(c(0, Pphy$root.edge, Proot.y), PBranchLines)#
      PConnectorLines <- t(t(PConnectorLines) + c(Pphy$root.edge, 0, 0, 0))#
#
      xshift <- max(HBranchLines[, 2])/1000 + Pphy$root.time#
      if (class(TraitTracking) == "list") {#
        yshift <- 0.5 #
      } else {#
        yshift <- 0.1#
      }#
      PBranchLines <- sweep(PBranchLines, 2, -c(xshift, xshift, yshift))#
      if (length(PConnectorLines[, 1]) > 1) {#
        PConnectorLines[, 1:3] <- sweep(PConnectorLines[, 1:3], 2, -c(xshift, yshift, yshift)) #
      } else { #
        PConnectorLines[1, 1:3] <- PConnectorLines[1, 1:3] + c(xshift, yshift, yshift)#
      }#
    }#
  }#
#
  # plotting all lines:#
  graphics::plot.new()#
  graphics::plot.window(xlim = c(0, max(HBranchLines[, 2])), ylim = c(0, max(HBranchLines[, 3])))#
  for (i in 1:length(HBranchLines[, 1])) {#
  	graphics::lines(c(HBranchLines[i, 1], HBranchLines[i, 2]), c(HBranchLines[i, 3], HBranchLines[i, 3]))#
  }#
  for (i in 1:length(HConnectorLines[, 1])) {#
  	graphics::lines(c(HConnectorLines[i, 1], HConnectorLines[i, 1]), c(HConnectorLines[i, 2], HConnectorLines[i,3]))#
  }#
#
  if (plotP == TRUE) {#
    for (i in 1:length(PBranchLines[, 1])) {#
    	  graphics::lines(c(PBranchLines[i, 1], PBranchLines[i, 2]), c(PBranchLines[i, 3], PBranchLines[i, 3]), col = ParasiteCol[[1]])#
    	}#
    for (i in 1:length(PConnectorLines[, 1])) {#
      if (PConnectorLines[i, 4] == TRUE) {#
        graphics::arrows(PConnectorLines[i, 1], PConnectorLines[i, 2], PConnectorLines[i, 1], PConnectorLines[i, 3], col = ParasiteCol[[1]], length = 0.1, angle = 10) else graphics::lines(c(PConnectorLines[i, 1], PConnectorLines[i, 1]), c(PConnectorLines[i, 2], PConnectorLines[i, 3]), col = ParasiteCol[[1]])#
      }#
    }#
  }#
}
library(devtools)
install_github("JanEngelstaedter/cophy")
install_github("JanEngelstaedter/cophy", pkg="cophy")
library(roxygen2)
?median
quantile(x <- rnorm(1001))
quantile(x <- rnorm(1001))[2:4]
# Lauren #
# started from version 2018_05_5 Lauren#
# attented prac 11/5/18#
# added comments to code#
#
#tmax = number of generations #
#N0 = initial population and maximum population size #
#Nmin = minimum population size, agter bottleneck #
#s = selection coefficient against mutations (mutations are deleterious) --> can be positive as well#
#mu1 = #
#
mutation.simulator<-function(tmax=100, N0=1000, Nmin=10, s=-0.00001, mu1=1, mu2=0.01, K=2000, bint=10, mu.sd = 0.5)#
{#
	# The following creates an empty array with three dimensions: 1) generation, 2) individual, and 3) its properties (mutation rate, # mutations, fitness):#
	pops<-array(NA,dim=c(tmax+1,N0,3),dimnames=list(0:tmax,1:N0,c("mu","n.muts","fitness")))#
	# Initialising the population with no mutations and 1:1 ratio of genotypes with the two mutation rates#
	# at the start, half the population have mu1 and half mu2#
	pops[1,,]<-matrix(c(rep(c(mu1,0,1),N0/2),rep(c(mu2,0,1),N0/2)),byrow=TRUE,ncol=3,nrow=N0,dimnames=list(1:N0,c("mu","n.muts","fitness")))#
	# a vector of fitness values for different numbers of mutations#
	fitness.values<-(1+s)^(0:1000)#
	# a vector of population size in each generation#
	N<- populationsize(K=K, tmax=tmax, bint=bint, Nmin=Nmin, N0=N0)#
	#iterating through generations#
	for(i in 1:tmax) {#
		current.pop<-pops[i,,]#
		#chance of mutation for each individuation taken from poisson distribution:#
		for(j in 1:N[i]) {#
			new.muts<-rpois(1,current.pop[j,"mu"])#
			current.pop[j,"n.muts"]<-current.pop[j,"n.muts"]+new.muts#
			current.pop[j,"fitness"]<-fitness.values[current.pop[j,"n.muts"]+1]#
		}#
		#lowers popoulation if there is bottleneck, otherwise models reproduction#
		if (N[i+1]==Nmin) {#
		  #takes the previous generation population and randomly selects sample (number = Nmin)#
		  #sets all dead/potential individuals to NA#
		  current.pop[-sample(N[i],Nmin),]<-NA#
		  #stack live individuals on top of NA #
		  pops[i+1,,]<-rbind(current.pop[which(!is.na(current.pop[,1])),],current.pop[which(is.na(current.pop[,1])),])#
		} else {#
		  # reproduction (including drift):#
		  # weighted sampling, higher fitness individuals more likely to copy themselves#
		  # sampling previous gen to get current gen #
		  pops[i+1,,][1:N[i+1],]<-current.pop[sample(N[i],N[i+1],replace=TRUE,prob=current.pop[,"fitness"][which(!is.na(current.pop[,"fitness"]))]),][1:N[i+1],]#
		}#
		print(exp(log(pops[i+1,,"mu"][1:N[i+1]])))#
		print(rnorm(N[i+1],0,mu.sd))#
	 #pops[i+1,,"mu"][1:N[i+1]] <- exp(log(pops[i+1,,"mu"][1:N[i+1]])) + rnorm(N[i+1],0,mu.sd)#
	}#
	return(pops)#
}#
#
# calculates population size of current generation and adds to vector, N #
# models bottlenecks and population growth #
populationsize <- function(K, tmax, bint, Nmin, N0){#
  N=c(N0)#
  for (i in 1:tmax){#
    if (i %% bint == 0){#
      N[i+1] <- Nmin #
    } else {#
      N[i+1] <- 2*N[i]*(1-(N[i]/K))#
    }#
  }#
  return(round(N))#
}#
#
# helper function to calculate the frequency of a genotype with a certain mutation rate:#
# y axis#
mutator.freq<-function(pop,mu)#
{#
	population<-pop[,"mu"][which(!is.na(pop[,"mu"]))]#
	return(length(which(population==mu))/length(population))#
}#
#
sim.run<-mutation.simulator()#
plot(apply(sim.run,1,mutator.freq,mu=0.01),type="l",xlab="Generation",ylab="Frequency of anti-mutator")
sim.run
sim.run[1,,]
sim.run[1,,1]
sim.run[,1,]
sim.run[,,1]
sim.run[,,1][1]
sim.run[,,1]
sim.run[1,,1]
mean(sim.run[1,,1])
mean(sim.run[1,,1], na.rm=TRUE)
matrix(NA, nrow=length(replicates), ncol=1000)
?quantile
quantile(x <- rnorm(1001))
quantile(x <- rnorm(1001))[2:4]
quantile(x <- rnorm(1001), na.rm=TRUE)[2:4]
?polygon
?rev
?polygon
polygon(x=c(1:3, 3,2,1), y=rep(2,6), col="blue")
plot(NA, ylim-c)
polygon(x=c(1:3, 3,2,1), y=c(2,2,2,3,3,3), col="blue")
plot(NA, ylim=c(0,4), x=c(1,3))
plot(NA, ylim=c(0,4), xlim=c(1,3))
polygon(x=c(1:3, 3,2,1), y=c(2,2,2,3,3,3), col="blue")
mine_sweeper <- function(width = 10, height = 10, mines = 20, cheat = FALSE) {#
  # Deal with some exceptions#
  if (!interactive()) return()#
  if (mines >= width * height) {#
    stop("Are you a terrorist??? Too many mines!")#
  }#
  if (width <= 0 | height <= 0 | mines <= 0) {#
    stop("width, height and mines should be positive!")#
  }#
  width <- floor(width)#
  height <- floor(height)#
  mines <- floor(mines)#
#
  m <- rep(0, width * height)#
  # Status: 0 for untested areas, 1 for tested areas, 2 for flags#
  mat.status <- matrix(m, height, width)#
  mine.index <- sample(width * height, mines)#
  m[mine.index] <- -10#
  mine.mat <- matrix(m, height, width)#
  search.mine <- which(mine.mat < 0, arr.ind = TRUE)#
  mine.row <- search.mine[, 1]#
  mine.col <- search.mine[, 2]#
  # Calculate the number of mines in every 3x3 square#
  for (i in 1:mines) {#
    mrow <- intersect(1:height, (mine.row[i] - 1):(mine.row[i] + 1))#
    mcol <- intersect(1:width, (mine.col[i] - 1):(mine.col[i] + 1))#
    mine.mat[mrow, mcol] <- mine.mat[mrow, mcol] + 1#
  }#
  mine.mat <- ifelse(mine.mat < 0, -1, mine.mat)#
  # -1 for mines#
  if (cheat) print(mine.mat)#
#
  # Plot a grid#
  plot.grid <- function(x, y, w = 1, h = 1, col1 = "#D6E3F0", col2 = "#92B0CA", slices = 10) {#
    # Generate contiguous colors#
    f <- colorRampPalette(c(col1, col2))#
    cols <- f(slices)#
    xs <- rep(x, slices)#
    ys <- seq(y + 0.5 * h - 0.5 * h / slices, y - 0.5 * h + 0.5 * h / slices,#
              length.out = slices)#
    gwidth <- rep(w, slices)#
    gheight <- rep(h / slices, slices)#
    # Rectangles with contiguous colors#
    symbols(xs, ys, rectangles = cbind(gwidth, gheight), fg = cols, bg = cols,#
            inches = FALSE, add = TRUE)#
    #         polygon(x + c(-0.5, -0.5, -0.45) * w,#
    #                 y + c(0.45, 0.5, 0.5) * h,#
    #                 border = NA, col = "#DDDDDD")#
    #         polygon(x + c(0.45, 0.5, 0.5) * w,#
    #                 y + c(0.5, 0.5, 0.45) * h,#
    #                 border = NA, col = "#DDDDDD")#
    #         polygon(x + c(-0.5, -0.5, -0.45) * w,#
    #                 y + c(-0.5, -0.45, -0.5) * h,#
    #                 border = NA, col = "#DDDDDD")#
    #         polygon(x + c(0.45, 0.5, 0.5) * w,#
    #                 y + c(-0.5, -0.45, -0.5) * h,#
    #                 border = NA, col = "#DDDDDD")#
    #         polygon(x + c(-0.5, -0.45, 0.45, 0.5, 0.5, 0.45, -0.45, -0.5) * w,#
    #                 y + c(0.45, 0.5, 0.5, 0.45, -0.45, -0.5, -0.5, -0.45) * h,#
    #                 border = "#777777", lwd = 1)#
    # Border#
    polygon(x + c(-0.5, -0.5, 0.5, 0.5) * w, y + c(-0.5, 0.5, 0.5, -0.5) * h,#
            border = "#777777")#
  }#
#
  # Plot the interface#
  par(mar = c(0, 0, 0, 0), bg = "#DDDDDD")#
  plot(1, type = "n", asp = 1, xlab = "", ylab = "",#
       xlim = c(0.5, width + 0.5), ylim = c(0.5, height + 0.5), axes = FALSE)#
  # Set font for X11 device#
  if(.Device == "X11") {#
    fixed <- X11Font("-*-fixed-*-*-*-*-*-*-*-*-*-*-*-*")#
    X11Fonts(fixed = fixed)#
    par(family = "fixed")#
  }#
  x.grid <- (width + 1) / 2#
  y.grid <- 1:height#
  for (i in 1:height)  plot.grid(x.grid, y.grid[i], w = width, h = 1)#
  x0 <- x1 <- seq(1.5, by = 1, length.out = width - 1)#
  y0 <- rep(0.5, width - 1)#
  y1 <- y0 + height#
  segments(x0, y0, x1, y1, col = "#777777")#
#
  # Colors to draw numbers#
  col.palette <- c("DarkBlue", "ForestGreen", "brown", "green",#
                   "blue", "yellow", "orange", "red")#
  # Function to determine the font size of numbers#
  text.cex <- function() {#
    ps <- par("ps")#
    0.6 * min(dev.size(units = "px") / c(width, height)) / ps#
  }#
  # Plot numbers -- vectorized#
  plot.num <- function(x, y, num) {#
    for(i in 1:length(x))  plot.grid(x[i], y[i], col1 = "#FFFFFF", col2 = "#C8C8C8")#
    pnum = num[num > 0]#
    px = x[num > 0]#
    py = y[num > 0]#
    text(px, py, pnum, col = col.palette[pnum], cex = text.cex())#
  }#
  # Draw unexploded mines -- vectorized#
  plot.mine <- function(x, y) {#
    for(i in 1:length(x))  plot.grid(x[i], y[i], col1 = "#FFFFFF", col2 = "#C8C8C8")#
    symbols(x, y, circles = rep(0.35, length(x)),#
            inches = FALSE, fg = NULL, bg = "black", add = TRUE)#
    op = par(lend = 2)#
    segments(x - 0.4, y, x + 0.4, y, col = "black", lwd = 5)#
    segments(x, y - 0.4, x, y + 0.4, col = "black", lwd = 5)#
    d = 0.4 / sqrt(2)#
    segments(x - d, y - d, x + d, y + d, col = "black", lwd = 5)#
    segments(x - d, y + d, x + d, y - d, col = "black", lwd = 5)#
  }#
  # Draw the exploded mine#
  plot.mine.explode <- function(x, y) {#
    plot.grid(x, y, col1 = "#FFFFFF", col2 = "#C8C8C8")#
    star <- t(matrix(c(0.3, 0.4), 20, length(x)))#
    symbols(x, y, stars = star, inches = FALSE, bg = "red", fg = NA, add = TRUE)#
    symbols(x, y, stars = 0.7 * star, inches = FALSE, bg = "yellow", fg = NA, add = TRUE)#
  }#
  # Draw flags -- vectorized#
  plot.flag <- function(x, y) {#
    symbols(x + 0.075, y + 0.2,#
            rectangles = matrix(rep(c(0.35, 0.2), rep(length(x), 2)), ncol = 2),#
            inches = FALSE, fg = "red", bg = "red", add = TRUE)#
    symbols(x, y - 0.25,#
            rectangles = matrix(rep(c(0.6, 0.1), rep(length(x), 2)), ncol = 2),#
            inches = FALSE, fg = "black", bg = "black", add = TRUE)#
    segments(x - 0.1, y + 0.3, x - 0.1, y - 0.2)#
  }#
  search.zeroes <- function(pos, mat) {#
    nr <- nrow(mat)#
    nc <- ncol(mat)#
    x <- ifelse(pos %% nr == 0, nr, pos %% nr)#
    y <- ceiling(pos / nr)#
    areas <- c(pos, (x > 1 & y > 1) * (pos - nr - 1), (y > 1) * (pos - nr),#
               (x < nr & y > 1) * (pos - nr + 1), (x > 1) * (pos - 1),#
               (x < nr) * (pos + 1), (x > 1 & y < nc) * (pos + nr - 1),#
               (y < nc) * (pos + nr), (x < nr & y < nc) * (pos + nr + 1))#
    areas <- unique(areas[areas != 0])#
    zeroes <- intersect(areas, which(mat == 0))#
    return(list(zeroes = zeroes, areas = areas))#
  }#
#
  mousedown <- function(buttons, x, y) {#
    ## At least under Ubuntu, right click leads to buttons = c(0, 1)#
    if (length(buttons) == 2) buttons <- 2#
    plx <- round(grconvertX(x, "ndc", "user"))#
    ply <- round(grconvertY(y, "ndc", "user"))#
    ms <- mat.status#
    if (plx < 1 || plx > width || ply < 1 || ply > height || buttons == 1) {#
      return(ms)#
    }#
    current.status <- ms[height + 1 - ply, plx]#
    current.mat <- mine.mat[height + 1 - ply, plx]#
    ## Left button#
    if (buttons == 0) {#
      ## Untested area#
      if (current.status == 0) {#
        ## Is a mine#
        if (current.mat == -1) {#
          plot.mine(mine.col, height + 1 - mine.row)#
          plot.mine.explode(plx, ply)#
          cat("Game Over!\n")#
          return(-1)#
          ## Blank area#
        } else if (current.mat == 0) {#
          pos <- height * plx + 1 - ply#
          while (TRUE) {#
            temp <- pos#
            lst <- search.zeroes(pos, mine.mat)#
            pos <- lst$zeroes#
            if (length(pos) == length(temp)) {#
              areas <- lst$areas#
              areas.row <- ifelse(areas %% height == 0, height, areas %% height)#
              areas.col <- ceiling(areas / height)#
              plot.num(areas.col, height + 1 - areas.row, mine.mat[areas])#
              ms[areas] <- 1#
              break#
            }#
          }#
          if (sum(ms == 1) == width * height - mines) {#
            plot.flag(mine.col, height + 1 - mine.row)#
            cat("You win!\n")#
            return(1)#
          }#
          return(ms)#
          ## Numbered area#
        } else {#
          plot.num(plx, ply, current.mat)#
          if (sum(ms == 1) == width * height - mines -1) {#
            plot.flag(mine.col, height + 1 - mine.row)#
            cat("You win!\n")#
            return(1)#
          }#
          ms[height + 1 - ply, plx] <- 1#
          return(ms)#
        }#
        ## Tested area or flag -- no action#
      } else {#
        return(ms)#
      }#
    }#
    ## Right button#
    if (buttons == 2) {#
      ## Blank area#
      if (current.status == 0) {#
        ms[height + 1 - ply, plx] <- 2#
        plot.flag(plx, ply)#
        return(ms)#
        ## Flag#
      } else if (current.status == 2) {#
        ms[height + 1 - ply, plx] <- 0#
        plot.grid(plx, ply)#
        return(ms)#
        ## Numbered area -- no action#
      } else {#
        return(ms)#
      }#
    }#
    return(ms)#
  }#
#
  while (TRUE) {#
    if (length(mat.status) == 1) break#
    mat.status <- getGraphicsEvent(prompt = "", onMouseDown = mousedown)#
  }#
}#
 2018 GitHub, Inc.#
Terms#
Privacy#
Security#
Status#
Help#
Contact GitHub#
API#
Training#
Shop#
Blog#
About
?sample
library(devtools)
devtools::install_github("JanEngelstaedter/cophy")
lib
library(cophy)
rcophylo_HP(tmax=5, k=5)
# Exploration C7#
# Specialist#
load('/Volumes/NicoleWork/Exploration C/ExplorationC7/Exploration C7 screen gamma-0.08, nu-0.75, sigma-0.RData')#
#
Survived<-which(output$statistics[,"NoPspecies"]>0)#
#
tmax   <-output$parameters[[1]]#
startT <-output$parameters[[2]]#
dt     <-0.5#
#
timepoints <-seq(startT, tmax, dt)#
#
BTT.specialist    <-matrix(NA, nrow=length(Survived), ncol=length(timepoints))#
colnames(BTT.specialist) <- timepoints#
rownames(BTT.specialist) <-paste("Ptree", Survived)#
#
for (i in 1:length(Survived)) {#
	BTT.specialist[i,]<-get_branchNThroughTime(phy=output$Ptrees[[Survived[i]]], tmax=tmax, startT=startT, dt=dt)#
}#
#
poly.specialist<-matrix(ncol=4*length(Survived))  #
#
for (i in 1:ncol(poly.specialist)) {#
	poly.specialist[1,i]<-quantile(BTT.specialist[,i], prob=0.05)#
	poly.specialist[2,i]<-quantile(BTT.specialist[,i], prob=0.25)#
	poly.specialist[3,i]<-quantile(BTT.specialist[,i], prob=0.5)#
	poly.specialist[4,i]<-quantile(BTT.specialist[,i], prob=0.75)#
	poly.specialist[5,i]<-quantile(BTT.specialist[,i], prob=0.95)#
}
BTT.specialist
# Specialist#
load('/Volumes/NicoleWork/Exploration C/ExplorationC7/Exploration C7 screen gamma-0.08, nu-0.75, sigma-0.RData')#
#
Survived<-which(output$statistics[,"NoPspecies"]>0)#
#
tmax   <-output$parameters[[1]]#
startT <-output$parameters[[2]]#
dt     <-0.5#
#
timepoints <-seq(startT, tmax, dt)#
#
BTT.specialist    <-matrix(NA, nrow=length(Survived), ncol=length(timepoints))#
colnames(BTT.specialist) <- timepoints#
rownames(BTT.specialist) <-paste("Ptree", Survived)#
#
for (i in 1:length(Survived)) {#
	BTT.specialist[i,]<-get_branchNThroughTime(phy=output$Ptrees[[Survived[i]]], tmax=tmax, startT=startT, dt=dt)#
}
get_branchNThroughTime <- function(phy, tmax, startT=0, dt) {#
  btt              <- rep(NA, length(seq(startT, tmax, by = dt)))#
  timepoints       <- seq(startT, tmax, by = dt)#
  names(btt)       <- timepoints#
  branchtimes      <- matrix(NA, ncol = 2, nrow = length(phy$edge[, 1]) + 1)#
  branchtimes[1, ] <- c(0, phy$root.edge)#
#
  if (length(phy$edge[, 1]) > 0) {#
    branchtimes[2, ] <- c(phy$root.edge, phy$root.edge + phy$edge.length[1])#
    branchtimes[3, ] <- c(phy$root.edge, phy$root.edge + phy$edge.length[2])#
  }#
#
  if (length(phy$edge[, 1]) > 2) {#
    for (i in 3:length(phy$edge[, 1])) {#
      motherbranch          <- which(phy$edge[, 2] == phy$edge[i, 1])#
      branchtimes[i + 1, 1] <- branchtimes[motherbranch + 1, 2]#
      branchtimes[i + 1, 2] <- branchtimes[i + 1, 1] + phy$edge.length[i]#
    }#
  }#
#
  branchtimes <- branchtimes + startT#
#
  for (i in 1:length(btt)) {#
    btt[i] <- sum((timepoints[i] >= branchtimes[, 1]) & (timepoints[i] <= branchtimes[, 2]))#
  }#
  return(btt)#
}
# Specialist#
load('/Volumes/NicoleWork/Exploration C/ExplorationC7/Exploration C7 screen gamma-0.08, nu-0.75, sigma-0.RData')#
#
Survived<-which(output$statistics[,"NoPspecies"]>0)#
#
tmax   <-output$parameters[[1]]#
startT <-output$parameters[[2]]#
dt     <-0.5#
#
timepoints <-seq(startT, tmax, dt)#
#
BTT.specialist    <-matrix(NA, nrow=length(Survived), ncol=length(timepoints))#
colnames(BTT.specialist) <- timepoints#
rownames(BTT.specialist) <-paste("Ptree", Survived)#
#
for (i in 1:length(Survived)) {#
	BTT.specialist[i,]<-get_branchNThroughTime(phy=output$Ptrees[[Survived[i]]], tmax=tmax, startT=startT, dt=dt)#
}
poly.specialist<-matrix(ncol=4*length(Survived))  #
#
for (i in 1:ncol(poly.specialist)) {#
	poly.specialist[1,i]<-quantile(BTT.specialist[,i], prob=0.05)#
	poly.specialist[2,i]<-quantile(BTT.specialist[,i], prob=0.25)#
	poly.specialist[3,i]<-quantile(BTT.specialist[,i], prob=0.5)#
	poly.specialist[4,i]<-quantile(BTT.specialist[,i], prob=0.75)#
	poly.specialist[5,i]<-quantile(BTT.specialist[,i], prob=0.95)#
}
rcophylo_PQonH <- function(tmax, H.tree, beta = 0.1, gamma.P = 0.02, gamma.Q = 0.02,#
                           sigma.self = 0, sigma.cross = 0, nu.P = 0.5, nu.Q = 0.5,#
                           kappa.P = 0, kappa.Q = 0, delta.P = 0, delta.Q = 0,#
                           prune.extinct = FALSE, export.format = "Phylo", P.startT = 0,#
                           Q.startT = 0, P.ini.Hbranch = NA, Q.ini.Hbranch = NA, #
                           Gdist = NA, timestep = 0.001) {#
#
  # adjusting the evolutionary rates to timesteps:#
  nu.P		<- nu.P * timestep#
  nu.Q		<- nu.Q * timestep#
  beta		<- beta * timestep#
  kappa.P	<- kappa.P * timestep#
  kappa.Q	<- kappa.Q * timestep#
#
  # Set beginning for P simulation#
  startT <- max(P.startT, Q.startT)#
#
  HBranches <- H.tree[which(H.tree$tDeath >= startT & H.tree$tBirth <= startT), ]  # which host branches are alive at invasion time T?#
#
  if (is.na(P.ini.Hbranch))  { # no initial host branch specified --> choose random branch#
    P.PstartHassoc <- sample(HBranches$branchNo, 1) # HBranch that P invasion will start from#
  } else {#
  	P.PstartHassoc <- P.ini.Hbranch # HBranch that invasion will start from#
  }	#
  if (is.na(Q.ini.Hbranch))  { # no initial host branch specified --> choose random branch#
    Q.PstartHassoc <- sample(HBranches$branchNo, 1) # HBranch that Q invasion will start from#
  } else {#
    Q.PstartHassoc <- Q.ini.Hbranch # HBranch that invasion will start from#
  }#
  P.PBranches <- data.frame(alive = TRUE, nodeBirth = 0, tBirth = P.startT, nodeDeath = 0,#
                            tDeath = 0, Hassoc = P.PstartHassoc, branchNo = 1)#
#
  P.nPBranches <- 1	 # total number of branches that have been constructed#
  P.nPAlive    <- 1	 # number of branches that extend until the current timestep#
  P.nextPNode  <- 1 # number of the next node to be produced#
#
  P.PDeadBranches	 <- data.frame(alive = rep(FALSE, DBINC), nodeBirth = 0, tBirth = 0,#
                                 nodeDeath = 0, tDeath = 0, Hassoc = 0, branchNo = 0)#
  P.nPDeadBranches <- 0 # number of dead parasite branches#
#
  Q.PBranches      <- data.frame(alive = TRUE, nodeBirth = 0, tBirth = Q.startT, nodeDeath = 0,#
                            tDeath = 0, Hassoc = Q.PstartHassoc, branchNo = 1)#
#
  Q.nPBranches <- 1 # total number of branches that have been constructed#
  Q.nPAlive    <- 1 # number of branches that extend until the current timestep#
  Q.nextPNode  <- 1 # number of the next node to be produced#
#
  Q.PDeadBranches	 <- data.frame(alive = rep(FALSE, DBINC), nodeBirth = 0, tBirth = 0,#
                                 nodeDeath = 0, tDeath = 0, Hassoc = 0, branchNo = 0)#
  Q.nPDeadBranches <- 0 # number of dead parasite branches#
#
  if (any(is.na(Gdist))) {#
    Gdist <- get_GDist(H.tree, t = startT) # initialise matrix that will record the genetic distance between all living hosts at time t#
  }#
#
  HBranchDeathTimes <- sort(H.tree$tDeath[H.tree$tDeath >= startT & H.tree$alive == FALSE])#
  HDeathIndex <- 1#
#
  continue <- TRUE#
  t <- startT#
  while (continue == TRUE) { # continue simulation until continue is set to FALSE#
    # main simulation loop through time#
    t <- t + timestep#
    # update Gdist#
    Gdist <- Gdist + 2 * timestep # add increased distance btw branches#
    diag (Gdist) <- 0  # cleaning up so that distance between branch to itself is always 0#
#
    # Host events:#
    if ((HDeathIndex <= length(HBranchDeathTimes)) & (HBranchDeathTimes[HDeathIndex] >=#
                                                      (t - timestep)) & (HBranchDeathTimes[HDeathIndex] < t)) { # if any host dies w/in interval#
      H.Death	<- which(HBranches$tDeath >= (t - timestep) & HBranches$tDeath < t & HBranches$alive == FALSE) # Any host branch that dies w/in timestep interval leading up to time t#
      HDeathIndex	<- HDeathIndex + length(H.Death)#
#
      for (i in HBranches$nodeDeath[H.Death][order(HBranches$nodeDeath[H.Death])]) { # for each node where a host died#
        # Cospeciation events:#
        if (i %in% H.tree$nodeBirth) {  # Check if host death is due to speciation#
          H.Speciations		 <- which(HBranches$nodeDeath == i) # H row speciating at time t at particular node#
          daughterBranches <- which(H.tree$nodeBirth == i)#
          HBranches        <- rbind(HBranches, H.tree[daughterBranches[1], ])#
          HBranches        <- rbind(HBranches, H.tree[daughterBranches[2], ])#
#
          timepoint        <- HBranches$tDeath[H.Speciations] # use exact time of death as opposed to current time t#
          # update Gdist matrix:#
          # filling in values#
#
          Gdist	<- rbind(Gdist, NA)#
          Gdist	<- rbind(Gdist, NA)#
          Gdist	<- cbind(Gdist, NA)#
          Gdist	<- cbind(Gdist, NA)#
#
          len 	<-length(Gdist[1, ])#
#
          Gdist[len - 1, len]	<- 2 * (t - timepoint)#
          Gdist[len, len - 1]	<- 2 * (t - timepoint)#
#
          Gdist[1:(len - 2), len - 1] <- Gdist[1:(len - 2), H.Speciations]#
          Gdist[1:(len - 2), len]	    <- Gdist[1:(len - 2), H.Speciations]#
          Gdist[len - 1, 1:(len - 2)]	<- Gdist[H.Speciations, 1:(len - 2)]#
          Gdist[len, 1:(len - 2)]	    <- Gdist[H.Speciations, 1:(len - 2)]#
#
          # P cospeciations#
          if (t >= P.startT) { # Only simulate once lineage intruduced#
            P.P.Speciations <- which(P.PBranches$Hassoc %in% HBranches$branchNo[H.Speciations]) # P branches cospeciate at time#
            if (length(P.P.Speciations) > 0) { # make sure argument greater then length 0#
              for(j in P.P.Speciations) {#
                P.PBranches$alive[j]     <-FALSE#
                P.PBranches$nodeDeath[j] <-P.nextPNode#
                P.PBranches$tDeath[j]    <-timepoint#
#
                P.nPDeadBranches <- P.nPDeadBranches + 1#
                P.PDeadBranches[P.nPDeadBranches, ] <- P.PBranches[j, ] # copy branches updated with death info to dead tree#
                if (length(P.PDeadBranches[, 1]) == P.nPDeadBranches) {# if dataframe containing dead branches is full#
                  P.PDeadBranches <- rbind(P.PDeadBranches, data.frame(alive = rep(FALSE, DBINC), nodeBirth = 0,#
                                                                     tBirth = 0, nodeDeath = 0, tDeath = 0,#
                                                                     Hassoc = 0, branchNo = 0))#
                }#
#
                P.PBranches  <- rbind(P.PBranches, c(TRUE, P.nextPNode, timepoint, 0, 0,#
                                                   H.tree$branchNo[daughterBranches[1]], P.nPBranches + 1))#
                P.PBranches  <- rbind(P.PBranches, c(TRUE, P.nextPNode, timepoint, 0, 0,#
                                                   H.tree$branchNo[daughterBranches[2]], P.nPBranches + 2))#
                P.nextPNode  <- P.nextPNode + 1#
                P.nPAlive    <- P.nPAlive + 1#
                P.nPBranches <- P.nPBranches + 2#
              }#
              P.PBranches	<- P.PBranches[-P.P.Speciations, ]  # removing all mother parasite branches that have co-speciated#
              if (delta.P > 0) {  # parasite loss during cospeciation; one of the new branches dies immediately#
                if(runif(1) < delta.P) {#
                  whichBranch <- sample(c(P.nPAlive - 1, P.nPAlive), 1)  # which of the two daughter branches dies?#
#
                  P.PBranches$alive[whichBranch]	   <- FALSE#
                  P.PBranches$nodeDeath[whichBranch] <- P.nextPNode#
                  P.PBranches$tDeath[whichBranch]    <- timepoint#
#
                  P.nPDeadBranches <- P.nPDeadBranches + 1#
                  P.PDeadBranches[P.nPDeadBranches, ]	<- P.PBranches[whichBranch, ] # copy branches updated with death info to dead tree#
                  if (length(P.PDeadBranches[, 1]) == P.nPDeadBranches) {# if dataframe containing dead branches is full#
                    P.PDeadBranches <- rbind(P.PDeadBranches, data.frame(alive = rep(FALSE, DBINC), #
                                             nodeBirth = 0, tBirth = 0, nodeDeath = 0, tDeath = 0, Hassoc = 0, branchNo = 0))#
                  }#
                  P.nextPNode <- P.nextPNode + 1#
                  P.nPAlive		<- P.nPAlive - 1#
                  P.PBranches	<- P.PBranches[-whichBranch, ] # removing dead parasite branche#
                }#
              }#
            }#
          }#
#
          # Q cospeciations#
          if (t >= Q.startT) { # Only simulate once lineage intruduced#
            Q.P.Speciations <- which(Q.PBranches$Hassoc %in% HBranches$branchNo[H.Speciations]) # P branches cospeciate at time#
#
            if (length(Q.P.Speciations) > 0) { # make sure argument greater then length 0#
              for(j in Q.P.Speciations)	{#
                Q.PBranches$alive[j]			<- FALSE#
                Q.PBranches$nodeDeath[j]	<- Q.nextPNode#
                Q.PBranches$tDeath[j]			<- timepoint#
#
                Q.nPDeadBranches		   		<- Q.nPDeadBranches + 1#
                Q.PDeadBranches[Q.nPDeadBranches, ]	<- Q.PBranches[j, ] # copy branches updated with death info to dead tree#
                if (length(Q.PDeadBranches[, 1]) == Q.nPDeadBranches) {# if dataframe containing dead branches is full#
                  Q.PDeadBranches <- rbind(Q.PDeadBranches, data.frame(alive = rep(FALSE, DBINC), #
                                           nodeBirth = 0, tBirth = 0, nodeDeath = 0, tDeath = 0, #
                                           Hassoc = 0, branchNo = 0))#
                }#
#
                Q.PBranches    <-rbind(Q.PBranches, c(TRUE, Q.nextPNode, timepoint, 0, 0,#
                                                    H.tree$branchNo[daughterBranches[1]], Q.nPBranches + 1))#
                Q.PBranches    <-rbind(Q.PBranches, c(TRUE, Q.nextPNode, timepoint, 0, 0,#
                                                    H.tree$branchNo[daughterBranches[2]], Q.nPBranches + 2))#
                Q.nextPNode    <- Q.nextPNode + 1#
                Q.nPAlive      <- Q.nPAlive + 1#
                Q.nPBranches   <- Q.nPBranches + 2#
              }#
              Q.PBranches	<- Q.PBranches[-Q.P.Speciations, ]  # removing all mother parasite branches that have co-speciated#
              if (delta.Q > 0) {  # parasite loss during cospeciation; one of the new branches dies immediately#
                if(runif(1) < delta.Q) {#
                  whichBranch <- sample(c(Q.nPAlive - 1, Q.nPAlive), 1)  # which of the two daughter branches dies?#
#
                  Q.PBranches$alive[whichBranch]	   <- FALSE#
                  Q.PBranches$nodeDeath[whichBranch] <- Q.nextPNode#
                  Q.PBranches$tDeath[whichBranch]    <- timepoint#
#
                  Q.nPDeadBranches <- Q.nPDeadBranches + 1#
                  Q.PDeadBranches[Q.nPDeadBranches, ] <-Q.PBranches[whichBranch, ] # copy branches updated with death info to dead tree#
                  if (length(Q.PDeadBranches[, 1]) == Q.nPDeadBranches) {# if dataframe containing dead branches is full#
                    Q.PDeadBranches <- rbind(P.PDeadBranches, data.frame(alive = rep(FALSE, DBINC),                           #
                                             nodeBirth = 0, tBirth = 0,nodeDeath = 0, tDeath = 0, #
                                             Hassoc = 0, branchNo = 0))#
                  }#
                  Q.nextPNode <- Q.nextPNode + 1#
                  Q.nPAlive		<- Q.nPAlive - 1#
                  Q.PBranches	<- Q.PBranches[-whichBranch, ] # removing dead parasite branche#
                }#
              }#
            }#
#
            # delete all extinct hosts from living tree#
            HBranches	<- HBranches[-H.Speciations, ]#
#
            Gdist	<- Gdist[-H.Speciations, ]  # removing all host mother branches that have speciated#
            Gdist	<- Gdist[, -H.Speciations]#
          } else { # is an extinction event#
            H.Extinctions	<- which(HBranches$nodeDeath == i) # H branch extinct at time t at particular node#
          }#
#
          # P coextinctions#
          if (t >= P.startT) {#
            P.P.Extinctions	<- which(P.PBranches$Hassoc %in% HBranches$branchNo[H.Extinctions]) # P branches coextinct at time t#
            if (length(P.P.Extinctions) > 0) {# make sure there is an associated P that goes extinct#
#
            for (j in P.P.Extinctions) {#
              timepoint			   				 <- HBranches$tDeath[H.Extinctions]#
#
              P.PBranches$alive[j]	   <- FALSE#
              P.PBranches$nodeDeath[j] <- P.nextPNode#
              P.PBranches$tDeath[j]    <- timepoint#
#
              P.nPDeadBranches		   	 <- P.nPDeadBranches + 1#
              P.PDeadBranches[P.nPDeadBranches,] <-P.PBranches[j, ] # copy branches updated with death info to dead tree#
              if (length(P.PDeadBranches[, 1]) == P.nPDeadBranches) {# if dataframe containing dead branches is full#
                P.PDeadBranches <- rbind(P.PDeadBranches, data.frame(alive = rep(FALSE, DBINC), nodeBirth = 0, tBirth = 0,#
                                                                     nodeDeath = 0, tDeath = 0, Hassoc = 0, branchNo = 0))#
              }#
#
              P.nextPNode <- P.nextPNode + 1#
              P.nPAlive		<- P.nPAlive - 1#
            }#
            P.PBranches <- P.PBranches[-P.P.Extinctions, ] # delete all branches associated with extinct host from living tree#
          }#
          }#
#
          # Q coextinctions#
          if (t >= Q.startT) {#
            Q.P.Extinctions	<- which(Q.PBranches$Hassoc %in% HBranches$branchNo[H.Extinctions]) # P branches coextinct at time t#
            if (length(Q.P.Extinctions) > 0) {# make sure there is an associated P that goes extinct#
#
            for (j in Q.P.Extinctions) {#
              timepoint                <- HBranches$tDeath[H.Extinctions]#
#
              Q.PBranches$alive[j]	   <- FALSE#
              Q.PBranches$nodeDeath[j] <- Q.nextPNode#
              Q.PBranches$tDeath[j]    <- timepoint#
#
              Q.nPDeadBranches		   	 <- Q.nPDeadBranches + 1#
              Q.PDeadBranches[Q.nPDeadBranches, ] <-Q.PBranches[j, ] # copy branches updated with death info to dead tree#
              if (length(Q.PDeadBranches[, 1]) == Q.nPDeadBranches) {# if dataframe containing dead branches is full#
                Q.PDeadBranches <- rbind(Q.PDeadBranches, data.frame(alive = rep(FALSE, DBINC), nodeBirth = 0, tBirth = 0,#
                                                                     nodeDeath = 0, tDeath = 0, Hassoc = 0, branchNo = 0))#
              }#
#
              Q.nextPNode	<- Q.nextPNode + 1#
              Q.nPAlive		<- Q.nPAlive - 1#
            }#
            Q.PBranches <- Q.PBranches[-Q.P.Extinctions, ] # delete all branches associated with extinct host from living tree#
          }#
          }#
#
          # removing all host mother branches that have died#
          HBranches	<- HBranches[-H.Extinctions, ] # delete all extinct hosts from living tree#
#
          Gdist	<- Gdist[-H.Extinctions, , drop = FALSE] # drop=FALSE is needed to avoid conversion to vector when Gdist is 2x2!#
          Gdist	<- Gdist[, -H.Extinctions, drop = FALSE]#
#
        } # completed speciation/extinction loops#
#
      } # completed loop through H.Death.Nodes#
#
    } # finished checking if any H deaths occured#
#
    # parasite speciation (independent of hosts)#
    if (t >= P.startT) {#
      if (kappa.P > 0) {#
      P.nPToSpeciate <- rbinom(1, P.nPAlive, kappa.P) # how many parasite species go extinct?#
    } else {#
      P.nPToSpeciate <- 0#
    }#
#
      if (P.nPToSpeciate > 0) {#
      P.PToSpeciate <- sample.int(P.nPAlive, P.nPToSpeciate) # which parasites?#
      P.PToSpeciate <- P.PToSpeciate[P.PBranches$tBirth[P.PToSpeciate] < (t - timestep)] # remove those that have just arisen in the same timestep; this is necessary to avoid problems such as negative branch lenghts#
#
      for (i in P.PToSpeciate) {#
        timepoint	               <- t - runif(1, max = timestep) # random timepoint for extinction event#
        P.PBranches$alive[i]	   <- FALSE#
        P.PBranches$nodeDeath[i] <- P.nextPNode#
        P.PBranches$tDeath[i]    <- timepoint#
#
        P.nPDeadBranches		     <- P.nPDeadBranches + 1#
        P.PDeadBranches[P.nPDeadBranches, ] <- P.PBranches[i, ] # copy branches updated with death info to dead tree#
        if (length(P.PDeadBranches[, 1]) == P.nPDeadBranches) {# if dataframe containing dead branches is full#
          P.PDeadBranches <- rbind(P.PDeadBranches, data.frame(alive = rep(FALSE, DBINC), nodeBirth = 0, tBirth = 0,#
                                                               nodeDeath = 0, tDeath = 0, Hassoc = 0, branchNo = 0))#
        }#
#
        P.PBranches  <- rbind(P.PBranches, c(TRUE, P.nextPNode, timepoint, 0, 0, P.PBranches$Hassoc[i], P.nPBranches + 1))#
        P.PBranches  <- rbind(P.PBranches, c(TRUE, P.nextPNode, timepoint, 0, 0, P.PBranches$Hassoc[i], P.nPBranches + 2))#
        P.nextPNode  <- P.nextPNode + 1#
        P.nPAlive    <- P.nPAlive + 1#
        P.nPBranches <- P.nPBranches + 2#
      }#
      if (length(P.PToSpeciate) > 0)#
        P.PBranches <- P.PBranches[-P.PToSpeciate, ] # removing all dead parasite branches#
    }#
#
      # P parasite extinction:#
      P.nPToDie	<- rbinom(1, P.nPAlive, nu.P) # how many parasite species go extinct?#
#
      if (P.nPToDie > 0) {#
      P.PToDie <- sample.int(P.nPAlive, P.nPToDie) # which parasites?#
      P.PToDie <- P.PToDie[P.PBranches$tBirth[P.PToDie] < (t - timestep)] # remove those that have just arisen in the same timestep; this is necessary to avoid problems such as negative branch lenghts#
#
      for (i in P.PToDie) {#
        timepoint	               <- t - runif(1, max = timestep) # random timepoint for extinction event#
        P.PBranches$alive[i]		 <- FALSE#
        P.PBranches$nodeDeath[i] <- P.nextPNode#
        P.PBranches$tDeath[i]		 <- timepoint#
#
        P.nPDeadBranches			   <- P.nPDeadBranches + 1#
        P.PDeadBranches[P.nPDeadBranches, ] <- P.PBranches[i, ] # copy branches updated with death info to dead tree#
        if (length(P.PDeadBranches[, 1]) == P.nPDeadBranches) {# if dataframe containing dead branches is full#
          P.PDeadBranches <- rbind(P.PDeadBranches, data.frame(alive = rep(FALSE, DBINC), nodeBirth = 0, tBirth = 0,#
                                                               nodeDeath = 0, tDeath = 0, Hassoc = 0, branchNo = 0))#
        }#
        P.nextPNode	<- P.nextPNode + 1#
        P.nPAlive		<- P.nPAlive - 1#
      }#
      if (length(P.PToDie) > 0) {#
        P.PBranches <- P.PBranches[-P.PToDie, ] # removing all dead parasite branches#
      }#
    }#
    }#
#
    # parasite speciation (independent of hosts)#
    if (t >= Q.startT) {#
      if (kappa.Q > 0) {#
      Q.nPToSpeciate <- rbinom(1, Q.nPAlive, kappa.Q) # how many parasite species go extinct?#
    } else {#
      Q.nPToSpeciate <- 0#
    }#
#
      if (Q.nPToSpeciate > 0) {#
      Q.PToSpeciate <- sample.int(Q.nPAlive, Q.nPToSpeciate) # which parasites?#
      Q.PToSpeciate <- Q.PToSpeciate[Q.PBranches$tBirth[Q.PToSpeciate] < (t - timestep)] # remove those that have just arisen in the same timestep; this is necessary to avoid problems such as negative branch lenghts#
#
      for (i in Q.PToSpeciate) {#
        timepoint                <- t - runif(1, max = timestep) # random timepoint for extinction event#
        Q.PBranches$alive[i]	   <- FALSE#
        Q.PBranches$nodeDeath[i] <- Q.nextPNode#
        Q.PBranches$tDeath[i]    <- timepoint#
#
        Q.nPDeadBranches		     <- Q.nPDeadBranches + 1#
        Q.PDeadBranches[Q.nPDeadBranches, ] <- Q.PBranches[i, ] # copy branches updated with death info to dead tree#
        if (length(Q.PDeadBranches[, 1]) == Q.nPDeadBranches) {# if dataframe containing dead branches is full#
          Q.PDeadBranches <- rbind(Q.PDeadBranches, data.frame(alive = rep(FALSE, DBINC), nodeBirth = 0, tBirth = 0,#
                                                               nodeDeath = 0, tDeath = 0, Hassoc = 0, branchNo = 0))#
        }#
#
        Q.PBranches  <- rbind(Q.PBranches, c(TRUE, Q.nextPNode, timepoint, 0, 0, Q.PBranches$Hassoc[i], Q.nPBranches + 1))#
        Q.PBranches  <- rbind(Q.PBranches, c(TRUE, Q.nextPNode, timepoint, 0, 0, Q.PBranches$Hassoc[i], Q.nPBranches + 2))#
        Q.nextPNode  <- Q.nextPNode + 1#
        Q.nPAlive    <- Q.nPAlive + 1#
        Q.nPBranches <- Q.nPBranches + 2#
      }#
      if (length(Q.PToSpeciate) > 0) {#
        Q.PBranches <- Q.PBranches[-Q.PToSpeciate, ] # removing all dead parasite branches#
      }#
    }#
#
      # Q parasite extinction:#
      Q.nPToDie	<- rbinom(1, Q.nPAlive, nu.Q) # how many parasite species go extinct?#
#
      if (Q.nPToDie > 0) {#
      Q.PToDie <- sample.int(Q.nPAlive, Q.nPToDie) # which parasites?#
      Q.PToDie <- Q.PToDie[Q.PBranches$tBirth[Q.PToDie] < (t - timestep)] # remove those that have just arisen in the same timestep; this is necessary to avoid problems such as negative branch lenghts#
#
      for (i in Q.PToDie) {#
        timepoint                <- t - runif(1, max = timestep) # random timepoint for extinction event#
        Q.PBranches$alive[i]		 <- FALSE#
        Q.PBranches$nodeDeath[i] <- Q.nextPNode#
        Q.PBranches$tDeath[i]		 <- timepoint#
#
        Q.nPDeadBranches			   <- Q.nPDeadBranches + 1#
        Q.PDeadBranches[Q.nPDeadBranches, ] <- Q.PBranches[i, ] # copy branches updated with death info to dead tree#
        if (length(Q.PDeadBranches[, 1]) == Q.nPDeadBranches) {# if dataframe containing dead branches is full#
          Q.PDeadBranches <- rbind(Q.PDeadBranches, data.frame(alive = rep(FALSE, DBINC), nodeBirth = 0, tBirth = 0,#
                                                               nodeDeath = 0, tDeath = 0, Hassoc = 0, branchNo = 0))#
        }#
#
        Q.nextPNode	<- Q.nextPNode + 1#
        Q.nPAlive		<- Q.nPAlive - 1#
      }#
      if (length(Q.PToDie) > 0) {#
        Q.PBranches <- Q.PBranches[-Q.PToDie, ] # removing all dead parasite branches#
      }#
    }#
    }#
#
    # parasite host jumps:#
    nHAlive			 <- length(HBranches[, 1])#
    hostJumpProb <- beta * (nHAlive - 1)#
#
    if (hostJumpProb > 1) {#
      print("Warning: host jump probability > 1!")#
      hostJumpProb <- 1#
    }#
#
    # P parasite host-jumps#
    if (t >= P.startT) {#
      P.noParasitesToJump	<- rbinom(1, P.nPAlive, beta * nHAlive)#
#
      if (P.noParasitesToJump > 0) {#
      P.parasitesToJump		<- sample.int(P.nPAlive, P.noParasitesToJump) # which parasites#
      P.parasitesToJump		<- P.parasitesToJump[P.PBranches$tBirth[P.parasitesToJump] < (t-timestep)] # remove those that have just arisen in the same timestep; this is necessary to avoid problems such as negative branch lenghts#
      P.parasitesToDelete <- numeric(0)  # this will become the vector of row numbers for rows to be deleted from PBranches afterwards#
#
      for (i in P.parasitesToJump) {#
        P.oldHost <- which(HBranches$branchNo == P.PBranches$Hassoc[i])   # row number of old host#
        P.otherHosts <- (1:nHAlive)[-P.oldHost]  # row numbers of all living hosts except the original one#
#
        if(length(P.otherHosts) > 0) {#
          newHost           <- P.otherHosts[sample.int(length(P.otherHosts), 1)]  # randomly choose branch number of new host#
          P.probEstablish   <- (exp(-gamma.P * Gdist[P.oldHost, newHost])) # determine if Parasite switch to new host is successful,depending on genetic distance#
          P.estabInfections <- length(which(P.PBranches$Hassoc == HBranches$branchNo[newHost]))  # no of parasites already infecting the potential new host#
          Q.estabInfections <- length(which(Q.PBranches$Hassoc == HBranches$branchNo[newHost]))  # no of parasites already infecting the potential new host#
          P.probEstablish   <- P.probEstablish * (sigma.self^P.estabInfections) * (sigma.cross^Q.estabInfections) # determine if parasite switch to new host is successful, depending on genetic distance and new host infection status#
#
          if(runif(1) < P.probEstablish) {# if host jump was successful#
            timepoint                <- t - runif(1, max = timestep) # random timepoint for jump#
            P.PBranches$nodeDeath[i] <- P.nextPNode#
            P.PBranches$tDeath[i]    <- timepoint#
            P.PBranches$alive[i]     <- FALSE#
#
            P.nPDeadBranches				 <- P.nPDeadBranches + 1#
            P.PDeadBranches[P.nPDeadBranches, ] <- P.PBranches[i, ] # copy branches updated with death info to dead tree#
            if (length(P.PDeadBranches[, 1]) == P.nPDeadBranches) {# if dataframe containing dead branches is full#
              P.PDeadBranches <- rbind(P.PDeadBranches, data.frame(alive = rep(FALSE, DBINC), nodeBirth = 0, tBirth = 0,#
                                                                   nodeDeath = 0, tDeath = 0, Hassoc = 0, branchNo = 0))#
            }#
#
            P.PBranches         <- rbind(P.PBranches, c(TRUE, P.nextPNode, timepoint, 0, 0,#
                                                        HBranches$branchNo[P.oldHost], P.nPBranches + 1))#
            P.PBranches         <- rbind(P.PBranches, c(TRUE, P.nextPNode, timepoint, 0, 0,#
                                                        HBranches$branchNo[newHost], P.nPBranches + 2))#
            P.parasitesToDelete <- c(P.parasitesToDelete, i)#
            P.nextPNode         <- P.nextPNode + 1#
            P.nPAlive           <- P.nPAlive + 1#
            P.nPBranches        <- P.nPBranches + 2#
          }#
        }#
      }#
      if (length(P.parasitesToDelete) > 0) {#
        P.PBranches <- P.PBranches[-P.parasitesToDelete, ] # removing all mother parasite branches that have host jumped#
      }#
    }#
    }#
#
    # Q parasite host-jumps#
    if (t >= Q.startT) {#
      Q.noParasitesToJump	<- rbinom(1, Q.nPAlive, beta * nHAlive)#
#
      if (Q.noParasitesToJump > 0) {#
      Q.parasitesToJump		<- sample.int(Q.nPAlive, Q.noParasitesToJump) # which parasites#
      Q.parasitesToJump		<- Q.parasitesToJump[Q.PBranches$tBirth[Q.parasitesToJump] < (t - timestep)] # remove those that have just arisen in the same timestep; this is necessary to avoid problems such as negative branch lenghts#
      Q.parasitesToDelete <- numeric(0)  # this will become the vector of row numbers for rows to be deleted from PBranches afterwards#
#
      for (i in Q.parasitesToJump) {#
        Q.oldHost    <- which(HBranches$branchNo == Q.PBranches$Hassoc[i])   # row number of old host#
        Q.otherHosts <- (1:nHAlive)[-Q.oldHost]  # row numbers of all living hosts except the original one#
#
        if(length(Q.otherHosts) > 0) {#
          newHost           <- Q.otherHosts[sample.int(length(Q.otherHosts), 1)]  # randomly choose branch number of new host#
          Q.probEstablish   <- (exp(-gamma.Q * Gdist[Q.oldHost, newHost])) # determine if Parasite switch to new host is successful,depending on genetic distance#
          P.estabInfections <- length(which(P.PBranches$Hassoc == HBranches$branchNo[newHost]))  # no of parasites already infecting the potential new host#
          Q.estabInfections <- length(which(Q.PBranches$Hassoc == HBranches$branchNo[newHost]))  # no of parasites already infecting the potential new host#
          Q.probEstablish   <- Q.probEstablish * (sigma.self^Q.estabInfections) * (sigma.cross^P.estabInfections) # determine if parasite switch to new host is successful, depending on genetic distance and new host infection status#
#
          if (runif(1) < Q.probEstablish) {# if host jump was successful#
            timepoint							   <- t - runif(1, max = timestep) # random timepoint for jump#
            Q.PBranches$nodeDeath[i] <- Q.nextPNode#
            Q.PBranches$tDeath[i]    <- timepoint#
            Q.PBranches$alive[i]     <- FALSE#
#
            Q.nPDeadBranches				 <- Q.nPDeadBranches + 1#
            Q.PDeadBranches[Q.nPDeadBranches, ] <- Q.PBranches[i, ] # copy branches updated with death info to dead tree#
            if (length(Q.PDeadBranches[, 1]) == Q.nPDeadBranches) {# if dataframe containing dead branches is full#
              Q.PDeadBranches <- rbind(Q.PDeadBranches, data.frame(alive = rep(FALSE, DBINC), nodeBirth = 0, tBirth = 0,#
                                                                   nodeDeath = 0, tDeath = 0, Hassoc = 0, branchNo = 0))#
            }#
#
            Q.PBranches         <- rbind(Q.PBranches, c(TRUE, Q.nextPNode, timepoint, 0, 0,#
                                                        HBranches$branchNo[Q.oldHost], Q.nPBranches + 1))#
            Q.PBranches         <- rbind(Q.PBranches, c(TRUE, Q.nextPNode, timepoint, 0, 0,#
                                                        HBranches$branchNo[newHost], Q.nPBranches + 2))#
            Q.parasitesToDelete <- c(Q.parasitesToDelete, i)#
            Q.nextPNode         <- Q.nextPNode + 1#
            Q.nPAlive           <- Q.nPAlive + 1#
            Q.nPBranches        <- Q.nPBranches + 2#
          }#
        }#
      }#
      if (length(Q.parasitesToDelete) > 0) {#
        Q.PBranches <- Q.PBranches[-Q.parasitesToDelete, ] # removing all mother parasite branches that have host jumped#
      }#
    }#
    }#
#
    if (((round(t / timestep) * timestep) >= tmax) || ((P.nPAlive == 0) && (Q.nPAlive == 0))) {#
      continue <- FALSE # abort simulation in the case that tmax has already been reached#
                        # or there are no living parasites.#
    }#
    #if (((P.nPAlive == 0) && (t < Q.startT)) || ((Q.nPAlive == 0) && (t < P.startT))) {#
    	#  continue <- FALSE # abort simulation in the case that one lineage goes extinct #
    #                    # before the other is introduced.#
    #}#
  } # loop back up to next t#
#
  # setting final times and nodes:#
  if (P.nPAlive > 0) {#
    P.PBranches$tDeath		<- t#
    P.PBranches$nodeDeath	<- P.nextPNode:(P.nextPNode + P.nPAlive - 1)#
  }#
  if (Q.nPAlive > 0) {#
    Q.PBranches$tDeath		<-t#
    Q.PBranches$nodeDeath	<-Q.nextPNode:(Q.nextPNode + Q.nPAlive - 1)#
  }#
#
  # recovering the original host tree:#
#
  HBranches	<- H.tree#
#
  # merging two P matricies together:#
#
  P.PBranches	<- rbind(P.PBranches, P.PDeadBranches[1:P.nPDeadBranches, ])#
  P.PBranches	<- P.PBranches[order(P.PBranches[, "branchNo"]), ]#
#
  Q.PBranches	<- rbind(Q.PBranches, Q.PDeadBranches[1:Q.nPDeadBranches, ])#
  Q.PBranches	<- Q.PBranches[order(Q.PBranches[, "branchNo"]), ]#
#
  if (export.format == "Phylo") { # return cophylogeny as an APE Phylo class#
    H.phylo     <- convert_HBranchesToPhylo(HBranches)#
    PandQ.phylo <- convert_PQBranchesToPhylo(P.PBranches, Q.PBranches)#
    return(list(H.phylo, PandQ.phylo[[1]], PandQ.phylo[[2]]))#
  } else if (export.format == "Raw") { # return the HBranches and PBranches lists as they are#
    return(list(HBranches, P.PBranches, Q.PBranches))#
  } else if (export.format == "PhyloPonly") {# return only the parasite tree, converted in Phylo format#
    PandQ.phylo <- convert_PQBranchesToPhylo(P.PBranches, Q.PBranches)#
    return(list(PandQ.phylo[[1]], PandQ.phylo[[2]]))#
  }#
}
ls
library(devtools)
library(roxygen2)
getwd()
setwd("Desktop/cophy")
document()
install("../cophy")
